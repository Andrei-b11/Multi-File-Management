#!/usr/bin/env python3
"""
Aplicaci√≥n de Gesti√≥n de Archivos y Carpetas
"""

import sys
import os
import json
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta

from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QScrollArea,
    QFrame,
    QLabel,
    QPushButton,
    QMessageBox,
    QMenu,
    QFileDialog,
    QLineEdit,
    QDialog,
    QDialogButtonBox,
    QTextEdit,
    QSplitter,
    QListWidget,
    QListWidgetItem,
    QTabWidget,
    QProgressBar,
    QTreeWidget,
    QTreeWidgetItem,
    QGroupBox,
    QGridLayout,
    QCheckBox,
    QSpinBox,
    QSystemTrayIcon,
    QComboBox,
    QCalendarWidget,
    QSizePolicy,
    QTableWidget,
    QTableWidgetItem,
)
from PyQt6.QtCore import (
    Qt,
    QMimeData,
    QUrl,
    QTimer,
    pyqtSignal,
    QThread,
    QObject,
    QMutex,
    pyqtSlot,
    QSize,
)
from PyQt6.QtGui import (
    QDragEnterEvent,
    QDropEvent,
    QDrag,
    QPixmap,
    QIcon,
    QFont,
    QPalette,
    QColor,
    QAction,
    QKeySequence,
)
import threading
import re
import time
import socket
import configparser
import tempfile
import uuid
import weakref
from functools import lru_cache
import logging
from concurrent.futures import ThreadPoolExecutor
import subprocess

# Imports para hooks globales y detecci√≥n de Windows
try:
    import pynput
    from pynput import keyboard
    import win32gui
    import win32con
    import win32api
    import win32process
    import psutil

    GLOBAL_HOOKS_AVAILABLE = True
except ImportError:
    GLOBAL_HOOKS_AVAILABLE = False
    print("Advertencia: pynput o pywin32 no disponible. Hooks globales deshabilitados.")


# Funci√≥n auxiliar para establecer el icono de la aplicaci√≥n
def set_window_icon(window):
    """Establecer el icono de la ventana desde logo_con_f.png"""
    icon_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "logo_con_f.png"
    )
    if os.path.exists(icon_path):
        window.setWindowIcon(QIcon(icon_path))


def normalize_network_path(path: str) -> str:
    r"""
    Normalizar rutas de red UNC para Windows.
    PyQt6's toLocalFile() puede devolver rutas con // en lugar de \\
    Esta funci√≥n convierte //servidor/carpeta a \\servidor\carpeta
    """
    if not path:
        return path

    # Si la ruta empieza con // (formato incorrecto de red en Windows)
    if path.startswith("//") and not path.startswith("///"):
        # Convertir // a \\ y todas las / a \
        path = "\\\\" + path[2:].replace("/", "\\")
    elif path.startswith("///"):
        # Caso especial: ///servidor/carpeta -> \\servidor\carpeta
        path = "\\\\" + path[3:].replace("/", "\\")
    elif "//" in path:
        # Reemplazar cualquier // interno por \\
        path = path.replace("//", "\\\\").replace("/", "\\")

    # Normalizar barras en general para rutas locales tambi√©n
    if os.name == "nt":  # Solo en Windows
        path = path.replace("/", "\\")

    return path


# Funci√≥n auxiliar para obtener iconos de archivos
def get_file_icon_by_extension(file_path, is_directory=False):
    """Obtener icono emoji espec√≠fico seg√∫n tipo de archivo"""
    # Si es carpeta
    if is_directory:
        return "üìÅ"

    # Obtener extensi√≥n del archivo
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()

    # Iconos por tipo de archivo
    icon_map = {
        # Im√°genes
        ".png": "üñºÔ∏è",
        ".jpg": "üñºÔ∏è",
        ".jpeg": "üñºÔ∏è",
        ".gif": "üñºÔ∏è",
        ".bmp": "üñºÔ∏è",
        ".svg": "üñºÔ∏è",
        ".webp": "üñºÔ∏è",
        ".ico": "üñºÔ∏è",
        # Videos
        ".mp4": "üé¨",
        ".avi": "üé¨",
        ".mkv": "üé¨",
        ".mov": "üé¨",
        ".wmv": "üé¨",
        ".flv": "üé¨",
        ".webm": "üé¨",
        ".m4v": "üé¨",
        # Audio
        ".mp3": "üéµ",
        ".wav": "üéµ",
        ".flac": "üéµ",
        ".aac": "üéµ",
        ".ogg": "üéµ",
        ".m4a": "üéµ",
        ".wma": "üéµ",
        # Documentos
        ".pdf": "üìï",
        ".doc": "üìò",
        ".docx": "üìò",
        ".txt": "üìù",
        ".rtf": "üìù",
        ".odt": "üìò",
        # Hojas de c√°lculo
        ".xlsx": "üìä",
        ".xls": "üìä",
        ".csv": "üìä",
        ".ods": "üìä",
        # Presentaciones
        ".pptx": "üìΩÔ∏è",
        ".ppt": "üìΩÔ∏è",
        ".odp": "üìΩÔ∏è",
        # C√≥digo
        ".py": "üêç",
        ".js": "üìú",
        ".ts": "üìú",
        ".html": "üåê",
        ".css": "üé®",
        ".cpp": "‚öôÔ∏è",
        ".c": "‚öôÔ∏è",
        ".h": "‚öôÔ∏è",
        ".java": "‚òï",
        ".go": "üêπ",
        ".rs": "ü¶Ä",
        ".php": "üêò",
        ".rb": "üíé",
        ".swift": "ü¶Ö",
        ".kt": "üéØ",
        # Archivos comprimidos
        ".zip": "üì¶",
        ".rar": "üì¶",
        ".7z": "üì¶",
        ".tar": "üì¶",
        ".gz": "üì¶",
        ".bz2": "üì¶",
        # Ejecutables
        ".exe": "‚öôÔ∏è",
        ".msi": "‚öôÔ∏è",
        ".app": "‚öôÔ∏è",
        ".deb": "‚öôÔ∏è",
        ".rpm": "‚öôÔ∏è",
        ".dmg": "‚öôÔ∏è",
        # Datos/Config
        ".json": "‚öôÔ∏è",
        ".xml": "‚öôÔ∏è",
        ".yaml": "‚öôÔ∏è",
        ".yml": "‚öôÔ∏è",
        ".ini": "‚öôÔ∏è",
        ".cfg": "‚öôÔ∏è",
        ".conf": "‚öôÔ∏è",
        ".sep": "üí°",
        ".dwg": "‚úèÔ∏è",
        # Bases de datos
        ".db": "üóÑÔ∏è",
        ".sqlite": "üóÑÔ∏è",
        ".sql": "üóÑÔ∏è",
        # Fuentes
        ".ttf": "üî§",
        ".otf": "üî§",
        ".woff": "üî§",
        ".woff2": "üî§",
        # Dise√±o
        ".psd": "üé®",
        ".ai": "üé®",
        ".sketch": "üé®",
        ".fig": "üé®",
        ".xd": "üé®",
    }

    # Devolver icono espec√≠fico o gen√©rico
    return icon_map.get(ext, "üìÑ")


class WindowGeometryManager:
    """Gestor de geometr√≠a y configuraci√≥n de ventanas"""

    def __init__(self):
        self.settings_file = "window_settings.ini"
        self.config = configparser.ConfigParser()
        self.load_settings()

    def load_settings(self):
        """Cargar configuraciones guardadas"""
        try:
            self.config.read(self.settings_file)
        except:
            pass

    def save_settings(self):
        """Guardar configuraciones"""
        try:
            with open(self.settings_file, "w") as f:
                self.config.write(f)
        except:
            pass

    def save_window_geometry(self, window_name, geometry):
        """Guardar geometr√≠a de ventana"""
        if not self.config.has_section("Windows"):
            self.config.add_section("Windows")

        self.config.set("Windows", f"{window_name}_x", str(geometry.x()))
        self.config.set("Windows", f"{window_name}_y", str(geometry.y()))
        self.config.set("Windows", f"{window_name}_width", str(geometry.width()))
        self.config.set("Windows", f"{window_name}_height", str(geometry.height()))
        self.save_settings()

    def restore_window_geometry(self, window, window_name, default_size=(800, 600)):
        """Restaurar geometr√≠a de ventana"""
        try:
            if self.config.has_section("Windows"):
                x = self.config.getint("Windows", f"{window_name}_x", fallback=100)
                y = self.config.getint("Windows", f"{window_name}_y", fallback=100)
                width = self.config.getint(
                    "Windows", f"{window_name}_width", fallback=default_size[0]
                )
                height = self.config.getint(
                    "Windows", f"{window_name}_height", fallback=default_size[1]
                )

                window.setGeometry(x, y, width, height)
            else:
                window.resize(default_size[0], default_size[1])
        except:
            window.resize(default_size[0], default_size[1])


class ThemeManager:
    """Gestor de temas y estilos"""

    def __init__(self):
        self.current_theme = "dark"
        self.themes = {
            "dark": {
                "name": "üåô Oscuro",
                "bg_primary": "#1a1a1a",
                "bg_secondary": "#2a2a2a",
                "bg_tertiary": "#3a3a3a",
                "text_primary": "#ffffff",
                "text_secondary": "#cccccc",
                "text_tertiary": "#888888",
                "accent": "#4a90e2",
                "accent_hover": "#357abd",
                "success": "#28a745",
                "success_hover": "#218838",
                "warning": "#ffc107",
                "danger": "#dc3545",
                "danger_hover": "#c82333",
                "border": "#555555",
            },
            "light": {
                "name": "‚òÄÔ∏è Claro",
                "bg_primary": "#ffffff",
                "bg_secondary": "#f8f9fa",
                "bg_tertiary": "#e9ecef",
                "text_primary": "#212529",
                "text_secondary": "#495057",
                "text_tertiary": "#6c757d",
                "accent": "#007bff",
                "accent_hover": "#0056b3",
                "success": "#28a745",
                "success_hover": "#1e7e34",
                "warning": "#ffc107",
                "danger": "#dc3545",
                "danger_hover": "#bd2130",
                "border": "#dee2e6",
            },
            "purple": {
                "name": "üíú P√∫rpura",
                "bg_primary": "#1e1729",
                "bg_secondary": "#2b2239",
                "bg_tertiary": "#3d2e4f",
                "text_primary": "#e8def8",
                "text_secondary": "#d1c4e9",
                "text_tertiary": "#9575cd",
                "accent": "#9c27b0",
                "accent_hover": "#7b1fa2",
                "success": "#4caf50",
                "success_hover": "#388e3c",
                "warning": "#ff9800",
                "danger": "#f44336",
                "danger_hover": "#d32f2f",
                "border": "#4a3a5f",
            },
            "ocean": {
                "name": "üåä Oc√©ano",
                "bg_primary": "#0a192f",
                "bg_secondary": "#112240",
                "bg_tertiary": "#1d3557",
                "text_primary": "#ccd6f6",
                "text_secondary": "#8892b0",
                "text_tertiary": "#495670",
                "accent": "#00b4d8",
                "accent_hover": "#0096c7",
                "success": "#06ffa5",
                "success_hover": "#05e594",
                "warning": "#ffd60a",
                "danger": "#ff006e",
                "danger_hover": "#d90059",
                "border": "#233554",
            },
            "forest": {
                "name": "üå≤ Bosque",
                "bg_primary": "#1a2b1a",
                "bg_secondary": "#243329",
                "bg_tertiary": "#2e4a35",
                "text_primary": "#e8f5e9",
                "text_secondary": "#c8e6c9",
                "text_tertiary": "#81c784",
                "accent": "#4caf50",
                "accent_hover": "#388e3c",
                "success": "#66bb6a",
                "success_hover": "#43a047",
                "warning": "#ffb74d",
                "danger": "#ef5350",
                "danger_hover": "#e53935",
                "border": "#3d5a40",
            },
            "sunset": {
                "name": "üåÖ Atardecer",
                "bg_primary": "#2b1a1a",
                "bg_secondary": "#3d2424",
                "bg_tertiary": "#4f2e2e",
                "text_primary": "#ffe0cc",
                "text_secondary": "#ffc2a3",
                "text_tertiary": "#ff9966",
                "accent": "#ff6b35",
                "accent_hover": "#e55a2e",
                "success": "#4ecdc4",
                "success_hover": "#3db9b0",
                "warning": "#f7b801",
                "danger": "#e63946",
                "danger_hover": "#d62828",
                "border": "#5a3535",
            },
            "cyberpunk": {
                "name": "üîÆ Cyberpunk",
                "bg_primary": "#0d0221",
                "bg_secondary": "#16033d",
                "bg_tertiary": "#240046",
                "text_primary": "#f72585",
                "text_secondary": "#b5179e",
                "text_tertiary": "#7209b7",
                "accent": "#00f5ff",
                "accent_hover": "#00d9e6",
                "success": "#39ff14",
                "success_hover": "#2ee60c",
                "warning": "#ffff00",
                "danger": "#ff006e",
                "danger_hover": "#d90059",
                "border": "#560bad",
            },
            "nord": {
                "name": "‚ùÑÔ∏è N√≥rdico",
                "bg_primary": "#2e3440",
                "bg_secondary": "#3b4252",
                "bg_tertiary": "#434c5e",
                "text_primary": "#eceff4",
                "text_secondary": "#e5e9f0",
                "text_tertiary": "#d8dee9",
                "accent": "#88c0d0",
                "accent_hover": "#5e81ac",
                "success": "#a3be8c",
                "success_hover": "#8fb573",
                "warning": "#ebcb8b",
                "danger": "#bf616a",
                "danger_hover": "#a84d57",
                "border": "#4c566a",
            },
            "dracula": {
                "name": "üßõ Dr√°cula",
                "bg_primary": "#282a36",
                "bg_secondary": "#343746",
                "bg_tertiary": "#44475a",
                "text_primary": "#f8f8f2",
                "text_secondary": "#e6e6e6",
                "text_tertiary": "#cccccc",
                "accent": "#bd93f9",
                "accent_hover": "#9f7fd1",
                "success": "#50fa7b",
                "success_hover": "#3ee066",
                "warning": "#f1fa8c",
                "danger": "#ff5555",
                "danger_hover": "#e64444",
                "border": "#6272a4",
            },
            "monokai": {
                "name": "üé∏ Monokai",
                "bg_primary": "#272822",
                "bg_secondary": "#3e3d32",
                "bg_tertiary": "#49483e",
                "text_primary": "#f8f8f2",
                "text_secondary": "#cfcfc2",
                "text_tertiary": "#a6a69f",
                "accent": "#66d9ef",
                "accent_hover": "#4fc4e0",
                "success": "#a6e22e",
                "success_hover": "#8ec926",
                "warning": "#e6db74",
                "danger": "#f92672",
                "danger_hover": "#e01661",
                "border": "#75715e",
            },
            "solarized": {
                "name": "üåû Solarized",
                "bg_primary": "#002b36",
                "bg_secondary": "#073642",
                "bg_tertiary": "#0f4753",
                "text_primary": "#fdf6e3",
                "text_secondary": "#eee8d5",
                "text_tertiary": "#93a1a1",
                "accent": "#268bd2",
                "accent_hover": "#1f6fa8",
                "success": "#859900",
                "success_hover": "#6d7e00",
                "warning": "#cb4b16",
                "danger": "#dc322f",
                "danger_hover": "#b32826",
                "border": "#586e75",
            },
            "gruvbox": {
                "name": "üé® Gruvbox",
                "bg_primary": "#282828",
                "bg_secondary": "#3c3836",
                "bg_tertiary": "#504945",
                "text_primary": "#ebdbb2",
                "text_secondary": "#d5c4a1",
                "text_tertiary": "#bdae93",
                "accent": "#83a598",
                "accent_hover": "#6b8396",
                "success": "#b8bb26",
                "success_hover": "#98971a",
                "warning": "#fabd2f",
                "danger": "#fb4934",
                "danger_hover": "#cc241d",
                "border": "#665c54",
            },
            "tokyo_night": {
                "name": "üóº Tokyo Night",
                "bg_primary": "#1a1b26",
                "bg_secondary": "#24283b",
                "bg_tertiary": "#2f3549",
                "text_primary": "#c0caf5",
                "text_secondary": "#a9b1d6",
                "text_tertiary": "#565f89",
                "accent": "#7aa2f7",
                "accent_hover": "#5884d6",
                "success": "#9ece6a",
                "success_hover": "#7fb652",
                "warning": "#e0af68",
                "danger": "#f7768e",
                "danger_hover": "#e65c75",
                "border": "#414868",
            },
            "cherry_blossom": {
                "name": "üå∏ Sakura",
                "bg_primary": "#2d1820",
                "bg_secondary": "#3d2430",
                "bg_tertiary": "#4d3040",
                "text_primary": "#ffd6e8",
                "text_secondary": "#ffb3d9",
                "text_tertiary": "#ff8fc7",
                "accent": "#ff6ba9",
                "accent_hover": "#ff4d96",
                "success": "#88d498",
                "success_hover": "#6bc783",
                "warning": "#ffb347",
                "danger": "#ff5e78",
                "danger_hover": "#ff3d5f",
                "border": "#5d4050",
            },
            "midnight_blue": {
                "name": "üåÉ Medianoche",
                "bg_primary": "#0c1445",
                "bg_secondary": "#141d5c",
                "bg_tertiary": "#1e2973",
                "text_primary": "#d4e4ff",
                "text_secondary": "#b3ccff",
                "text_tertiary": "#8ab0ff",
                "accent": "#4169e1",
                "accent_hover": "#2c4ab8",
                "success": "#5fdb9e",
                "success_hover": "#3ec984",
                "warning": "#ffa726",
                "danger": "#ff5252",
                "danger_hover": "#e63939",
                "border": "#2a3680",
            },
            "desert_sand": {
                "name": "üèúÔ∏è Desierto",
                "bg_primary": "#2d2416",
                "bg_secondary": "#3d321d",
                "bg_tertiary": "#4d4024",
                "text_primary": "#f5e6d3",
                "text_secondary": "#e8d4b8",
                "text_tertiary": "#d4b896",
                "accent": "#d4a574",
                "accent_hover": "#b8895e",
                "success": "#8bc34a",
                "success_hover": "#6fa52f",
                "warning": "#ff9f1c",
                "danger": "#e74c3c",
                "danger_hover": "#c0392b",
                "border": "#5d4e30",
            },
            "aurora": {
                "name": "üåå Aurora",
                "bg_primary": "#0f1626",
                "bg_secondary": "#1b2538",
                "bg_tertiary": "#273449",
                "text_primary": "#c7f9ff",
                "text_secondary": "#a0e7ff",
                "text_tertiary": "#70d4ff",
                "accent": "#00ffaa",
                "accent_hover": "#00d98f",
                "success": "#52ffa8",
                "success_hover": "#2fe68e",
                "warning": "#ffd93d",
                "danger": "#ff5ea0",
                "danger_hover": "#ff3b87",
                "border": "#344b5e",
            },
            "coffee": {
                "name": "‚òï Caf√©",
                "bg_primary": "#1f1410",
                "bg_secondary": "#2e1e18",
                "bg_tertiary": "#3d2820",
                "text_primary": "#e8d5c4",
                "text_secondary": "#d4b9a4",
                "text_tertiary": "#b89878",
                "accent": "#a67c52",
                "accent_hover": "#8d6843",
                "success": "#7cb342",
                "success_hover": "#5a9216",
                "warning": "#ffa000",
                "danger": "#d84315",
                "danger_hover": "#bf360c",
                "border": "#4d3528",
            },
            "mint": {
                "name": "üçÉ Menta",
                "bg_primary": "#0e2520",
                "bg_secondary": "#16332e",
                "bg_tertiary": "#1f413c",
                "text_primary": "#d4f8e8",
                "text_secondary": "#b3efd8",
                "text_tertiary": "#8ae3c5",
                "accent": "#00d9a3",
                "accent_hover": "#00b886",
                "success": "#26de81",
                "success_hover": "#0dc765",
                "warning": "#fed330",
                "danger": "#fc5c65",
                "danger_hover": "#eb3b5a",
                "border": "#2d4f4a",
            },
            "lava": {
                "name": "üåã Lava",
                "bg_primary": "#1a0a0a",
                "bg_secondary": "#2d1212",
                "bg_tertiary": "#401a1a",
                "text_primary": "#ffe6e6",
                "text_secondary": "#ffcccc",
                "text_tertiary": "#ff9999",
                "accent": "#ff4500",
                "accent_hover": "#e03d00",
                "success": "#32cd32",
                "success_hover": "#28a428",
                "warning": "#ff8c00",
                "danger": "#ff0000",
                "danger_hover": "#cc0000",
                "border": "#522222",
            },
            "galaxy": {
                "name": "‚ú® Galaxia",
                "bg_primary": "#0a0420",
                "bg_secondary": "#150833",
                "bg_tertiary": "#200c46",
                "text_primary": "#e8d5ff",
                "text_secondary": "#d4b8ff",
                "text_tertiary": "#b08cff",
                "accent": "#8b5cf6",
                "accent_hover": "#7c3aed",
                "success": "#34d399",
                "success_hover": "#10b981",
                "warning": "#fbbf24",
                "danger": "#f87171",
                "danger_hover": "#ef4444",
                "border": "#2e1454",
            },
            "coral": {
                "name": "ü™∏ Coral",
                "bg_primary": "#2a1616",
                "bg_secondary": "#3a2020",
                "bg_tertiary": "#4a2a2a",
                "text_primary": "#ffe4e1",
                "text_secondary": "#ffc8c3",
                "text_tertiary": "#ff9e99",
                "accent": "#ff7f50",
                "accent_hover": "#ff6347",
                "success": "#3bb273",
                "success_hover": "#2d9561",
                "warning": "#ffb84d",
                "danger": "#ff5252",
                "danger_hover": "#e63939",
                "border": "#5a3434",
            },
            "slate": {
                "name": "üóø Pizarra",
                "bg_primary": "#1e1e2e",
                "bg_secondary": "#2a2a3e",
                "bg_tertiary": "#36364e",
                "text_primary": "#e4e4f0",
                "text_secondary": "#c9c9d9",
                "text_tertiary": "#a0a0b8",
                "accent": "#7287fd",
                "accent_hover": "#5c6dd6",
                "success": "#40c057",
                "success_hover": "#2f9e44",
                "warning": "#fab005",
                "danger": "#fa5252",
                "danger_hover": "#e03131",
                "border": "#45455e",
            },
        }

    def get_theme_names(self):
        """Obtener lista de nombres de temas disponibles"""
        return {key: value["name"] for key, value in self.themes.items()}

    def get_stylesheet(self, component_type="main"):
        """Obtener stylesheet para componente espec√≠fico"""
        theme = self.themes[self.current_theme]

        if component_type == "main":
            return f"""
                QMainWindow {{
                    background-color: {theme["bg_primary"]};
                    color: {theme["text_primary"]};
                }}
                QWidget {{
                    background-color: {theme["bg_primary"]};
                    color: {theme["text_primary"]};
                }}
                QTabWidget::pane {{
                    border: 1px solid {theme["border"]};
                    background-color: {theme["bg_primary"]};
                }}
                QTabBar::tab {{
                    background-color: {theme["bg_secondary"]};
                    color: {theme["text_primary"]};
                    padding: 10px 20px;
                    margin-right: 2px;
                    border: 1px solid {theme["border"]};
                    border-bottom: none;
                    border-radius: 4px 4px 0 0;
                }}
                QTabBar::tab:selected {{
                    background-color: {theme["accent"]};
                }}
                QTabBar::tab:hover {{
                    background-color: {theme["bg_tertiary"]};
                }}
                QMenuBar {{
                    background-color: {theme["bg_secondary"]};
                    color: {theme["text_primary"]};
                    padding: 4px;
                }}
                QMenuBar::item {{
                    background-color: transparent;
                    padding: 8px 12px;
                    border-radius: 4px;
                }}
                QMenuBar::item:selected {{
                    background-color: {theme["accent"]};
                }}
                QMenu {{
                    background-color: {theme["bg_secondary"]};
                    color: {theme["text_primary"]};
                    border: 1px solid {theme["border"]};
                    border-radius: 4px;
                }}
                QMenu::item {{
                    padding: 8px 20px;
                    border-radius: 4px;
                    margin: 2px;
                }}
                QMenu::item:selected {{
                    background-color: {theme["accent"]};
                }}
                QStatusBar {{
                    background-color: {theme["bg_secondary"]};
                    color: {theme["text_secondary"]};
                    border-top: 1px solid {theme["border"]};
                }}
            """
        elif component_type == "dialog":
            return f"""
                QDialog {{
                    background-color: {theme["bg_primary"]};
                    color: {theme["text_primary"]};
                }}
                QGroupBox {{
                    font-weight: bold;
                    border: 2px solid {theme["border"]};
                    border-radius: 8px;
                    margin-top: 10px;
                    padding-top: 10px;
                }}
                QGroupBox::title {{
                    subcontrol-origin: margin;
                    left: 10px;
                    padding: 0 5px 0 5px;
                    color: {theme["accent"]};
                }}
                QLineEdit, QTextEdit, QSpinBox {{
                    background-color: {theme["bg_secondary"]};
                    border: 2px solid {theme["border"]};
                    border-radius: 4px;
                    padding: 8px;
                    color: {theme["text_primary"]};
                }}
                QLineEdit:focus, QTextEdit:focus, QSpinBox:focus {{
                    border-color: {theme["accent"]};
                }}
                QPushButton {{
                    background-color: {theme["accent"]};
                    border: none;
                    border-radius: 6px;
                    color: white;
                    padding: 10px 20px;
                    font-weight: bold;
                    font-size: 10pt;
                }}
                QPushButton:hover {{
                    background-color: {theme["accent_hover"]};
                }}
                QPushButton:disabled {{
                    background-color: {theme["text_tertiary"]};
                }}
            """

    def toggle_theme(self):
        """Alternar entre temas oscuro y claro"""
        self.current_theme = "light" if self.current_theme == "dark" else "dark"

    def set_theme(self, theme_key):
        """Establecer tema espec√≠fico"""
        if theme_key in self.themes:
            self.current_theme = theme_key


class GlobalHotkeyManager(QObject):
    """Gestor de atajos globales del sistema usando threading"""

    # Se√±ales para comunicarse con el hilo principal
    global_paste_triggered = pyqtSignal(str)
    global_copy_triggered = pyqtSignal()
    show_window_triggered = pyqtSignal()
    hide_window_triggered = pyqtSignal()

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.listener = None
        self.active = False
        self.thread = None
        self.config_manager = AdvancedConfigManager()
        # Conectar se√±ales al m√©todo del main window
        self.global_paste_triggered.connect(main_window.show_global_quick_paste)
        self.global_copy_triggered.connect(main_window.capture_selected_files)
        self.show_window_triggered.connect(main_window.show_main_window)
        self.hide_window_triggered.connect(main_window.hide_main_window)

    def start_global_listener(self):
        """Iniciar listener de atajos globales"""
        if not GLOBAL_HOOKS_AVAILABLE:
            return False

        try:
            import threading

            def run_listener():
                try:
                    # Obtener atajos configurables desde la configuraci√≥n
                    show_window_shortcut = self.config_manager.get(
                        "shortcuts", "show_window", "<ctrl>+<alt>+s"
                    )
                    hide_window_shortcut = self.config_manager.get(
                        "shortcuts", "hide_window", "<ctrl>+<alt>+h"
                    )
                    quick_paste_shortcut = self.config_manager.get(
                        "shortcuts", "quick_paste", "<ctrl>+<alt>+v"
                    )
                    quick_copy_shortcut = self.config_manager.get(
                        "shortcuts", "quick_copy", "<ctrl>+<alt>+c"
                    )

                    # Definir combinaciones de teclas
                    hotkey_combinations = {
                        quick_paste_shortcut: self.on_global_quick_paste,
                        quick_copy_shortcut: self.on_global_copy,
                        show_window_shortcut: self.on_show_window,
                        hide_window_shortcut: self.on_hide_window,
                    }

                    print(f"Atajos configurados:")
                    print(f"  - Pegado r√°pido: {quick_paste_shortcut}")
                    print(f"  - Copiar archivos: {quick_copy_shortcut}")
                    print(f"  - Mostrar ventana: {show_window_shortcut}")
                    print(f"  - Ocultar ventana: {hide_window_shortcut}")

                    # Crear y ejecutar listener
                    with keyboard.GlobalHotKeys(hotkey_combinations):
                        self.active = True
                        print("Hooks globales iniciados correctamente")
                        # Mantener el listener ejecut√°ndose
                        while self.active:
                            import time

                            time.sleep(0.1)

                except Exception as e:
                    print(f"Error en listener global: {e}")
                    self.active = False

            # Crear y iniciar hilo para el listener
            self.thread = threading.Thread(target=run_listener, daemon=True)
            self.thread.start()

            # Esperar un poco para confirmar que se inici√≥
            import time

            time.sleep(0.5)

            return self.active

        except Exception as e:
            print(f"Error iniciando hooks globales: {e}")
            return False

    def stop_global_listener(self):
        """Detener listener global"""
        self.active = False
        if self.listener:
            try:
                self.listener.stop()
            except:
                pass
        self.listener = None

    def on_global_quick_paste(self):
        """Callback para Ctrl+Alt+V global"""
        try:
            # Detectar carpeta activa
            target_folder = self.detect_current_folder()
            print(f"Ctrl+Alt+V detectado! Carpeta: {target_folder}")

            # Emitir se√±al para comunicar con el hilo principal
            self.global_paste_triggered.emit(target_folder or "")

        except Exception as e:
            print(f"Error en pegado global: {e}")

    def on_global_copy(self):
        """Callback para Ctrl+Alt+C global - Copiar archivos seleccionados"""
        try:
            print("Ctrl+Alt+C detectado! Capturando archivos seleccionados...")

            # Emitir se√±al para capturar archivos en el hilo principal
            self.global_copy_triggered.emit()

        except Exception as e:
            print(f"Error en copiado global: {e}")

    def on_show_window(self):
        """Callback para mostrar la ventana principal"""
        try:
            print("Atajo de mostrar ventana detectado!")
            # Emitir se√±al para mostrar ventana en el hilo principal
            self.show_window_triggered.emit()
        except Exception as e:
            print(f"Error mostrando ventana: {e}")

    def on_hide_window(self):
        """Callback para ocultar la ventana principal"""
        try:
            print("Atajo de ocultar ventana detectado!")
            # Emitir se√±al para ocultar ventana en el hilo principal
            self.hide_window_triggered.emit()
        except Exception as e:
            print(f"Error ocultando ventana: {e}")

    def detect_current_folder(self):
        """Detectar la carpeta actual donde est√° el usuario"""
        try:
            # Obtener ventana activa
            hwnd = win32gui.GetForegroundWindow()

            if hwnd == 0:
                return os.path.expanduser("~")  # Fallback a Home

            # Obtener informaci√≥n de la ventana
            window_title = win32gui.GetWindowText(hwnd)

            # Obtener proceso de la ventana
            _, pid = win32process.GetWindowThreadProcessId(hwnd)

            try:
                process = psutil.Process(pid)
                process_name = process.name().lower()

                # Detectar si es Explorer de Windows
                if "explorer.exe" in process_name:
                    return self.get_explorer_current_folder(hwnd, window_title)

                # Detectar si es el escritorio
                elif "dwm.exe" in process_name or window_title == "":
                    return self.get_desktop_path()

                # Otras aplicaciones - tratar de obtener directorio de trabajo
                else:
                    return self.get_process_working_directory(process)

            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass

            # Fallback
            return os.path.expanduser("~")

        except Exception as e:
            print(f"Error detectando carpeta: {e}")
            return os.path.expanduser("~")

    def get_explorer_current_folder(self, hwnd, title):
        """Obtener carpeta actual del Explorer de Windows"""
        try:
            # M√©todo 1: Intentar desde el t√≠tulo de ventana
            if title and (":\\" in title or title.startswith("\\\\")):
                # Si el t√≠tulo contiene una ruta, usarla
                normalized_title = normalize_network_path(title)
                if os.path.exists(normalized_title):
                    print(f"‚úì Carpeta detectada desde t√≠tulo: {normalized_title}")
                    return normalized_title

            # M√©todo 2: Usar COM para obtener carpeta del Explorer
            try:
                import win32com.client
                import urllib.parse

                shell = win32com.client.Dispatch("Shell.Application")

                for window in shell.Windows():
                    if window.HWND == hwnd:
                        location = window.LocationURL
                        print(f"LocationURL detectado: {location}")

                        # Rutas UNC de red: file://servidor/carpeta
                        if location.startswith("file://") and not location.startswith(
                            "file:///"
                        ):
                            # Es una ruta de red UNC
                            path = urllib.parse.unquote(
                                location[7:]
                            )  # Remover 'file://'
                            # Convertir a formato UNC de Windows
                            path = "\\\\" + path.replace("/", "\\")
                            print(f"Ruta UNC convertida: {path}")
                            if os.path.exists(path):
                                print(f"‚úì Carpeta de red detectada: {path}")
                                return path

                        # Rutas locales: file:///C:/carpeta
                        elif location.startswith("file:///"):
                            path = urllib.parse.unquote(
                                location[8:]
                            )  # Remover 'file:///'
                            # Normalizar ruta para soportar rutas de red UNC correctamente
                            path = normalize_network_path(path)
                            print(f"Ruta local convertida: {path}")
                            if os.path.exists(path):
                                print(f"‚úì Carpeta local detectada: {path}")
                                return path

                        break

            except Exception as e:
                print(f"Error en m√©todo COM: {e}")
                pass

            # M√©todo 3: Fallback usando el t√≠tulo
            if "Documentos" in title:
                return os.path.join(os.path.expanduser("~"), "Documents")
            elif "Escritorio" in title or "Desktop" in title:
                return self.get_desktop_path()
            elif "Descargas" in title or "Downloads" in title:
                return os.path.join(os.path.expanduser("~"), "Downloads")

            # √öltimo fallback
            print(f"‚ö† Usando fallback: carpeta de usuario")
            return os.path.expanduser("~")

        except Exception as e:
            print(f"Error obteniendo carpeta del Explorer: {e}")
            return os.path.expanduser("~")

    def get_desktop_path(self):
        """Obtener ruta del escritorio"""
        try:
            import winreg

            with winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders",
            ) as key:
                desktop_path, _ = winreg.QueryValueEx(key, "Desktop")
                return desktop_path
        except:
            # Fallback
            desktop = os.path.join(os.path.expanduser("~"), "Desktop")
            if os.path.exists(desktop):
                return desktop
            return os.path.join(os.path.expanduser("~"), "Escritorio")

    def get_process_working_directory(self, process):
        """Obtener directorio de trabajo de un proceso"""
        try:
            return process.cwd()
        except:
            return os.path.expanduser("~")


class GlobalQuickPasteDialog(QDialog):
    """Di√°logo especializado para pegado global con detecci√≥n autom√°tica de carpeta"""

    def __init__(self, items_list, target_folder, parent=None):
        super().__init__(parent)
        self.items_list = items_list
        self.target_folder = target_folder or os.path.expanduser("~")
        self.selected_items = []
        self.config_manager = AdvancedConfigManager()
        self.setWindowTitle("‚ö° Pegado Global - Ctrl+Alt+V")
        set_window_icon(self)
        self.setWindowFlags(
            Qt.WindowType.Dialog
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
            | Qt.WindowType.WindowCloseButtonHint
        )
        self.setMinimumSize(600, 450)
        self.resize(800, 650)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        self.setup_shortcuts()
        self.position_near_cursor()
        # Asegurar que el di√°logo est√© siempre visible
        self.raise_()
        self.activateWindow()

    def setup_ui(self):
        """Configurar interfaz del pegado global"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(12, 12, 12, 12)

        # T√≠tulo principal
        title_label = QLabel("‚ö° Pegado Global - Detecci√≥n Autom√°tica")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #ff6b35; margin-bottom: 5px;")
        layout.addWidget(title_label)

        # Mostrar carpeta detectada autom√°ticamente
        folder_group = QGroupBox("üìÅ Carpeta Detectada Autom√°ticamente")
        folder_layout = QVBoxLayout(folder_group)

        self.folder_label = QLabel(f"üìÇ {self.target_folder}")
        self.folder_label.setStyleSheet("""
            color: #4a90e2;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            padding: 8px;
            background-color: rgba(74, 144, 226, 0.1);
            border-radius: 4px;
        """)
        self.folder_label.setWordWrap(True)
        folder_layout.addWidget(self.folder_label)

        # Bot√≥n para cambiar carpeta
        change_folder_layout = QHBoxLayout()
        change_folder_btn = QPushButton("üìÇ Cambiar Carpeta")
        change_folder_btn.clicked.connect(self.change_target_folder)
        change_folder_btn.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
        """)

        detect_again_btn = QPushButton("üîç Detectar de Nuevo")
        detect_again_btn.clicked.connect(self.detect_folder_again)
        detect_again_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #138496;
            }
        """)

        change_folder_layout.addWidget(change_folder_btn)
        change_folder_layout.addWidget(detect_again_btn)
        change_folder_layout.addStretch()
        folder_layout.addLayout(change_folder_layout)

        layout.addWidget(folder_group)

        # Lista de archivos para pegar
        files_group = QGroupBox(
            f"üìã Archivos Disponibles ({len(self.items_list)} elementos)"
        )
        files_layout = QVBoxLayout(files_group)

        # TreeWidget para selecci√≥n con columna de renombrado
        self.items_tree = QTreeWidget()
        self.items_tree.setHeaderLabels(
            ["", "Archivo/Carpeta", "Nuevo Nombre", "Origen"]
        )
        self.items_tree.setRootIsDecorated(False)
        self.items_tree.setAlternatingRowColors(True)
        self.items_tree.setMaximumHeight(180)

        # Poblar con archivos
        for item in self.items_list:
            tree_item = QTreeWidgetItem()
            tree_item.setFlags(
                tree_item.flags()
                | Qt.ItemFlag.ItemIsUserCheckable
                | Qt.ItemFlag.ItemIsEditable
            )
            tree_item.setCheckState(0, Qt.CheckState.Checked)

            icon = get_file_icon_by_extension(item.path, item.is_directory)
            tree_item.setText(1, f"{icon} {item.name}")
            tree_item.setText(2, item.name)  # Nuevo nombre (editable - doble click)
            tree_item.setText(3, os.path.dirname(item.path))
            tree_item.setData(0, Qt.ItemDataRole.UserRole, item)
            tree_item.setToolTip(2, "Doble click para editar el nombre")

            if item.is_directory:
                tree_item.setBackground(1, QColor(54, 162, 235, 30))
            else:
                tree_item.setBackground(1, QColor(75, 192, 192, 30))

            # Color especial para columna editable
            tree_item.setBackground(2, QColor(100, 200, 100, 20))

            self.items_tree.addTopLevelItem(tree_item)

        for i in range(4):
            self.items_tree.resizeColumnToContents(i)

        # Conectar doble click para edici√≥n controlada
        self.items_tree.itemDoubleClicked.connect(self.on_item_double_clicked)

        files_layout.addWidget(self.items_tree)

        # Botones de selecci√≥n y renombrado
        selection_layout = QHBoxLayout()
        select_all_btn = QPushButton("‚òë Todo")
        select_all_btn.clicked.connect(self.select_all)
        select_none_btn = QPushButton("‚òê Nada")
        select_none_btn.clicked.connect(self.select_none)

        selection_layout.addWidget(select_all_btn)
        selection_layout.addWidget(select_none_btn)
        selection_layout.addStretch()

        files_layout.addLayout(selection_layout)

        # Botones de renombrado autom√°tico
        rename_layout = QHBoxLayout()
        rename_title = QLabel("<b>üîÑ Renombrado Autom√°tico:</b>")
        rename_title.setStyleSheet("color: #4a90e2; font-size: 10pt; margin-top: 8px;")
        rename_layout.addWidget(rename_title)
        rename_layout.addStretch()

        # Botones de patrones de renombrado
        rename_buttons = [
            ("üìÖ Fecha", "{date}_{name}"),
            ("üïê Hora", "{time_short}_{name}"),
            ("üî¢ Contador", "{name}_{counter:3}"),
            ("üë§ Usuario", "{user}_{name}"),
            ("üñ•Ô∏è PC", "{computer}_{name}"),
            ("üîí UUID", "{uuid_short}_{name}"),
            ("üìä Hash", "{hash_short}_{name}"),
            ("üßπ Limpio", "{clean:{name}}"),
        ]

        for text, pattern in rename_buttons:
            btn = QPushButton(text)
            btn.setToolTip(f"Patr√≥n: {pattern}")
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #3a3a3a;
                    border: 1px solid #555;
                    border-radius: 4px;
                    padding: 4px 8px;
                    color: #ffffff;
                    font-size: 8pt;
                    margin: 1px;
                }
                QPushButton:hover {
                    background-color: #217346;
                    border-color: #4a90e2;
                }
                QPushButton:pressed {
                    background-color: #357abd;
                }
            """)
            btn.clicked.connect(
                lambda checked, p=pattern: self.apply_rename_pattern_to_selected(p)
            )
            rename_layout.addWidget(btn)

        files_layout.addLayout(rename_layout)
        layout.addWidget(files_group)

        # Info de selecci√≥n
        self.selection_info = QLabel("Todos los elementos seleccionados")
        self.selection_info.setStyleSheet(
            "color: #888888; font-style: italic; font-size: 9pt;"
        )
        layout.addWidget(self.selection_info)

        # Opci√≥n para cerrar despu√©s de pegar
        close_after_layout = QHBoxLayout()
        self.close_after_paste_check = QCheckBox("Cerrar ventana despu√©s de pegar")
        self.close_after_paste_check.setChecked(
            self.config_manager.get("behavior", "close_quick_paste_after_pasting", True)
        )
        self.close_after_paste_check.setToolTip(
            "Si est√° marcado, la ventana se cerrar√° autom√°ticamente despu√©s de pegar.\n"
            "Si no est√° marcado, la ventana permanecer√° abierta para pegar m√°s archivos."
        )
        self.close_after_paste_check.toggled.connect(self.on_close_after_paste_toggled)
        self.close_after_paste_check.setStyleSheet("""
            QCheckBox {
                color: #cccccc;
                font-size: 9pt;
                padding: 5px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        close_after_layout.addWidget(self.close_after_paste_check)
        close_after_layout.addStretch()
        layout.addLayout(close_after_layout)

        # Botones principales
        buttons_layout = QHBoxLayout()

        self.paste_btn = QPushButton("‚ö° Pegar Ahora")
        self.paste_btn.clicked.connect(self.execute_global_paste)
        self.paste_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)

        buttons_layout.addWidget(self.paste_btn)
        buttons_layout.addWidget(self.cancel_btn)
        layout.addLayout(buttons_layout)

        # Conectar eventos
        self.items_tree.itemChanged.connect(self.update_selection_info)
        self.update_selection_info()

    def setup_style(self):
        """Configurar estilo del di√°logo global"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
                border: 2px solid #ff6b35;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555555;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #ff6b35;
            }
            QTreeWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                alternate-background-color: #3a3a3a;
            }
            QTreeWidget::item {
                padding: 4px;
                border: none;
            }
            QTreeWidget::item:hover {
                background-color: #454545;
            }
            QHeaderView::section {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 6px;
                border: 1px solid #555555;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 8px 16px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
        """)

    def setup_shortcuts(self):
        """Configurar atajos del di√°logo"""
        from PyQt6.QtGui import QShortcut

        enter_shortcut = QShortcut(QKeySequence("Return"), self)
        enter_shortcut.activated.connect(self.execute_global_paste)

        escape_shortcut = QShortcut(QKeySequence("Escape"), self)
        escape_shortcut.activated.connect(self.reject)

    def position_near_cursor(self):
        """Posicionar cerca del cursor de manera inteligente"""
        from PyQt6.QtGui import QCursor

        cursor_pos = QCursor.pos()
        dialog_size = self.size()

        # Obtener informaci√≥n de la pantalla
        screen = QApplication.screenAt(cursor_pos)
        if screen:
            screen_geometry = screen.geometry()

            # Calcular posici√≥n cerca del cursor pero dentro de la pantalla
            x = cursor_pos.x() + 20
            y = cursor_pos.y() + 20

            # Ajustar si se sale de la pantalla por la derecha
            if x + dialog_size.width() > screen_geometry.right():
                x = cursor_pos.x() - dialog_size.width() - 20

            # Ajustar si se sale de la pantalla por abajo
            if y + dialog_size.height() > screen_geometry.bottom():
                y = cursor_pos.y() - dialog_size.height() - 20

            # Asegurar que no se salga por la izquierda o arriba
            x = max(screen_geometry.left() + 10, x)
            y = max(screen_geometry.top() + 10, y)

            self.move(x, y)
        else:
            # Fallback: centrar cerca del cursor
            self.move(cursor_pos.x() + 20, cursor_pos.y() + 20)

    def change_target_folder(self):
        """Cambiar carpeta destino manualmente"""
        new_folder = QFileDialog.getExistingDirectory(
            self, "Seleccionar Nueva Carpeta Destino", self.target_folder
        )
        if new_folder:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            self.target_folder = normalize_network_path(new_folder)
            self.folder_label.setText(f"üìÇ {self.target_folder}")

    def detect_folder_again(self):
        """Volver a detectar la carpeta actual"""
        if hasattr(self.parent(), "global_hotkey_manager"):
            new_folder = self.parent().global_hotkey_manager.detect_current_folder()
            # Normalizar ruta para soportar rutas de red UNC correctamente
            self.target_folder = normalize_network_path(new_folder)
            self.folder_label.setText(f"üìÇ {self.target_folder}")
            print(f"‚úì Carpeta re-detectada: {self.target_folder}")

    def select_all(self):
        """Seleccionar todos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Checked)

    def select_none(self):
        """Deseleccionar todos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Unchecked)

    def on_item_double_clicked(self, item, column):
        """Permitir edici√≥n solo en la columna 'Nuevo Nombre' (columna 2)"""
        if column == 2:
            self.items_tree.editItem(item, column)

    def apply_rename_pattern_to_selected(self, pattern):
        """Aplicar patr√≥n de renombrado a elementos seleccionados"""
        import datetime
        import uuid
        import hashlib
        import getpass
        import platform
        import re

        counter = 1
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                file_item = item.data(0, Qt.ItemDataRole.UserRole)
                if file_item:
                    # Aplicar patr√≥n de renombrado
                    new_name = self.apply_rename_pattern(file_item, pattern, counter)
                    item.setText(2, new_name)
                    counter += 1

    def apply_rename_pattern(self, file_item, pattern, counter=1):
        """Aplicar patr√≥n de renombrado a un archivo espec√≠fico"""
        import datetime
        import uuid
        import hashlib
        import getpass
        import platform
        import re
        import os

        # Obtener informaci√≥n del archivo
        name, ext = os.path.splitext(file_item.name)
        folder_name = os.path.basename(os.path.dirname(file_item.path))

        # Variables disponibles
        now = datetime.datetime.now()
        result = pattern

        # Reemplazar variables b√°sicas
        result = result.replace("{name}", name)
        result = result.replace("{ext}", ext)
        result = result.replace("{date}", now.strftime("%Y-%m-%d"))
        result = result.replace("{time}", now.strftime("%H%M%S"))
        result = result.replace("{time_short}", now.strftime("%H%M"))
        result = result.replace("{year}", str(now.year))
        result = result.replace("{month}", str(now.month).zfill(2))
        result = result.replace("{day}", str(now.day).zfill(2))
        result = result.replace("{counter:3}", str(counter).zfill(3))
        result = result.replace("{counter}", str(counter))
        result = result.replace("{user}", getpass.getuser())
        result = result.replace("{computer}", platform.node())
        result = result.replace("{uuid_short}", str(uuid.uuid4())[:8])
        result = result.replace(
            "{hash_short}", hashlib.md5(file_item.name.encode()).hexdigest()[:8]
        )

        # Transformaciones de texto
        clean_pattern = r"\{clean:([^}]+)\}"
        for match in re.finditer(clean_pattern, result):
            text = match.group(1)
            clean_text = re.sub(r"[^a-zA-Z0-9\s]", "", text)
            clean_text = re.sub(r"\s+", " ", clean_text.strip())
            result = result.replace(match.group(0), clean_text)

        return result

    def update_selection_info(self):
        """Actualizar info de selecci√≥n"""
        count = sum(
            1
            for i in range(self.items_tree.topLevelItemCount())
            if self.items_tree.topLevelItem(i).checkState(0) == Qt.CheckState.Checked
        )

        if count == 0:
            self.selection_info.setText("Ning√∫n elemento seleccionado")
            self.paste_btn.setEnabled(False)
        else:
            self.selection_info.setText(f"{count} elementos seleccionados para pegar")
            self.paste_btn.setEnabled(True)

    def on_close_after_paste_toggled(self, checked):
        """Guardar configuraci√≥n cuando cambia la opci√≥n de cerrar despu√©s de pegar"""
        self.config_manager.set("behavior", "close_quick_paste_after_pasting", checked)

    def execute_global_paste(self):
        """Ejecutar pegado global con automatizaci√≥n inteligente"""
        selected_items = []
        custom_names = {}
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                file_item = item.data(0, Qt.ItemDataRole.UserRole)
                if file_item:
                    selected_items.append(file_item)
                    # Guardar nombre personalizado si fue editado
                    custom_name = item.text(2).strip()
                    if custom_name and custom_name != file_item.name:
                        custom_names[file_item.path] = custom_name

        if not selected_items:
            return

        if not os.access(self.target_folder, os.W_OK):
            QMessageBox.critical(
                self,
                "Sin Permisos",
                f"No tienes permisos para escribir en:\n{self.target_folder}",
            )
            return

        # Ejecutar copia con automatizaci√≥n
        self.paste_btn.setText("Copiando...")
        self.paste_btn.setEnabled(False)

        # Crear motor de automatizaci√≥n
        automation_engine = FileAutomationEngine()

        copied_count = 0
        skipped_count = 0
        errors = []
        automation_messages = []

        try:
            import shutil

            for item in selected_items:
                try:
                    if not os.path.exists(item.path):
                        errors.append(f"{item.name}: No existe")
                        continue

                    # Procesar con motor de automatizaci√≥n
                    auto_result = automation_engine.process_file_with_automation(
                        item, self.target_folder
                    )

                    # Si se salt√≥ por reglas, registrarlo
                    if auto_result["skipped"]:
                        skipped_count += 1
                        automation_messages.append(
                            f"‚è≠Ô∏è {item.name}: {auto_result['message'].strip()}"
                        )
                        continue

                    # Determinar nombre final (renombrado manual tiene prioridad sobre autom√°tico)
                    if item.path in custom_names:
                        dest_name = custom_names[item.path]
                    else:
                        dest_name = auto_result["final_name"]

                    # Usar destino determinado por automatizaci√≥n
                    dest_folder = auto_result["destination"]
                    dest_path = os.path.join(dest_folder, dest_name)

                    # Verificar si el archivo ya existe y si se debe saltar en pegado repetido
                    if os.path.exists(dest_path) and item.auto_skip_on_repeat_paste:
                        skipped_count += 1
                        automation_messages.append(
                            f"üîÑ {item.name}: Ya existe, saltado por configuraci√≥n de pegado repetido"
                        )
                        continue

                    # Manejar duplicados (si no se manejaron por automatizaci√≥n)
                    counter = 1
                    original_dest = dest_path
                    while os.path.exists(dest_path):
                        name, ext = os.path.splitext(dest_name)
                        if item.is_directory:
                            new_name = f"{name} - Copia ({counter})"
                        else:
                            new_name = f"{name} - Copia ({counter}){ext}"
                        dest_path = os.path.join(dest_folder, new_name)
                        counter += 1

                    # Copiar
                    if item.is_directory:
                        shutil.copytree(item.path, dest_path)

                        # Renombrar archivos y subcarpetas internos si hay patrones configurados
                        if auto_result.get("folder_files"):
                            for original_name, new_name in auto_result[
                                "folder_files"
                            ].items():
                                if original_name != new_name:
                                    try:
                                        old_file_path = os.path.join(
                                            dest_path, original_name
                                        )
                                        new_file_path = os.path.join(
                                            dest_path, new_name
                                        )

                                        if os.path.exists(old_file_path):
                                            os.rename(old_file_path, new_file_path)
                                            print(
                                                f"  ‚úì Renombrado: {original_name} ‚Üí {new_name}"
                                            )
                                    except Exception as e:
                                        print(
                                            f"  ‚úó Error renombrando {original_name}: {e}"
                                        )
                    else:
                        shutil.copy2(item.path, dest_path)

                    copied_count += 1

                    # Registrar mensaje de automatizaci√≥n si hay
                    if auto_result["message"]:
                        automation_messages.append(
                            f"‚úì {item.name}: {auto_result['message'].strip()}"
                        )

                except Exception as e:
                    errors.append(f"{item.name}: {str(e)}")

                QApplication.processEvents()

            # Mostrar resultado
            if copied_count > 0 or skipped_count > 0:
                result_msg = f"‚úÖ {copied_count} archivos copiados"
                if skipped_count > 0:
                    result_msg += f"\n‚è≠Ô∏è {skipped_count} archivos saltados (duplicados)"
                if errors:
                    result_msg += f"\n‚ùå {len(errors)} errores"

                # Mostrar mensajes detallados de automatizaci√≥n si hay
                if automation_messages:
                    details_msg = "\n\nüìã Detalles de automatizaci√≥n:\n" + "\n".join(
                        automation_messages[:10]
                    )  # Limitar a 10 mensajes
                    if len(automation_messages) > 10:
                        details_msg += f"\n... y {len(automation_messages) - 10} m√°s"
                else:
                    details_msg = ""

                if errors or skipped_count > 0:
                    QMessageBox.information(
                        self,
                        "‚úÖ Pegado Completado",
                        result_msg + details_msg,
                    )
                else:
                    # Notificaci√≥n de √©xito
                    self.show_success_notification(copied_count)

                    # Cerrar autom√°ticamente solo si la opci√≥n est√° marcada
                    if self.close_after_paste_check.isChecked():
                        QTimer.singleShot(1200, self.accept)
                    else:
                        # Desmarcar todos los items despu√©s de pegar si no se cierra
                        self.select_none()
                        # Restaurar el estado del bot√≥n y ventana despu√©s de 1.5 segundos
                        QTimer.singleShot(1500, self.restore_button_state)
            else:
                QMessageBox.critical(self, "Error", "No se pudo copiar ning√∫n archivo")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error durante la copia:\n{str(e)}")

        finally:
            self.paste_btn.setText("‚ö° Pegar Ahora")
            self.paste_btn.setEnabled(True)

    def show_success_notification(self, count):
        """Mostrar notificaci√≥n de √©xito"""
        self.setWindowTitle(f"‚úÖ ¬°{count} archivos pegados exitosamente!")
        self.setStyleSheet(
            self.styleSheet()
            + """
            QDialog {
                border: 3px solid #28a745;
                background-color: #1a2e1a;
            }
        """
        )

        # Agregar mensaje de √©xito visible en el di√°logo
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if item and item.widget() and isinstance(item.widget(), QPushButton):
                if "Pegar Ahora" in item.widget().text():
                    item.widget().setText("‚úÖ ¬°Pegado Exitoso!")
                    item.widget().setEnabled(False)
                    break

    def restore_button_state(self):
        """Restaurar el estado del bot√≥n y ventana al color naranja original"""
        # Restaurar t√≠tulo
        self.setWindowTitle("‚ö° Pegado Global - Ctrl+Alt+V")

        # Restaurar estilo de la ventana (aplicar el tema original)
        self.setup_style()

        # Restaurar bot√≥n al color naranja original
        self.paste_btn.setText("‚ö° Pegar Ahora")
        self.paste_btn.setEnabled(True)
        self.paste_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff6b35;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 12px 24px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #e55a2e;
            }
            QPushButton:pressed {
                background-color: #cc4d26;
            }
            QPushButton:disabled {
                background-color: #666666;
            }
        """)

        # Actualizar informaci√≥n de selecci√≥n
        self.update_selection_info()


class NoFilesDialog(QDialog):
    """Di√°logo elegante cuando no hay archivos disponibles"""

    def __init__(self, target_folder, parent=None):
        super().__init__(parent)
        self.target_folder = target_folder
        self.setWindowTitle("‚ö†Ô∏è Sin Archivos Disponibles")
        set_window_icon(self)
        self.setWindowFlags(
            Qt.WindowType.Dialog
            | Qt.WindowType.WindowStaysOnTopHint
            | Qt.WindowType.Tool
        )
        self.setFixedSize(450, 280)
        self.setup_ui()
        self.setup_style()
        self.position_near_cursor()

    def setup_ui(self):
        """Configurar interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        # Icono y t√≠tulo
        title_label = QLabel("üìã No Hay Archivos para Pegar")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #ffc107; text-align: center;")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title_label)

        # Mensaje principal
        message_label = QLabel(
            "La aplicaci√≥n no tiene archivos guardados\npara pegar en esta ubicaci√≥n."
        )
        message_label.setStyleSheet(
            "color: #ffffff; font-size: 11pt; text-align: center;"
        )
        message_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(message_label)

        # Carpeta detectada
        folder_label = QLabel(f"üìÅ Carpeta detectada:\n{self.target_folder}")
        folder_label.setStyleSheet(
            "color: #4a90e2; font-size: 9pt; text-align: center; font-family: 'Consolas';"
        )
        folder_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        folder_label.setWordWrap(True)
        layout.addWidget(folder_label)

        # Instrucciones
        instructions_label = QLabel(
            "üí° Para usar el pegado global:\n\n"
            "1. Abre la ventana principal de la aplicaci√≥n\n"
            "2. Arrastra algunos archivos/carpetas a la lista\n"
            "3. Usa Ctrl+Alt+V desde cualquier lugar"
        )
        instructions_label.setStyleSheet(
            "color: #cccccc; font-size: 9pt; background-color: rgba(74, 144, 226, 0.1); "
            "padding: 10px; border-radius: 4px;"
        )
        instructions_label.setAlignment(Qt.AlignmentFlag.AlignLeft)
        layout.addWidget(instructions_label)

        # Botones
        buttons_layout = QHBoxLayout()

        show_app_btn = QPushButton("üìñ Abrir Aplicaci√≥n")
        show_app_btn.clicked.connect(self.show_main_app)
        show_app_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)

        ok_btn = QPushButton("‚úÖ Entendido")
        ok_btn.clicked.connect(self.accept)
        ok_btn.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
        """)

        buttons_layout.addWidget(show_app_btn)
        buttons_layout.addWidget(ok_btn)
        layout.addLayout(buttons_layout)

    def setup_style(self):
        """Configurar estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
                border: 2px solid #ffc107;
                border-radius: 8px;
            }
        """)

    def position_near_cursor(self):
        """Posicionar cerca del cursor"""
        from PyQt6.QtGui import QCursor

        cursor_pos = QCursor.pos()
        self.move(cursor_pos.x() + 20, cursor_pos.y() + 20)

    def show_main_app(self):
        """Mostrar la aplicaci√≥n principal"""
        if self.parent():
            self.parent().show()
            self.parent().raise_()
            self.parent().activateWindow()
        self.accept()


class PerformanceManager:
    """Gestor de rendimiento y optimizaciones"""

    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=4)
        self.cache = {}
        self.cache_size_limit = 1000

    @lru_cache(maxsize=100)
    def get_file_info(self, path):
        """Obtener informaci√≥n de archivo con cach√©"""
        try:
            stat = os.stat(path)
            return {
                "size": stat.st_size,
                "modified": stat.st_mtime,
                "is_dir": os.path.isdir(path),
            }
        except:
            return None

    def clear_cache(self):
        """Limpiar cach√©"""
        self.get_file_info.cache_clear()
        self.cache.clear()

    def shutdown(self):
        """Cerrar executor"""
        self.executor.shutdown(wait=True)


class PluginManager:
    """Sistema b√°sico de plugins"""

    def __init__(self):
        self.plugins = {}
        self.plugin_hooks = {
            "file_added": [],
            "file_removed": [],
            "app_started": [],
            "app_closing": [],
        }

    def register_plugin(self, name, plugin_instance):
        """Registrar plugin"""
        self.plugins[name] = plugin_instance

    def add_hook(self, hook_name, callback):
        """Agregar hook"""
        if hook_name in self.plugin_hooks:
            self.plugin_hooks[hook_name].append(callback)

    def trigger_hook(self, hook_name, *args, **kwargs):
        """Ejecutar hooks"""
        if hook_name in self.plugin_hooks:
            for callback in self.plugin_hooks[hook_name]:
                try:
                    callback(*args, **kwargs)
                except Exception as e:
                    print(f"Error en plugin hook {hook_name}: {e}")


class Logger:
    """Sistema de logging mejorado"""

    def __init__(self):
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
            handlers=[logging.FileHandler("app.log"), logging.StreamHandler()],
        )
        self.logger = logging.getLogger(__name__)

    def info(self, message):
        self.logger.info(message)

    def error(self, message):
        self.logger.error(message)

    def warning(self, message):
        self.logger.warning(message)


class AdvancedConfigManager:
    """Gestor de configuraci√≥n avanzada"""

    def __init__(self):
        self.config_file = "advanced_config.json"
        self.default_config = {
            "appearance": {
                "theme": "dark",
                "animations_enabled": True,
                "show_tooltips": True,
                "window_opacity": 1.0,
            },
            "performance": {
                "max_clipboard_items": 50,
                "cache_enabled": True,
                "virtual_scrolling": True,
                "max_display_items": 500,
            },
            "behavior": {
                "auto_save_interval": 30,
                "confirm_deletions": True,
                "remember_window_positions": True,
                "enable_plugins": True,
                "start_in_background": False,
                "close_quick_paste_after_pasting": True,
                "use_global_quick_paste": False,
                "auto_start_windows": False,
            },
            "network": {"scan_timeout": 30, "max_scan_depth": 5, "concurrent_scans": 4},
            "shortcuts": {
                "show_window": "<ctrl>+<alt>+s",
                "hide_window": "<ctrl>+<alt>+h",
                "quick_paste": "<ctrl>+<alt>+v",
                "quick_copy": "<ctrl>+<alt>+c",
            },
        }
        self.config = self.load_config()

    def load_config(self):
        """Cargar configuraci√≥n desde archivo"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, "r", encoding="utf-8") as f:
                    loaded_config = json.load(f)
                    # Merge with defaults para keys faltantes
                    return self.merge_configs(self.default_config, loaded_config)
            return self.default_config.copy()
        except Exception as e:
            print(f"Error cargando configuraci√≥n: {e}")
            return self.default_config.copy()

    def merge_configs(self, default, loaded):
        """Fusionar configuraciones manteniendo estructura"""
        result = default.copy()
        for key, value in loaded.items():
            if (
                key in result
                and isinstance(result[key], dict)
                and isinstance(value, dict)
            ):
                result[key] = self.merge_configs(result[key], value)
            else:
                result[key] = value
        return result

    def save_config(self):
        """Guardar configuraci√≥n a archivo"""
        try:
            with open(self.config_file, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error guardando configuraci√≥n: {e}")
            return False

    def get(self, category, key, default=None):
        """Obtener valor de configuraci√≥n"""
        return self.config.get(category, {}).get(key, default)

    def set(self, category, key, value):
        """Establecer valor de configuraci√≥n"""
        if category not in self.config:
            self.config[category] = {}
        self.config[category][key] = value
        self.save_config()

    def export_config(self, filepath):
        """Exportar configuraci√≥n a archivo"""
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Error exportando configuraci√≥n: {e}")
            return False

    def import_config(self, filepath):
        """Importar configuraci√≥n desde archivo"""
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                imported_config = json.load(f)
                self.config = self.merge_configs(self.default_config, imported_config)
                self.save_config()
            return True
        except Exception as e:
            print(f"Error importando configuraci√≥n: {e}")
            return False


class DataExportManager:
    """Gestor de exportaci√≥n e importaci√≥n de datos"""

    def __init__(self):
        self.supported_formats = ["json", "csv", "xml"]

    def export_data(self, data, filepath, format_type="json"):
        """Exportar datos en formato especificado"""
        try:
            if format_type == "json":
                return self._export_json(data, filepath)
            elif format_type == "csv":
                return self._export_csv(data, filepath)
            elif format_type == "xml":
                return self._export_xml(data, filepath)
            else:
                raise ValueError(f"Formato no soportado: {format_type}")
        except Exception as e:
            print(f"Error exportando datos: {e}")
            return False

    def _export_json(self, data, filepath):
        """Exportar a JSON"""
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False, default=str)
        return True

    def _export_csv(self, data, filepath):
        """Exportar a CSV"""
        import csv

        with open(filepath, "w", newline="", encoding="utf-8") as f:
            if isinstance(data, dict) and "items" in data:
                items = data["items"]
                if items:
                    fieldnames = items[0].keys()
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(items)
        return True

    def _export_xml(self, data, filepath):
        """Exportar a XML"""
        import xml.etree.ElementTree as ET

        root = ET.Element("FileManagerData")

        if isinstance(data, dict) and "items" in data:
            items_element = ET.SubElement(root, "Items")
            for item in data["items"]:
                item_element = ET.SubElement(items_element, "Item")
                for key, value in item.items():
                    elem = ET.SubElement(item_element, key)
                    elem.text = str(value)

        tree = ET.ElementTree(root)
        tree.write(filepath, encoding="utf-8", xml_declaration=True)
        return True

    def import_data(self, filepath, format_type="json"):
        """Importar datos desde archivo"""
        try:
            if format_type == "json":
                return self._import_json(filepath)
            elif format_type == "csv":
                return self._import_csv(filepath)
            elif format_type == "xml":
                return self._import_xml(filepath)
            else:
                raise ValueError(f"Formato no soportado: {format_type}")
        except Exception as e:
            print(f"Error importando datos: {e}")
            return None

    def _import_json(self, filepath):
        """Importar desde JSON"""
        with open(filepath, "r", encoding="utf-8") as f:
            return json.load(f)

    def _import_csv(self, filepath):
        """Importar desde CSV"""
        import csv

        items = []
        with open(filepath, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            items = list(reader)
        return {"items": items}

    def _import_xml(self, filepath):
        """Importar desde XML"""
        import xml.etree.ElementTree as ET

        tree = ET.parse(filepath)
        root = tree.getroot()

        items = []
        items_element = root.find("Items")
        if items_element is not None:
            for item_element in items_element.findall("Item"):
                item = {}
                for child in item_element:
                    item[child.tag] = child.text
                items.append(item)

        return {"items": items}


class MultiClipboard:
    """Sistema de clipboard m√∫ltiple para manejar varios elementos copiados"""

    def __init__(self):
        self.items = []  # Lista de elementos en clipboard
        self.max_items = 50  # M√°ximo n√∫mero de elementos

    def add_item(self, path):
        """Agregar elemento al clipboard"""
        if path in [item["path"] for item in self.items]:
            # Si ya existe, moverlo al principio
            self.items = [item for item in self.items if item["path"] != path]

        try:
            item_info = {
                "path": path,
                "name": os.path.basename(path),
                "is_directory": os.path.isdir(path),
                "size": os.path.getsize(path) if os.path.isfile(path) else None,
                "modified": datetime.fromtimestamp(os.path.getmtime(path)).strftime(
                    "%Y-%m-%d %H:%M:%S"
                ),
                "added_time": datetime.now().strftime("%H:%M:%S"),
            }

            # Agregar al principio de la lista
            self.items.insert(0, item_info)

            # Mantener l√≠mite m√°ximo
            if len(self.items) > self.max_items:
                self.items = self.items[: self.max_items]

            return True
        except Exception as e:
            print(f"Error agregando al clipboard: {e}")
            return False

    def remove_item(self, path):
        """Remover elemento del clipboard"""
        self.items = [item for item in self.items if item["path"] != path]

    def clear_all(self):
        """Limpiar todo el clipboard"""
        self.items = []

    def get_items(self):
        """Obtener todos los elementos"""
        return self.items.copy()

    def count(self):
        """Obtener n√∫mero de elementos"""
        return len(self.items)

    def is_empty(self):
        """Verificar si est√° vac√≠o"""
        return len(self.items) == 0


class NetworkScanner(QObject):
    """Esc√°ner de red para buscar carpetas por cliente y proyecto"""

    progress_updated = pyqtSignal(int, str)  # progreso, mensaje
    results_found = pyqtSignal(list)  # lista de resultados
    scan_finished = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.is_scanning = False
        self.should_stop = False

    def scan_network_paths(
        self, base_paths, client_name="", project_name="", max_depth=3
    ):
        """Escanear rutas de red buscando coincidencias"""
        if self.is_scanning:
            return

        self.is_scanning = True
        self.should_stop = False
        results = []

        try:
            total_paths = len(base_paths)
            for i, base_path in enumerate(base_paths):
                if self.should_stop:
                    break

                self.progress_updated.emit(
                    int((i / total_paths) * 100), f"Escaneando: {base_path}"
                )

                try:
                    found_items = self._scan_directory(
                        base_path, client_name, project_name, max_depth, 0
                    )
                    results.extend(found_items)
                except Exception as e:
                    print(f"Error escaneando {base_path}: {e}")

            self.results_found.emit(results)

        finally:
            self.is_scanning = False
            self.scan_finished.emit()

    def _scan_directory(
        self, path, client_name, project_name, max_depth, current_depth
    ):
        """Escanear directorio recursivamente"""
        results = []

        if current_depth >= max_depth or self.should_stop:
            return results

        try:
            if not os.path.exists(path) or not os.path.isdir(path):
                return results

            for item in os.listdir(path):
                if self.should_stop:
                    break

                item_path = os.path.join(path, item)

                if os.path.isdir(item_path):
                    # Verificar si coincide con criterios de b√∫squeda
                    matches_client = not client_name or self._fuzzy_match(
                        item.lower(), client_name.lower()
                    )
                    matches_project = not project_name or self._fuzzy_match(
                        item.lower(), project_name.lower()
                    )

                    if matches_client or matches_project:
                        try:
                            # Obtener informaci√≥n del directorio
                            stat_info = os.stat(item_path)
                            size = self._get_directory_size(item_path)

                            result = {
                                "path": item_path,
                                "name": item,
                                "type": "directory",
                                "size": size,
                                "modified": datetime.fromtimestamp(
                                    stat_info.st_mtime
                                ).strftime("%Y-%m-%d %H:%M:%S"),
                                "client_match": matches_client,
                                "project_match": matches_project,
                                "match_score": self._calculate_match_score(
                                    item, client_name, project_name
                                ),
                            }
                            results.append(result)
                        except Exception as e:
                            print(f"Error obteniendo info de {item_path}: {e}")

                    # Continuar escaneo recursivo
                    if current_depth < max_depth - 1:
                        sub_results = self._scan_directory(
                            item_path,
                            client_name,
                            project_name,
                            max_depth,
                            current_depth + 1,
                        )
                        results.extend(sub_results)

        except Exception as e:
            print(f"Error accediendo a {path}: {e}")

        return results

    def _fuzzy_match(self, text, pattern):
        """B√∫squeda difusa que permite coincidencias parciales"""
        if not pattern:
            return True

        # Dividir patr√≥n en palabras
        pattern_words = pattern.split()

        for word in pattern_words:
            if word in text:
                return True

        # Tambi√©n probar coincidencia por expresi√≥n regular flexible
        try:
            pattern_regex = ".*".join(re.escape(char) for char in pattern)
            return bool(re.search(pattern_regex, text))
        except:
            return False

    def _calculate_match_score(self, text, client_name, project_name):
        """Calcular puntuaci√≥n de coincidencia"""
        score = 0
        text_lower = text.lower()

        if client_name:
            client_lower = client_name.lower()
            if client_lower in text_lower:
                score += 10
            elif any(word in text_lower for word in client_lower.split()):
                score += 5

        if project_name:
            project_lower = project_name.lower()
            if project_lower in text_lower:
                score += 10
            elif any(word in text_lower for word in project_lower.split()):
                score += 5

        return score

    def _get_directory_size(self, path):
        """Obtener tama√±o aproximado del directorio (limitado para rendimiento)"""
        try:
            total_size = 0
            file_count = 0

            for root, dirs, files in os.walk(path):
                # Limitar a los primeros 100 archivos para rendimiento
                if file_count > 100:
                    break

                for file in files[:10]:  # Solo los primeros 10 archivos por directorio
                    try:
                        file_path = os.path.join(root, file)
                        total_size += os.path.getsize(file_path)
                        file_count += 1
                    except:
                        continue

                # Solo el primer nivel de subdirectorios para rendimiento
                if root != path:
                    break

            return total_size if total_size > 0 else None
        except:
            return None

    def stop_scan(self):
        """Detener escaneo actual"""
        self.should_stop = True


class NetworkScanWidget(QWidget):
    """Widget para escaneo de red local con rendimiento mejorado"""

    file_found = pyqtSignal(str)  # Se√±al cuando se encuentra un archivo para agregar

    def __init__(self, parent=None):
        super().__init__(parent)
        self.scanner = NetworkScanner()
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.performance_manager = PerformanceManager()
        self.setup_ui()
        self.setup_connections()
        self.scan_thread = None
        self.results_cache = {}  # Cache para resultados
        self.virtual_scroll_enabled = True

    def setup_ui(self):
        """Configurar la interfaz del esc√°ner de red"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)

        # T√≠tulo
        title_label = QLabel("üåê Esc√°ner de Red Local")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(14)
        title_label.setFont(title_font)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Configuraci√≥n de b√∫squeda
        search_group = QGroupBox("üîç Configuraci√≥n de B√∫squeda")
        search_layout = QGridLayout(search_group)

        # Rutas base
        search_layout.addWidget(QLabel("Rutas de red:"), 0, 0)

        # Widget contenedor para rutas
        paths_widget = QWidget()
        paths_layout = QVBoxLayout(paths_widget)
        paths_layout.setSpacing(5)
        paths_layout.setContentsMargins(0, 0, 0, 0)

        self.paths_text = QTextEdit()
        self.paths_text.setMaximumHeight(80)
        self.paths_text.setPlaceholderText(
            "Ingresa las rutas de red, una por l√≠nea:\n"
            "\\\\servidor\\carpeta\n"
            "\\\\192.168.1.100\\proyectos\n"
            "C:\\Proyectos\\Red"
        )
        paths_layout.addWidget(self.paths_text)

        # Botones de rutas predefinidas
        predefined_layout = QHBoxLayout()

        common_paths_btn = QPushButton("üè¢ Rutas Comunes")
        common_paths_btn.setMaximumHeight(25)
        common_paths_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #138496;
            }
        """)
        common_paths_btn.clicked.connect(self.add_common_paths)

        local_drives_btn = QPushButton("üíæ Drives Locales")
        local_drives_btn.setMaximumHeight(25)
        local_drives_btn.setStyleSheet("""
            QPushButton {
                background-color: #6f42c1;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #5a32a3;
            }
        """)
        local_drives_btn.clicked.connect(self.add_local_drives)

        clear_paths_btn = QPushButton("üóëÔ∏è Limpiar")
        clear_paths_btn.setMaximumHeight(25)
        clear_paths_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 3px;
                padding: 2px 8px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
        """)
        clear_paths_btn.clicked.connect(self.paths_text.clear)

        predefined_layout.addWidget(common_paths_btn)
        predefined_layout.addWidget(local_drives_btn)
        predefined_layout.addWidget(clear_paths_btn)
        predefined_layout.addStretch()

        paths_layout.addLayout(predefined_layout)
        search_layout.addWidget(paths_widget, 0, 1)

        # Nombre del cliente
        search_layout.addWidget(QLabel("Cliente:"), 1, 0)
        self.client_input = QLineEdit()
        self.client_input.setPlaceholderText(
            "Nombre del cliente (ej: Coca-Cola, Microsoft)"
        )
        search_layout.addWidget(self.client_input, 1, 1)

        # Nombre del proyecto
        search_layout.addWidget(QLabel("Proyecto:"), 2, 0)
        self.project_input = QLineEdit()
        self.project_input.setPlaceholderText(
            "Nombre del proyecto (ej: Website, App M√≥vil)"
        )
        search_layout.addWidget(self.project_input, 2, 1)

        # Profundidad de b√∫squeda
        search_layout.addWidget(QLabel("Profundidad:"), 3, 0)
        self.depth_spin = QSpinBox()
        self.depth_spin.setMinimum(1)
        self.depth_spin.setMaximum(10)
        self.depth_spin.setValue(3)
        self.depth_spin.setToolTip(
            "Niveles de carpetas a escanear (m√°s alto = m√°s lento)"
        )
        search_layout.addWidget(self.depth_spin, 3, 1)

        layout.addWidget(search_group)

        # Botones de control
        buttons_layout = QHBoxLayout()

        self.scan_btn = QPushButton("üîç Iniciar Escaneo")
        self.scan_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #218838;
            }
            QPushButton:disabled {
                background-color: #6c757d;
            }
        """)

        self.stop_btn = QPushButton("‚èπ Detener")
        self.stop_btn.setEnabled(False)
        self.stop_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 20px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
            QPushButton:disabled {
                background-color: #6c757d;
            }
        """)

        buttons_layout.addWidget(self.scan_btn)
        buttons_layout.addWidget(self.stop_btn)
        buttons_layout.addStretch()
        layout.addLayout(buttons_layout)

        # Barra de progreso
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 2px solid #555555;
                border-radius: 5px;
                text-align: center;
                font-weight: bold;
            }
            QProgressBar::chunk {
                background-color: #217346;
                border-radius: 3px;
            }
        """)
        layout.addWidget(self.progress_bar)

        # Etiqueta de estado
        self.status_label = QLabel("Listo para escanear")
        self.status_label.setStyleSheet("color: #888888; font-style: italic;")
        layout.addWidget(self.status_label)

        # √Årbol de resultados
        results_group = QGroupBox("üìä Resultados de B√∫squeda")
        results_layout = QVBoxLayout(results_group)

        self.results_tree = QTreeWidget()
        self.results_tree.setHeaderLabels(
            ["Nombre", "Ruta", "Tama√±o", "Modificado", "Coincidencia", "Puntuaci√≥n"]
        )
        self.results_tree.setUniformRowHeights(True)  # Mejor rendimiento
        self.results_tree.setRootIsDecorated(False)  # Sin decoraciones para speed
        self.results_tree.setAlternatingRowColors(True)
        self.results_tree.setSortingEnabled(True)
        self.results_tree.setStyleSheet("""
            QTreeWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                alternate-background-color: #3a3a3a;
            }
            QTreeWidget::item:selected {
                background-color: #217346;
            }
            QTreeWidget::item:hover {
                background-color: #454545;
            }
            QHeaderView::section {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 5px;
                border: 1px solid #555555;
            }
        """)

        # Men√∫ contextual para resultados
        self.results_tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.results_tree.customContextMenuRequested.connect(
            self.show_results_context_menu
        )

        results_layout.addWidget(self.results_tree)

        # Botones de resultados
        results_buttons_layout = QHBoxLayout()

        self.add_selected_btn = QPushButton("‚ûï Agregar Seleccionado")
        self.add_selected_btn.setEnabled(False)
        self.add_selected_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #138496;
            }
            QPushButton:disabled {
                background-color: #6c757d;
            }
        """)

        self.clear_results_btn = QPushButton("üóëÔ∏è Limpiar Resultados")
        self.clear_results_btn.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
        """)

        results_buttons_layout.addWidget(self.add_selected_btn)
        results_buttons_layout.addWidget(self.clear_results_btn)
        results_buttons_layout.addStretch()
        results_layout.addLayout(results_buttons_layout)

        layout.addWidget(results_group)

        # Configuraciones guardadas
        config_layout = QHBoxLayout()

        save_config_btn = QPushButton("üíæ Guardar Config")
        save_config_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)
        save_config_btn.clicked.connect(self.save_search_config)

        load_config_btn = QPushButton("üìÇ Cargar Config")
        load_config_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #138496;
            }
        """)
        load_config_btn.clicked.connect(self.load_search_config)

        config_layout.addWidget(save_config_btn)
        config_layout.addWidget(load_config_btn)
        config_layout.addStretch()

        layout.addLayout(config_layout)

        # Establecer estilo general
        self.setStyleSheet("""
            QWidget {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #555555;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #4a90e2;
            }
            QLineEdit, QTextEdit, QSpinBox {
                background-color: #ffffff;
                border: 2px solid #555555;
                border-radius: 4px;
                padding: 5px;
                color: #ffffff;
            }
            QLineEdit:focus, QTextEdit:focus, QSpinBox:focus {
                border-color: #4a90e2;
            }
            QLabel {
                color: #cccccc;
            }
        """)

    def setup_connections(self):
        """Configurar conexiones de se√±ales"""
        self.scan_btn.clicked.connect(self.start_scan)
        self.stop_btn.clicked.connect(self.stop_scan)
        self.add_selected_btn.clicked.connect(self.add_selected_items)
        self.clear_results_btn.clicked.connect(self.clear_results)
        self.results_tree.itemSelectionChanged.connect(self.on_selection_changed)

        # Conexiones del esc√°ner
        self.scanner.progress_updated.connect(self.update_progress)
        self.scanner.results_found.connect(self.display_results)
        self.scanner.scan_finished.connect(self.scan_finished)

    def add_common_paths(self):
        """Agregar rutas de red comunes empresariales"""
        common_paths = [
            "\\\\servidor\\proyectos",
            "\\\\servidor\\clientes",
            "\\\\servidor\\compartido",
            "\\\\fileserver\\data",
            "\\\\nas\\projects",
            "\\\\192.168.1.100\\shared",
            "\\\\192.168.1.200\\files",
            "C:\\Proyectos",
            "D:\\Clientes",
            "E:\\Compartido",
        ]

        current_text = self.paths_text.toPlainText().strip()
        if current_text:
            current_text += "\n"

        new_text = current_text + "\n".join(common_paths)
        self.paths_text.setPlainText(new_text)

    def add_local_drives(self):
        """Agregar drives locales disponibles"""
        import string

        drives = []

        # Obtener drives disponibles en Windows
        if sys.platform == "win32":
            for letter in string.ascii_uppercase:
                drive_path = f"{letter}:\\"
                if os.path.exists(drive_path):
                    drives.append(drive_path)
        else:
            # Para sistemas Unix-like
            drives = ["/", "/home", "/tmp", "/var"]

        if drives:
            current_text = self.paths_text.toPlainText().strip()
            if current_text:
                current_text += "\n"

            new_text = current_text + "\n".join(drives)
            self.paths_text.setPlainText(new_text)

    def save_search_config(self):
        """Guardar configuraci√≥n de b√∫squeda actual"""
        config = {
            "paths": self.paths_text.toPlainText(),
            "client": self.client_input.text(),
            "project": self.project_input.text(),
            "depth": self.depth_spin.value(),
        }

        try:
            config_file = "network_scan_config.json"
            with open(config_file, "w", encoding="utf-8") as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

            self.status_label.setText("‚úÖ Configuraci√≥n guardada exitosamente.")
            QTimer.singleShot(
                3000, lambda: self.status_label.setText("Listo para escanear")
            )

        except Exception as e:
            QMessageBox.warning(
                self, "Error", f"No se pudo guardar la configuraci√≥n:\n{str(e)}"
            )

    def load_search_config(self):
        """Cargar configuraci√≥n de b√∫squeda guardada"""
        try:
            config_file = "network_scan_config.json"
            if not os.path.exists(config_file):
                QMessageBox.information(
                    self, "Informaci√≥n", "No hay configuraci√≥n guardada."
                )
                return

            with open(config_file, "r", encoding="utf-8") as f:
                config = json.load(f)

            self.paths_text.setPlainText(config.get("paths", ""))
            self.client_input.setText(config.get("client", ""))
            self.project_input.setText(config.get("project", ""))
            self.depth_spin.setValue(config.get("depth", 3))

            self.status_label.setText("‚úÖ Configuraci√≥n cargada exitosamente.")
            QTimer.singleShot(
                3000, lambda: self.status_label.setText("Listo para escanear")
            )

        except Exception as e:
            QMessageBox.warning(
                self, "Error", f"No se pudo cargar la configuraci√≥n:\n{str(e)}"
            )

    def start_scan(self):
        """Iniciar escaneo de red"""
        # Obtener par√°metros
        paths_text = self.paths_text.toPlainText().strip()
        if not paths_text:
            QMessageBox.warning(
                self,
                "Error",
                "Por favor ingresa al menos una ruta de red para escanear.",
            )
            return

        base_paths = [path.strip() for path in paths_text.split("\n") if path.strip()]
        client_name = self.client_input.text().strip()
        project_name = self.project_input.text().strip()
        max_depth = self.depth_spin.value()

        if not client_name and not project_name:
            result = QMessageBox.question(
                self,
                "B√∫squeda Amplia",
                "No has especificado nombre de cliente ni proyecto.\n"
                "Esto puede resultar en muchos resultados y ser lento.\n"
                "¬øDeseas continuar?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )
            if result == QMessageBox.StandardButton.No:
                return

        # Preparar UI para escaneo
        self.scan_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        self.status_label.setText("Iniciando escaneo...")
        self.results_tree.clear()

        # Iniciar escaneo en hilo separado
        self.scan_thread = threading.Thread(
            target=self.scanner.scan_network_paths,
            args=(base_paths, client_name, project_name, max_depth),
            daemon=True,
        )
        self.scan_thread.start()

    def stop_scan(self):
        """Detener escaneo actual"""
        self.scanner.stop_scan()
        self.status_label.setText("Deteniendo escaneo...")

    def update_progress(self, progress, message):
        """Actualizar barra de progreso"""
        self.progress_bar.setValue(progress)
        self.status_label.setText(message)

    def display_results(self, results):
        """Mostrar resultados del escaneo con optimizaci√≥n de rendimiento"""
        self.results_tree.clear()

        if not results:
            self.status_label.setText("No se encontraron resultados.")
            return

        # Organizar resultados por puntuaci√≥n
        results.sort(key=lambda x: x.get("match_score", 0), reverse=True)

        # Implementar paginaci√≥n para mejor rendimiento con muchos resultados
        max_display = 500  # Limitar elementos mostrados
        if len(results) > max_display:
            results = results[:max_display]
            self.status_label.setText(
                f"Mostrando {max_display} de {len(results)} resultados"
            )

        for result in results:
            item = QTreeWidgetItem()

            # Nombre
            item.setText(0, result["name"])

            # Ruta
            item.setText(1, result["path"])

            # Tama√±o
            if result.get("size"):
                size_mb = result["size"] / (1024 * 1024)
                item.setText(2, f"{size_mb:.1f} MB")
            else:
                item.setText(2, "N/A")

            # Fecha modificaci√≥n
            item.setText(3, result.get("modified", "N/A"))

            # Tipo de coincidencia
            matches = []
            if result.get("client_match"):
                matches.append("Cliente")
            if result.get("project_match"):
                matches.append("Proyecto")
            item.setText(4, ", ".join(matches) or "Parcial")

            # Puntuaci√≥n
            item.setText(5, str(result.get("match_score", 0)))

            # Guardar datos del resultado
            item.setData(0, Qt.ItemDataRole.UserRole, result)

            # Color seg√∫n puntuaci√≥n
            score = result.get("match_score", 0)
            if score >= 10:
                item.setBackground(0, QColor(40, 167, 69, 50))  # Verde
            elif score >= 5:
                item.setBackground(0, QColor(255, 193, 7, 50))  # Amarillo
            else:
                item.setBackground(0, QColor(108, 117, 125, 50))  # Gris

            self.results_tree.addTopLevelItem(item)

        # Expandir y ajustar columnas
        self.results_tree.expandAll()
        for i in range(6):
            self.results_tree.resizeColumnToContents(i)

        self.status_label.setText(
            f"Escaneo completado. {len(results)} resultados encontrados."
        )

    def scan_finished(self):
        """Limpieza despu√©s del escaneo"""
        self.scan_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.progress_bar.setVisible(False)

    def on_selection_changed(self):
        """Manejar cambio de selecci√≥n"""
        selected_items = self.results_tree.selectedItems()
        self.add_selected_btn.setEnabled(len(selected_items) > 0)

    def show_results_context_menu(self, position):
        """Mostrar men√∫ contextual en resultados"""
        item = self.results_tree.itemAt(position)
        if not item:
            return

        menu = QMenu(self)

        add_action = menu.addAction("‚ûï Agregar al Gestor")
        add_action.triggered.connect(lambda: self.add_item_to_manager(item))

        open_action = menu.addAction("üìÇ Abrir Carpeta")
        open_action.triggered.connect(lambda: self.open_item_location(item))

        copy_path_action = menu.addAction("üìã Copiar Ruta")
        copy_path_action.triggered.connect(lambda: self.copy_item_path(item))

        menu.exec(self.results_tree.mapToGlobal(position))

    def add_selected_items(self):
        """Agregar elementos seleccionados al gestor principal"""
        selected_items = self.results_tree.selectedItems()

        for item in selected_items:
            self.add_item_to_manager(item)

    def add_item_to_manager(self, tree_item):
        """Agregar un elemento al gestor principal"""
        result_data = tree_item.data(0, Qt.ItemDataRole.UserRole)
        if result_data:
            self.file_found.emit(result_data["path"])

    def open_item_location(self, tree_item):
        """Abrir ubicaci√≥n del elemento"""
        result_data = tree_item.data(0, Qt.ItemDataRole.UserRole)
        if result_data:
            try:
                path = result_data["path"]
                if sys.platform == "win32":
                    os.startfile(path)
                elif sys.platform == "darwin":
                    os.system(f"open '{path}'")
                else:
                    os.system(f"xdg-open '{path}'")
            except Exception as e:
                QMessageBox.warning(
                    self, "Error", f"No se pudo abrir la ubicaci√≥n:\n{str(e)}"
                )

    def copy_item_path(self, tree_item):
        """Copiar ruta del elemento al clipboard"""
        result_data = tree_item.data(0, Qt.ItemDataRole.UserRole)
        if result_data:
            from PyQt6.QtWidgets import QApplication

            clipboard = QApplication.clipboard()
            clipboard.setText(result_data["path"])
            self.status_label.setText(f"Ruta copiada: {result_data['path']}")

    def clear_results(self):
        """Limpiar resultados"""
        self.results_tree.clear()
        self.results_cache.clear()
        self.performance_manager.clear_cache()
        self.status_label.setText("Resultados limpiados.")
        self.add_selected_btn.setEnabled(False)

    def update_theme(self, theme_manager):
        """Actualizar tema del widget"""
        self.theme_manager = theme_manager
        self.setStyleSheet(self.theme_manager.get_stylesheet("dialog"))


@dataclass
class FileItem:
    """Clase para representar un archivo o carpeta"""

    name: str
    path: str
    is_directory: bool
    date_added: str
    last_modified: str
    size: Optional[int] = None
    description: str = ""
    # Reglas de automatizaci√≥n
    auto_destination: str = ""  # Patr√≥n de b√∫squeda para carpeta destino
    auto_check_duplicates: bool = True  # Verificar duplicados antes de pegar
    auto_rename_pattern: str = (
        ""  # Patr√≥n de renombrado (ej: "{folder_name}_{original}", "{file:0}", etc)
    )
    auto_skip_if_exists: bool = True  # Si existe, saltar (True) o sobrescribir (False)
    auto_create_folder: bool = True  # Crear carpeta autom√°ticamente si no existe
    auto_skip_on_repeat_paste: bool = True  # Saltar archivos existentes al pegar de nuevo

    # Nuevas automatizaciones avanzadas
    auto_organize_by_type: bool = False  # Organizar por tipo de archivo
    auto_compress_large_files: bool = False  # Comprimir archivos grandes
    auto_backup: bool = False  # Crear respaldo
    auto_convert_format: bool = False  # Convertir formato
    auto_extract_metadata: bool = False  # Extraer metadatos
    auto_watermark: bool = False  # Agregar marca de agua
    auto_optimize_images: bool = False  # Optimizar im√°genes
    auto_encrypt: bool = False  # Encriptar archivo
    auto_scan_virus: bool = False  # Escanear virus
    auto_cloud_sync: bool = False  # Sincronizar con nube

    # Configuraci√≥n de archivos dentro de carpetas
    folder_files_patterns: dict = None  # {nombre_archivo: patr√≥n_renombrado}
    folder_files_detected: list = None  # Lista de archivos detectados en la carpeta
    folder_subfolders_detected: list = None  # Lista de subcarpetas detectadas en la carpeta
    folder_subfolders_patterns: dict = None  # {nombre_subcarpeta: patr√≥n_renombrado}


class FileAutomationEngine:
    """Motor de automatizaci√≥n para procesamiento inteligente de archivos"""

    def __init__(self):
        pass

    def find_destination_folder(
        self, pattern: str, base_search_path: str = None, search_subfolders: bool = True, auto_create_enabled: bool = True
    ) -> Optional[str]:
        """
        Buscar carpeta de destino seg√∫n patr√≥n flexible.

        Args:
            pattern: Patr√≥n de b√∫squeda flexible:
                     - Ruta completa: "C:/MiCarpeta"
                     - Ruta jer√°rquica: "Proyectos/2024"
                     - Palabras clave: "cm, control, material" (busca carpetas con alguna palabra)
                     - B√∫squeda anidada: "Carpeta A -> Carpeta B" (busca Carpeta B dentro de Carpeta A)
            base_search_path: Ruta base donde buscar (None = b√∫squeda amplia)
            search_subfolders: Si True, busca recursivamente en subcarpetas

        Returns:
            Ruta completa de la carpeta encontrada o None
        """
        if not pattern:
            return None

        # Si el patr√≥n es una ruta completa y existe, usarla directamente
        if os.path.isabs(pattern) and os.path.exists(pattern):
            print(f"‚úì Carpeta encontrada (ruta absoluta): {pattern}")
            return pattern

        # Definir rutas base para buscar
        search_paths = []
        if base_search_path:
            search_paths.append(base_search_path)
        else:
            # Buscar en ubicaciones comunes
            search_paths.extend(
                [
                    os.path.expanduser("~"),  # Home del usuario
                    os.path.join(os.path.expanduser("~"), "Documents"),
                    os.path.join(os.path.expanduser("~"), "Desktop"),
                    os.path.join(os.path.expanduser("~"), "Downloads"),
                    "C:\\",  # Ra√≠z del sistema (si es Windows)
                    "D:\\",  # Disco adicional com√∫n
                ]
            )

        # Detectar tipo de patr√≥n
        # Si contiene '->', es una b√∫squeda anidada (Carpeta A -> Carpeta B -> Carpeta C)
        if "->" in pattern:
            # Modo anidado: buscar y crear estructura completa
            nested_parts = [p.strip() for p in pattern.split("->") if p.strip()]
            if len(nested_parts) >= 2:
                print(f"üîç B√∫squeda anidada multi-nivel: {' -> '.join(nested_parts)}")
                
                # Construir estructura de carpetas paso a paso
                current_path = base_search_path if base_search_path else None
                
                for i, folder_name in enumerate(nested_parts):
                    if current_path:
                        # Buscar la carpeta dentro del path actual
                        found_path = self.find_destination_folder(folder_name, current_path, search_subfolders, auto_create_enabled)
                        if found_path:
                            current_path = found_path
                            print(f"‚úì Nivel {i+1}: '{folder_name}' encontrado en {current_path}")
                        else:
                            # No se encontr√≥ la carpeta
                            if auto_create_enabled:
                                # Crear la carpeta dentro del path actual
                                new_path = os.path.join(current_path, folder_name)
                                try:
                                    os.makedirs(new_path, exist_ok=True)
                                    current_path = new_path
                                    print(f"‚úì Nivel {i+1}: '{folder_name}' creado en {current_path}")
                                except Exception as e:
                                    print(f"‚ùå Error creando '{folder_name}' en {current_path}: {e}")
                                    return None
                            else:
                                # Auto-creaci√≥n desactivada, no crear carpetas
                                print(f"‚ùå No se encontr√≥ '{folder_name}' en {current_path} y auto-creaci√≥n est√° desactivada")
                                return None
                    else:
                        # Primera carpeta: buscar en todas las ubicaciones
                        found_path = self.find_destination_folder(folder_name, base_search_path, search_subfolders, auto_create_enabled)
                        if found_path:
                            current_path = found_path
                            print(f"‚úì Nivel {i+1}: '{folder_name}' encontrado en {current_path}")
                        else:
                            # No se encontr√≥ la primera carpeta
                            if auto_create_enabled:
                                # Intentar crear en el directorio actual como fallback
                                print(f"‚ö† No se encontr√≥ la carpeta ra√≠z '{folder_name}', auto-creaci√≥n no aplicable para carpeta ra√≠z")
                                return None
                            else:
                                print(f"‚ùå No se encontr√≥ la carpeta ra√≠z '{folder_name}' y auto-creaci√≥n est√° desactivada")
                                return None
                
                if current_path:
                    print(f"‚úì Estructura anidada completa: {current_path}")
                    return current_path
                else:
                    print(f"‚ùå No se pudo construir la estructura anidada")
                    return None
            else:
                # Si no hay suficientes partes, tratar como patr√≥n simple
                pattern_parts = [pattern.strip()]
                use_flexible_search = True
        elif "/" in pattern or "\\" in pattern:
            # Modo jer√°rquico: todas las partes deben estar en la ruta
            pattern_parts = pattern.replace("\\", "/").split("/")
            pattern_parts = [p.strip() for p in pattern_parts if p.strip()]
            use_flexible_search = False
        elif "," in pattern:
            # Modo flexible: palabras clave separadas por comas
            pattern_parts = [p.strip() for p in pattern.split(",") if p.strip()]
            use_flexible_search = True
        else:
            # Modo simple: una sola palabra/frase
            pattern_parts = [pattern.strip()]
            use_flexible_search = True

        print(f"üîç Buscando carpeta con patr√≥n: {pattern}")
        print(
            f"   Modo: {'Flexible (palabras clave)' if use_flexible_search else 'Jer√°rquico (ruta)'}"
        )
        print(f"   Partes del patr√≥n: {pattern_parts}")

        # Buscar en cada ruta base
        best_match = None
        best_score = 0

        for base_path in search_paths:
            if not os.path.exists(base_path):
                continue

            try:
                # Buscar coincidencia
                if use_flexible_search:
                    match, score = self._search_folder_flexible(
                        base_path,
                        pattern_parts,
                        max_depth=4 if search_subfolders else 1,
                    )
                    if match and score > best_score:
                        best_match = match
                        best_score = score
                else:
                    match = self._search_folder_recursive(
                        base_path,
                        pattern_parts,
                        max_depth=4 if search_subfolders else 1,
                    )
                    if match:
                        print(f"‚úì Carpeta encontrada: {match}")
                        return match
            except Exception as e:
                print(f"Error buscando en {base_path}: {e}")
                continue

        if best_match:
            print(f"‚úì Carpeta encontrada (score: {best_score}): {best_match}")
            return best_match

        print(f"‚ö† No se encontr√≥ carpeta con el patr√≥n: {pattern}")
        return None

    def _search_folder_recursive(
        self,
        current_path: str,
        pattern_parts: list,
        max_depth: int,
        current_depth: int = 0,
    ) -> Optional[str]:
        """B√∫squeda recursiva de carpeta que coincida con todas las partes del patr√≥n"""
        if current_depth > max_depth:
            return None

        try:
            # Verificar si la ruta actual contiene todas las partes del patr√≥n
            current_path_lower = current_path.lower()
            if all(part.lower() in current_path_lower for part in pattern_parts):
                return current_path

            # Buscar en subcarpetas
            for item in os.listdir(current_path):
                item_path = os.path.join(current_path, item)
                if os.path.isdir(item_path):
                    # Verificar si este directorio coincide
                    item_path_lower = item_path.lower()
                    if all(part.lower() in item_path_lower for part in pattern_parts):
                        return item_path

                    # Buscar recursivamente
                    result = self._search_folder_recursive(
                        item_path, pattern_parts, max_depth, current_depth + 1
                    )
                    if result:
                        return result
        except (PermissionError, OSError):
            pass

        return None

    def _search_folder_flexible(
        self, current_path: str, keywords: list, max_depth: int, current_depth: int = 0
    ) -> tuple[Optional[str], int]:
        """
        B√∫squeda flexible de carpeta que contenga ALGUNA de las palabras clave.
        Retorna la carpeta con mejor score (m√°s palabras clave coincidentes).

        Returns:
            tuple(ruta_encontrada, score) donde score = n√∫mero de palabras clave encontradas
        """
        if current_depth > max_depth:
            return None, 0

        best_match = None
        best_score = 0

        try:
            # Calcular score para la ruta actual
            current_name = os.path.basename(current_path).lower()
            current_score = sum(
                1 for keyword in keywords if keyword.lower() in current_name
            )

            if current_score > 0:
                best_match = current_path
                best_score = current_score

            # Buscar en subcarpetas
            try:
                items = os.listdir(current_path)
            except (PermissionError, OSError):
                return best_match, best_score

            for item in items:
                item_path = os.path.join(current_path, item)
                if not os.path.isdir(item_path):
                    continue

                try:
                    # Calcular score para este directorio
                    item_name = item.lower()
                    item_score = sum(
                        1 for keyword in keywords if keyword.lower() in item_name
                    )

                    if item_score > best_score:
                        best_match = item_path
                        best_score = item_score

                    # Si encontramos una carpeta con todas las palabras clave, es perfecta
                    if item_score == len(keywords):
                        return best_match, best_score

                    # Buscar recursivamente solo si tiene sentido
                    if current_depth < max_depth:
                        sub_match, sub_score = self._search_folder_flexible(
                            item_path, keywords, max_depth, current_depth + 1
                        )
                        if sub_match and sub_score > best_score:
                            best_match = sub_match
                            best_score = sub_score

                        # Si encontramos score perfecto, detener b√∫squeda
                        if best_score == len(keywords):
                            return best_match, best_score

                except (PermissionError, OSError):
                    continue

        except (PermissionError, OSError):
            pass

        return best_match, best_score

    def check_duplicate(self, source_path: str, destination_folder: str) -> bool:
        """
        Verificar si el archivo ya existe en la carpeta de destino.

        Returns:
            True si ya existe, False si no existe
        """
        filename = os.path.basename(source_path)
        dest_path = os.path.join(destination_folder, filename)
        return os.path.exists(dest_path)

    def apply_rename_pattern(
        self, original_name: str, pattern: str, destination_folder: str
    ) -> str:
        """
        Aplicar patr√≥n de renombrado con variables avanzadas.

        Variables soportadas:
            ARCHIVO:
            {original} - Nombre original completo
            {name} - Nombre sin extensi√≥n
            {ext} - Solo la extensi√≥n (con punto)
            {name:N} - Primeros N caracteres del nombre
            {name:N:M} - Caracteres desde N hasta M

            CARPETA (espacios reemplazados por "_" autom√°ticamente):
            {folder_name} - Nombre de carpeta destino
            {parent_folder} - Carpeta padre de la carpeta destino
            {client} - Carpeta 2 niveles arriba (carpeta del cliente)
            {folder_parent:N} - N-√©simo nivel hacia arriba (0=actual, 1=padre, 2=abuelo...)
            {folder_prefix:PV} - Buscar carpeta ancestro que empiece con "PV"
            {folder_contains:texto} - Buscar carpeta ancestro que contenga "texto"
            {file:N} - N-√©simo archivo existente en carpeta destino

            FECHA Y HORA:
            {date} - Fecha (YYYY-MM-DD)
            {date_short} - Fecha (YYYYMMDD)
            {year} - A√±o (YYYY)
            {month} - Mes (MM)
            {day} - D√≠a (DD)
            {time} - Hora (HH-MM-SS)
            {time_short} - Hora (HHMMSS)
            {hour} - Hora (HH)
            {minute} - Minuto (MM)
            {second} - Segundo (SS)
            {timestamp} - Unix timestamp

            CONTADORES:
            {counter} - Contador autom√°tico (1, 2, 3...)
            {counter:3} - Contador con padding (001, 002, 003...)
            {random} - N√∫mero aleatorio (4 d√≠gitos)
            {random:N} - N√∫mero aleatorio de N d√≠gitos

            TRANSFORMACIONES:
            {upper:texto} - TEXTO en may√∫sculas
            {lower:texto} - texto en min√∫sculas
            {title:texto} - Texto Con May√∫scula Inicial

            EXTRACCI√ìN DESDE RUTAS EXTERNAS:
            {path_file:ruta:N} - Nombre completo del N-√©simo archivo de una ruta externa
            {path_name:ruta:N} - Solo nombre (sin ext) del N-√©simo archivo de ruta externa
            {path_ext:ruta:N} - Solo extensi√≥n del N-√©simo archivo de ruta externa
            {path_folder:ruta} - Nombre de la √∫ltima carpeta de una ruta externa
            {path_parent:ruta:N} - N-√©simo nivel de carpeta de una ruta externa
            {path_count:ruta} - Cantidad de archivos en una ruta externa
            {path_content:ruta:N} - Contenido del N-√©simo archivo de texto (max 10KB)
            {path_line:ruta:N:L} - L√≠nea L del N-√©simo archivo en una ruta externa

        Args:
            original_name: Nombre original del archivo
            pattern: Patr√≥n con variables
            destination_folder: Carpeta de destino

        Returns:
            Nuevo nombre con patr√≥n aplicado
        """
        if not pattern:
            return original_name

        from datetime import datetime, timedelta
        import random
        import re

        result = pattern

        # Separar nombre y extensi√≥n del archivo original
        name_no_ext, ext = os.path.splitext(original_name)

        # ===== ARCHIVO =====
        # {original} - nombre original completo
        result = result.replace("{original}", original_name)

        # {name} - nombre sin extensi√≥n
        result = result.replace("{name}", name_no_ext)

        # {ext} - extensi√≥n con punto
        result = result.replace("{ext}", ext)

        # {name:N} - primeros N caracteres del nombre
        # {name:N:M} - substring del nombre
        name_slice_pattern = r"\{name:(\d+)(?::(\d+))?\}"
        for match in re.finditer(name_slice_pattern, result):
            start = int(match.group(1))
            end = int(match.group(2)) if match.group(2) else None
            if end:
                sliced = name_no_ext[start:end]
            else:
                sliced = name_no_ext[:start]
            result = result.replace(match.group(0), sliced)

        # ===== CARPETA =====
        # NOTA: Todas las variables de carpeta reemplazan espacios por "_" autom√°ticamente

        # {folder_name} - nombre de carpeta destino
        folder_name = os.path.basename(destination_folder).replace(" ", "_")
        result = result.replace("{folder_name}", folder_name)

        # {parent_folder} - carpeta padre
        try:
            parent_folder = os.path.basename(
                os.path.dirname(destination_folder)
            ).replace(" ", "_")
            result = result.replace("{parent_folder}", parent_folder)
        except:
            result = result.replace("{parent_folder}", "")

        # {client} - alias para carpeta 2 niveles arriba (carpeta del cliente)
        try:
            current_path = destination_folder
            # Subir 2 niveles
            current_path = os.path.dirname(current_path)  # Nivel 1
            current_path = os.path.dirname(current_path)  # Nivel 2
            client_folder = os.path.basename(current_path).replace(" ", "_")
            result = result.replace("{client}", client_folder)
        except:
            result = result.replace("{client}", "")

        # {folder_parent:N} - N-√©simo nivel hacia arriba (0=actual, 1=padre, 2=abuelo...)
        folder_parent_pattern = r"\{folder_parent:(\d+)\}"
        for match in re.finditer(folder_parent_pattern, result):
            level = int(match.group(1))
            try:
                current_path = destination_folder
                for _ in range(level):
                    current_path = os.path.dirname(current_path)
                folder_at_level = os.path.basename(current_path).replace(" ", "_")
                result = result.replace(match.group(0), folder_at_level)
            except:
                result = result.replace(match.group(0), "")

        # {folder_prefix:XXX} - Buscar carpeta ancestro que empiece con "XXX"
        folder_prefix_pattern = r"\{folder_prefix:([^}]+)\}"
        for match in re.finditer(folder_prefix_pattern, result):
            prefix = match.group(1)
            try:
                current_path = destination_folder
                found = ""
                # Buscar hasta 10 niveles hacia arriba
                for _ in range(10):
                    folder_name_check = os.path.basename(current_path)
                    if folder_name_check.upper().startswith(prefix.upper()):
                        found = folder_name_check.replace(" ", "_")
                        break
                    parent = os.path.dirname(current_path)
                    if parent == current_path:  # Llegamos a la ra√≠z
                        break
                    current_path = parent
                result = result.replace(match.group(0), found)
            except:
                result = result.replace(match.group(0), "")

        # {folder_contains:XXX} - Buscar carpeta ancestro que contenga "XXX"
        folder_contains_pattern = r"\{folder_contains:([^}]+)\}"
        for match in re.finditer(folder_contains_pattern, result):
            text = match.group(1)
            try:
                current_path = destination_folder
                found = ""
                # Buscar hasta 10 niveles hacia arriba
                for _ in range(10):
                    folder_name_check = os.path.basename(current_path)
                    if text.upper() in folder_name_check.upper():
                        found = folder_name_check.replace(" ", "_")
                        break
                    parent = os.path.dirname(current_path)
                    if parent == current_path:  # Llegamos a la ra√≠z
                        break
                    current_path = parent
                result = result.replace(match.group(0), found)
            except:
                result = result.replace(match.group(0), "")

        # {file:N} - N-√©simo archivo de la carpeta destino
        try:
            dest_files = [
                f
                for f in os.listdir(destination_folder)
                if os.path.isfile(os.path.join(destination_folder, f))
            ]
            dest_files.sort()

            for i in range(20):  # Soportar {file:0} a {file:19}
                if f"{{file:{i}}}" in result:
                    if i < len(dest_files):
                        file_name = os.path.splitext(dest_files[i])[0]
                        result = result.replace(f"{{file:{i}}}", file_name)
                    else:
                        result = result.replace(f"{{file:{i}}}", f"file{i}")
        except:
            pass

        # ===== FECHA Y HORA =====
        now = datetime.now()

        # Fecha
        result = result.replace("{date}", now.strftime("%Y-%m-%d"))
        result = result.replace("{date_short}", now.strftime("%Y%m%d"))
        result = result.replace("{year}", now.strftime("%Y"))
        result = result.replace("{month}", now.strftime("%m"))
        result = result.replace("{day}", now.strftime("%d"))

        # Hora
        result = result.replace("{time}", now.strftime("%H-%M-%S"))
        result = result.replace("{time_short}", now.strftime("%H%M%S"))
        result = result.replace("{hour}", now.strftime("%H"))
        result = result.replace("{minute}", now.strftime("%M"))
        result = result.replace("{second}", now.strftime("%S"))

        # Timestamp
        result = result.replace("{timestamp}", str(int(now.timestamp())))

        # ===== CONTADORES Y ALEATORIOS =====
        # {counter} - se dejar√° para manejar despu√©s

        # {counter:N} - contador con padding
        counter_padding_pattern = r"\{counter:(\d+)\}"
        for match in re.finditer(counter_padding_pattern, result):
            padding = int(match.group(1))
            # Se reemplazar√° despu√©s con el contador real
            result = result.replace(match.group(0), f"{{counter:{padding}}}")

        # {random} - n√∫mero aleatorio de 4 d√≠gitos
        if "{random}" in result:
            result = result.replace("{random}", str(random.randint(1000, 9999)))

        # {random:N} - n√∫mero aleatorio de N d√≠gitos
        random_pattern = r"\{random:(\d+)\}"
        for match in re.finditer(random_pattern, result):
            digits = int(match.group(1))
            min_val = 10 ** (digits - 1) if digits > 1 else 0
            max_val = (10**digits) - 1
            result = result.replace(
                match.group(0), str(random.randint(min_val, max_val))
            )

        # ===== TRANSFORMACIONES =====
        # {upper:texto}
        upper_pattern = r"\{upper:([^}]+)\}"
        for match in re.finditer(upper_pattern, result):
            text = match.group(1)
            result = result.replace(match.group(0), text.upper())

        # {lower:texto}
        lower_pattern = r"\{lower:([^}]+)\}"
        for match in re.finditer(lower_pattern, result):
            text = match.group(1)
            result = result.replace(match.group(0), text.lower())

        # {title:texto}
        title_pattern = r"\{title:([^}]+)\}"
        for match in re.finditer(title_pattern, result):
            text = match.group(1)
            result = result.replace(match.group(0), text.title())

        # ===== NUEVAS TRANSFORMACIONES =====
        # {camel:texto} - ConvierteACamelCase
        camel_pattern = r"\{camel:([^}]+)\}"
        for match in re.finditer(camel_pattern, result):
            text = match.group(1)
            # Convertir a camelCase
            words = re.sub(r"[^a-zA-Z0-9\s]", " ", text).split()
            camel_text = words[0].lower() if words else ""
            for word in words[1:]:
                camel_text += word.capitalize()
            result = result.replace(match.group(0), camel_text)

        # {snake:texto} - convierte_a_snake_case
        snake_pattern = r"\{snake:([^}]+)\}"
        for match in re.finditer(snake_pattern, result):
            text = match.group(1)
            # Convertir a snake_case
            snake_text = re.sub(r"[^a-zA-Z0-9\s]", " ", text)
            snake_text = re.sub(r"\s+", "_", snake_text.strip()).lower()
            result = result.replace(match.group(0), snake_text)

        # {kebab:texto} - convierte-a-kebab-case
        kebab_pattern = r"\{kebab:([^}]+)\}"
        for match in re.finditer(kebab_pattern, result):
            text = match.group(1)
            # Convertir a kebab-case
            kebab_text = re.sub(r"[^a-zA-Z0-9\s]", " ", text)
            kebab_text = re.sub(r"\s+", "-", kebab_text.strip()).lower()
            result = result.replace(match.group(0), kebab_text)

        # {reverse:texto} - Invierte el texto
        reverse_pattern = r"\{reverse:([^}]+)\}"
        for match in re.finditer(reverse_pattern, result):
            text = match.group(1)
            result = result.replace(match.group(0), text[::-1])

        # {clean:texto} - Limpia caracteres especiales
        clean_pattern = r"\{clean:([^}]+)\}"
        for match in re.finditer(clean_pattern, result):
            text = match.group(1)
            # Mantener solo letras, n√∫meros y espacios
            clean_text = re.sub(r"[^a-zA-Z0-9\s]", "", text)
            clean_text = re.sub(r"\s+", " ", clean_text.strip())
            result = result.replace(match.group(0), clean_text)

        # {slug:texto} - Convierte a slug URL-friendly
        slug_pattern = r"\{slug:([^}]+)\}"
        for match in re.finditer(slug_pattern, result):
            text = match.group(1)
            # Convertir a slug
            slug_text = re.sub(r"[^a-zA-Z0-9\s-]", "", text)
            slug_text = re.sub(r"\s+", "-", slug_text.strip()).lower()
            result = result.replace(match.group(0), slug_text)

        # ===== EXTRACCI√ìN DESDE RUTAS EXTERNAS =====
        # {path_file:ruta:N} - Nombre completo del N-√©simo archivo de una ruta
        path_file_pattern = r"\{path_file:([^:}]+):(\d+)\}"
        for match in re.finditer(path_file_pattern, result):
            external_path = match.group(1).strip()
            file_index = int(match.group(2))
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    files.sort()
                    if file_index < len(files):
                        result = result.replace(match.group(0), files[file_index])
                    else:
                        result = result.replace(match.group(0), f"file{file_index}")
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_name:ruta:N} - Solo nombre (sin extensi√≥n) del N-√©simo archivo
        path_name_pattern = r"\{path_name:([^:}]+):(\d+)\}"
        for match in re.finditer(path_name_pattern, result):
            external_path = match.group(1).strip()
            file_index = int(match.group(2))
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    files.sort()
                    if file_index < len(files):
                        name_only = os.path.splitext(files[file_index])[0]
                        result = result.replace(match.group(0), name_only)
                    else:
                        result = result.replace(match.group(0), f"name{file_index}")
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_folder:ruta} - Nombre de la √∫ltima carpeta de una ruta
        path_folder_pattern = r"\{path_folder:([^}]+)\}"
        for match in re.finditer(path_folder_pattern, result):
            external_path = match.group(1).strip()
            try:
                if os.path.exists(external_path):
                    folder_name_ext = os.path.basename(external_path).replace(" ", "_")
                    result = result.replace(match.group(0), folder_name_ext)
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_parent:ruta:N} - N-√©simo nivel de carpeta de una ruta
        path_parent_pattern = r"\{path_parent:([^:}]+):(\d+)\}"
        for match in re.finditer(path_parent_pattern, result):
            external_path = match.group(1).strip()
            level = int(match.group(2))
            try:
                current = external_path
                for _ in range(level):
                    current = os.path.dirname(current)
                folder_at_level = os.path.basename(current).replace(" ", "_")
                result = result.replace(match.group(0), folder_at_level)
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_count:ruta} - Cantidad de archivos en una ruta
        path_count_pattern = r"\{path_count:([^}]+)\}"
        for match in re.finditer(path_count_pattern, result):
            external_path = match.group(1).strip()
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    result = result.replace(match.group(0), str(len(files)))
                else:
                    result = result.replace(match.group(0), "0")
            except Exception as e:
                result = result.replace(match.group(0), "0")

        # {path_content:ruta:N} - Contenido completo del N-√©simo archivo (para archivos de texto peque√±os)
        path_content_pattern = r"\{path_content:([^:}]+):(\d+)\}"
        for match in re.finditer(path_content_pattern, result):
            external_path = match.group(1).strip()
            file_index = int(match.group(2))
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    files.sort()
                    if file_index < len(files):
                        file_path = os.path.join(external_path, files[file_index])
                        # Leer solo si es archivo de texto y menor a 10KB
                        if os.path.getsize(file_path) < 10240:
                            try:
                                with open(file_path, "r", encoding="utf-8") as f:
                                    content = f.read().strip()
                                    # Reemplazar saltos de l√≠nea y espacios m√∫ltiples
                                    content = re.sub(r"\s+", " ", content)
                                    result = result.replace(match.group(0), content)
                            except:
                                result = result.replace(match.group(0), "")
                        else:
                            result = result.replace(match.group(0), "")
                    else:
                        result = result.replace(match.group(0), "")
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_line:ruta:N:L} - L√≠nea L del N-√©simo archivo en una ruta
        path_line_pattern = r"\{path_line:([^:}]+):(\d+):(\d+)\}"
        for match in re.finditer(path_line_pattern, result):
            external_path = match.group(1).strip()
            file_index = int(match.group(2))
            line_number = int(match.group(3))
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    files.sort()
                    if file_index < len(files):
                        file_path = os.path.join(external_path, files[file_index])
                        try:
                            with open(file_path, "r", encoding="utf-8") as f:
                                lines = f.readlines()
                                if line_number < len(lines):
                                    line_content = lines[line_number].strip()
                                    result = result.replace(match.group(0), line_content)
                                else:
                                    result = result.replace(match.group(0), "")
                        except:
                            result = result.replace(match.group(0), "")
                    else:
                        result = result.replace(match.group(0), "")
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # {path_ext:ruta:N} - Solo extensi√≥n del N-√©simo archivo
        path_ext_pattern = r"\{path_ext:([^:}]+):(\d+)\}"
        for match in re.finditer(path_ext_pattern, result):
            external_path = match.group(1).strip()
            file_index = int(match.group(2))
            try:
                if os.path.exists(external_path) and os.path.isdir(external_path):
                    files = [
                        f
                        for f in os.listdir(external_path)
                        if os.path.isfile(os.path.join(external_path, f))
                    ]
                    files.sort()
                    if file_index < len(files):
                        ext_only = os.path.splitext(files[file_index])[1]
                        result = result.replace(match.group(0), ext_only)
                    else:
                        result = result.replace(match.group(0), "")
                else:
                    result = result.replace(match.group(0), "")
            except Exception as e:
                result = result.replace(match.group(0), "")

        # ===== INFORMACI√ìN DEL SISTEMA =====
        import getpass
        import platform

        # {user} - Nombre del usuario
        result = result.replace("{user}", getpass.getuser())

        # {computer} - Nombre del equipo
        result = result.replace("{computer}", platform.node())

        # {os} - Sistema operativo
        result = result.replace("{os}", platform.system())

        # {version} - Versi√≥n de la aplicaci√≥n
        result = result.replace("{version}", "1.0.0")

        # {size} - Tama√±o del archivo (requiere acceso al archivo)
        try:
            file_path = os.path.join(destination_folder, original_name)
            if os.path.exists(file_path):
                size_bytes = os.path.getsize(file_path)
                result = result.replace("{size}", str(size_bytes))

                # {size_kb} - Tama√±o en KB
                size_kb = size_bytes / 1024
                result = result.replace("{size_kb}", f"{size_kb:.1f}")

                # {size_mb} - Tama√±o en MB
                size_mb = size_bytes / (1024 * 1024)
                result = result.replace("{size_mb}", f"{size_mb:.1f}")

                # {size_human} - Tama√±o legible
                if size_bytes < 1024:
                    size_human = f"{size_bytes} B"
                elif size_bytes < 1024 * 1024:
                    size_human = f"{size_bytes / 1024:.1f} KB"
                else:
                    size_human = f"{size_bytes / (1024 * 1024):.1f} MB"
                result = result.replace("{size_human}", size_human)
        except:
            result = result.replace("{size}", "0")
            result = result.replace("{size_kb}", "0")
            result = result.replace("{size_mb}", "0")
            result = result.replace("{size_human}", "0 B")

        # ===== NUEVOS CONTADORES =====
        import uuid
        import hashlib

        # {uuid} - UUID completo
        result = result.replace("{uuid}", str(uuid.uuid4()))

        # {uuid_short} - UUID corto (primeros 8 caracteres)
        result = result.replace("{uuid_short}", str(uuid.uuid4())[:8])

        # {hash} - Hash MD5 del nombre original
        hash_md5 = hashlib.md5(original_name.encode()).hexdigest()
        result = result.replace("{hash}", hash_md5)

        # {hash_short} - Primeros 8 caracteres del hash
        result = result.replace("{hash_short}", hash_md5[:8])

        # ===== PATRONES AVANZADOS =====
        # {match:patr√≥n} - Extrae texto que coincida con patr√≥n
        match_pattern = r"\{match:([^}]+)\}"
        for match in re.finditer(match_pattern, result):
            pattern = match.group(1)
            try:
                # Buscar coincidencias en el nombre original
                matches = re.findall(pattern, original_name)
                if matches:
                    result = result.replace(match.group(0), matches[0])
                else:
                    result = result.replace(match.group(0), "")
            except:
                result = result.replace(match.group(0), "")

        # {replace:buscar|reemplazar} - Reemplaza texto
        replace_pattern = r"\{replace:([^|]+)\|([^}]+)\}"
        for match in re.finditer(replace_pattern, result):
            search_text = match.group(1)
            replace_text = match.group(2)
            result = result.replace(
                match.group(0), result.replace(search_text, replace_text)
            )

        # {substr:inicio:fin} - Subcadena
        substr_pattern = r"\{substr:(\d+):(\d+)\}"
        for match in re.finditer(substr_pattern, result):
            start = int(match.group(1))
            end = int(match.group(2))
            if start < len(original_name) and end <= len(original_name):
                substr = original_name[start:end]
                result = result.replace(match.group(0), substr)
            else:
                result = result.replace(match.group(0), "")

        # {pad:N:char} - Rellena con caracteres
        pad_pattern = r"\{pad:(\d+):([^}]+)\}"
        for match in re.finditer(pad_pattern, result):
            length = int(match.group(1))
            char = match.group(2)
            # Aplicar padding al nombre sin extensi√≥n
            padded = name_no_ext.ljust(length, char)
            result = result.replace(match.group(0), padded)

        # {trim:texto} - Elimina espacios
        trim_pattern = r"\{trim:([^}]+)\}"
        for match in re.finditer(trim_pattern, result):
            text = match.group(1)
            result = result.replace(match.group(0), text.strip())

        # {repeat:N} - Repite texto
        repeat_pattern = r"\{repeat:(\d+)\}"
        for match in re.finditer(repeat_pattern, result):
            count = int(match.group(1))
            # Repetir el nombre sin extensi√≥n
            repeated = name_no_ext * count
            result = result.replace(match.group(0), repeated)

        # Asegurar que la extensi√≥n se mantenga
        # Si el resultado no tiene extensi√≥n, agregar la extensi√≥n original
        if not os.path.splitext(result)[1] and ext:
            result = result + ext

        return result

    def process_file_with_automation(
        self, file_item: FileItem, fallback_destination: str
    ) -> dict:
        """
        Procesar un archivo o carpeta con reglas de automatizaci√≥n.

        Returns:
            dict con:
                - success: bool
                - destination: str (carpeta final de destino)
                - final_name: str (nombre final del archivo/carpeta)
                - skipped: bool (si se salt√≥ por duplicado)
                - message: str (mensaje explicativo)
                - folder_files: dict (solo para carpetas) con {nombre_original: nombre_nuevo}
        """
        result = {
            "success": False,
            "destination": fallback_destination,
            "final_name": os.path.basename(file_item.path),
            "skipped": False,
            "message": "",
            "folder_files": {},  # Para guardar renombrados de archivos internos
        }

        # 1. Determinar carpeta de destino
        if file_item.auto_destination:
            found_dest = self.find_destination_folder(
                file_item.auto_destination, fallback_destination, True, file_item.auto_create_folder
            )
            if found_dest:
                result["destination"] = found_dest
                result["message"] += f"üìÅ Destino autom√°tico: {found_dest}\n"
            else:
                # Si no se encontr√≥ y est√° habilitada la opci√≥n de crear carpeta
                if file_item.auto_create_folder:
                    # Determinar el nombre de la carpeta a crear
                    folder_name_to_create = file_item.auto_destination
                    
                    # Si es un patr√≥n anidado (contiene "->"), usar solo el √∫ltimo nombre
                    if "->" in file_item.auto_destination:
                        nested_parts = [p.strip() for p in file_item.auto_destination.split("->") if p.strip()]
                        if nested_parts:
                            folder_name_to_create = nested_parts[-1]  # Usar el √∫ltimo nombre
                            result["message"] += f"üîç Patr√≥n anidado detectado, creando carpeta: '{folder_name_to_create}'\n"
                    
                    # Crear carpeta en el directorio actual (fallback_destination)
                    new_folder_path = os.path.join(
                        fallback_destination, folder_name_to_create
                    )
                    try:
                        os.makedirs(new_folder_path, exist_ok=True)
                        result["destination"] = new_folder_path
                        result["message"] += f"‚ú® Carpeta creada: {new_folder_path}\n"
                        print(f"‚ú® Carpeta creada autom√°ticamente: {new_folder_path}")
                    except Exception as e:
                        result["message"] += (
                            f"‚ùå Error creando carpeta '{folder_name_to_create}': {str(e)}\n"
                        )
                        result["message"] += f"‚ö† Usando destino predeterminado\n"
                        print(f"Error creando carpeta: {e}")
                else:
                    result["message"] += (
                        f"‚ö† No se encontr√≥ carpeta con patr√≥n '{file_item.auto_destination}', usando destino predeterminado\n"
                    )

        # 2. Verificar duplicados
        if file_item.auto_check_duplicates:
            if self.check_duplicate(file_item.path, result["destination"]):
                if file_item.auto_skip_if_exists:
                    result["skipped"] = True
                    result["message"] += f"‚è≠Ô∏è Archivo ya existe, saltado\n"
                    return result
                else:
                    result["message"] += f"‚ö† Archivo ya existe, ser√° sobrescrito\n"

        # 3. Aplicar renombrado (para archivo o carpeta)
        if file_item.auto_rename_pattern:
            new_name = self.apply_rename_pattern(
                os.path.basename(file_item.path),
                file_item.auto_rename_pattern,
                result["destination"],
            )
            result["final_name"] = new_name
            result["message"] += f"üè∑Ô∏è Renombrado autom√°tico: {new_name}\n"

        # 4. Procesar archivos y subcarpetas internos si es una carpeta
        if file_item.is_directory and (file_item.folder_files_patterns or file_item.folder_subfolders_patterns or file_item.auto_rename_pattern):
            result["message"] += f"\nüìÇ Procesando contenido interno de la carpeta...\n"

            try:
                # Obtener lista actual de archivos y subcarpetas en la carpeta
                if os.path.exists(file_item.path) and os.path.isdir(file_item.path):
                    for item in os.listdir(file_item.path):
                        item_path = os.path.join(file_item.path, item)
                        if os.path.isfile(item_path):
                            original_name = item

                            # Verificar si hay patr√≥n espec√≠fico para este archivo
                            if file_item.folder_files_patterns and original_name in file_item.folder_files_patterns:
                                pattern = file_item.folder_files_patterns[original_name]
                            else:
                                # Si no hay patr√≥n espec√≠fico, usar el patr√≥n de la carpeta como fallback
                                pattern = file_item.auto_rename_pattern

                            # Determinar la carpeta de destino para el archivo
                            # (ser√° la carpeta pegada en su nueva ubicaci√≥n)
                            file_destination = os.path.join(
                                result["destination"], result["final_name"]
                            )

                            # Aplicar el patr√≥n de renombrado (si hay uno)
                            if pattern:
                                new_file_name = self.apply_rename_pattern(
                                    original_name,
                                    pattern,
                                    file_destination,
                                )
                            else:
                                # Si no hay patr√≥n, mantener nombre original
                                new_file_name = original_name

                            result["folder_files"][original_name] = new_file_name
                            if new_file_name != original_name:
                                result["message"] += (
                                    f"  ‚Ä¢ {original_name} ‚Üí {new_file_name}\n"
                                )
                                print(
                                    f"üìÑ Patr√≥n aplicado: {original_name} ‚Üí {new_file_name}"
                                )
                        
                        elif os.path.isdir(item_path):
                            original_name = item

                            # Verificar si hay patr√≥n espec√≠fico para esta subcarpeta
                            if file_item.folder_subfolders_patterns and original_name in file_item.folder_subfolders_patterns:
                                pattern = file_item.folder_subfolders_patterns[original_name]
                            else:
                                # Si no hay patr√≥n espec√≠fico, usar el patr√≥n de la carpeta como fallback
                                pattern = file_item.auto_rename_pattern

                            # Determinar la carpeta de destino para la subcarpeta
                            # (ser√° la carpeta pegada en su nueva ubicaci√≥n)
                            subfolder_destination = os.path.join(
                                result["destination"], result["final_name"]
                            )

                            # Aplicar el patr√≥n de renombrado (si hay uno)
                            if pattern:
                                new_subfolder_name = self.apply_rename_pattern(
                                    original_name,
                                    pattern,
                                    subfolder_destination,
                                )
                            else:
                                # Si no hay patr√≥n, mantener nombre original
                                new_subfolder_name = original_name

                            # Agregar a folder_files para que se procese en el pegado
                            result["folder_files"][original_name] = new_subfolder_name
                            if new_subfolder_name != original_name:
                                result["message"] += (
                                    f"  üìÅ {original_name} ‚Üí {new_subfolder_name}\n"
                                )
                                print(
                                    f"üìÅ Patr√≥n aplicado a subcarpeta: {original_name} ‚Üí {new_subfolder_name}"
                                )

            except Exception as e:
                result["message"] += f"‚ö†Ô∏è Error procesando contenido interno: {str(e)}\n"
                print(f"Error procesando contenido interno: {e}")

        # 4. Nuevas automatizaciones avanzadas
        if file_item.auto_organize_by_type:
            result = self.organize_by_file_type(file_item, result)

        if file_item.auto_compress_large_files:
            result = self.compress_large_files(file_item, result)

        if file_item.auto_backup:
            result = self.create_backup(file_item, result)

        if file_item.auto_convert_format:
            result = self.convert_file_format(file_item, result)

        if file_item.auto_extract_metadata:
            result = self.extract_and_save_metadata(file_item, result)

        if file_item.auto_watermark:
            result = self.add_watermark(file_item, result)

        if file_item.auto_optimize_images:
            result = self.optimize_images(file_item, result)

        if file_item.auto_encrypt:
            result = self.encrypt_file(file_item, result)

        if file_item.auto_scan_virus:
            result = self.scan_for_viruses(file_item, result)

        if file_item.auto_cloud_sync:
            result = self.sync_to_cloud(file_item, result)

        result["success"] = True
        return result

    def organize_by_file_type(self, file_item: FileItem, result: dict) -> dict:
        """Organizar archivos por tipo autom√°ticamente"""
        try:
            file_ext = os.path.splitext(file_item.path)[1].lower()

            # Mapeo de extensiones a carpetas
            type_folders = {
                ".pdf": "Documentos/PDF",
                ".doc": "Documentos/Word",
                ".docx": "Documentos/Word",
                ".xls": "Documentos/Excel",
                ".xlsx": "Documentos/Excel",
                ".ppt": "Documentos/PowerPoint",
                ".pptx": "Documentos/PowerPoint",
                ".txt": "Documentos/Texto",
                ".jpg": "Im√°genes/JPG",
                ".jpeg": "Im√°genes/JPG",
                ".png": "Im√°genes/PNG",
                ".gif": "Im√°genes/GIF",
                ".bmp": "Im√°genes/BMP",
                ".mp4": "Videos/MP4",
                ".avi": "Videos/AVI",
                ".mov": "Videos/MOV",
                ".mp3": "Audio/MP3",
                ".wav": "Audio/WAV",
                ".zip": "Archivos/Comprimidos",
                ".rar": "Archivos/Comprimidos",
                ".exe": "Programas/Executables",
                ".msi": "Programas/Instaladores",
            }

            if file_ext in type_folders:
                type_folder = type_folders[file_ext]
                new_dest = os.path.join(result["destination"], type_folder)
                os.makedirs(new_dest, exist_ok=True)
                result["destination"] = new_dest
                result["message"] += f"üìÅ Organizado por tipo: {type_folder}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error organizando por tipo: {str(e)}\n"

        return result

    def compress_large_files(self, file_item: FileItem, result: dict) -> dict:
        """Comprimir archivos grandes autom√°ticamente"""
        try:
            file_size = os.path.getsize(file_item.path)
            size_mb = file_size / (1024 * 1024)

            # Comprimir si es mayor a 10MB
            if size_mb > 10:
                import zipfile

                zip_name = os.path.splitext(result["final_name"])[0] + ".zip"
                zip_path = os.path.join(result["destination"], zip_name)

                with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                    zipf.write(file_item.path, os.path.basename(file_item.path))

                result["final_name"] = zip_name
                result["message"] += f"üóúÔ∏è Comprimido (era {size_mb:.1f}MB): {zip_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error comprimiendo: {str(e)}\n"

        return result

    def create_backup(self, file_item: FileItem, result: dict) -> dict:
        """Crear respaldo autom√°tico del archivo"""
        try:
            backup_folder = os.path.join(result["destination"], "Backups")
            os.makedirs(backup_folder, exist_ok=True)

            from datetime import datetime

            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{os.path.splitext(result['final_name'])[0]}_backup_{timestamp}{os.path.splitext(result['final_name'])[1]}"
            backup_path = os.path.join(backup_folder, backup_name)

            import shutil

            shutil.copy2(file_item.path, backup_path)
            result["message"] += f"üíæ Respaldo creado: {backup_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error creando respaldo: {str(e)}\n"

        return result

    def convert_file_format(self, file_item: FileItem, result: dict) -> dict:
        """Convertir formato de archivo autom√°ticamente"""
        try:
            file_ext = os.path.splitext(file_item.path)[1].lower()

            # Conversiones comunes
            conversions = {
                ".doc": ".docx",
                ".xls": ".xlsx",
                ".ppt": ".pptx",
                ".bmp": ".jpg",
                ".tiff": ".png",
            }

            if file_ext in conversions:
                new_ext = conversions[file_ext]
                new_name = os.path.splitext(result["final_name"])[0] + new_ext
                result["final_name"] = new_name
                result["message"] += f"üîÑ Convertido: {file_ext} ‚Üí {new_ext}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error convirtiendo formato: {str(e)}\n"

        return result

    def extract_and_save_metadata(self, file_item: FileItem, result: dict) -> dict:
        """Extraer y guardar metadatos del archivo"""
        try:
            metadata_folder = os.path.join(result["destination"], "Metadata")
            os.makedirs(metadata_folder, exist_ok=True)

            from datetime import datetime
            import json

            # Informaci√≥n b√°sica del archivo
            stat = os.stat(file_item.path)
            metadata = {
                "filename": os.path.basename(file_item.path),
                "size_bytes": stat.st_size,
                "created": datetime.fromtimestamp(stat.st_ctime).isoformat(),
                "modified": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                "accessed": datetime.fromtimestamp(stat.st_atime).isoformat(),
                "extension": os.path.splitext(file_item.path)[1],
                "path": file_item.path,
            }

            # Guardar metadatos como JSON
            metadata_file = os.path.join(
                metadata_folder,
                f"{os.path.splitext(result['final_name'])[0]}_metadata.json",
            )
            with open(metadata_file, "w", encoding="utf-8") as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)

            result["message"] += (
                f"üìä Metadatos extra√≠dos: {os.path.basename(metadata_file)}\n"
            )

        except Exception as e:
            result["message"] += f"‚ö† Error extrayendo metadatos: {str(e)}\n"

        return result

    def add_watermark(self, file_item: FileItem, result: dict) -> dict:
        """Agregar marca de agua a im√°genes"""
        try:
            file_ext = os.path.splitext(file_item.path)[1].lower()

            if file_ext in [".jpg", ".jpeg", ".png", ".bmp"]:
                # Solo para im√°genes
                watermark_folder = os.path.join(result["destination"], "Watermarked")
                os.makedirs(watermark_folder, exist_ok=True)

                watermarked_name = f"watermarked_{result['final_name']}"
                watermarked_path = os.path.join(watermark_folder, watermarked_name)

                # Copiar archivo (en una implementaci√≥n real se agregar√≠a la marca de agua)
                import shutil

                shutil.copy2(file_item.path, watermarked_path)

                result["message"] += f"üè∑Ô∏è Marca de agua agregada: {watermarked_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error agregando marca de agua: {str(e)}\n"

        return result

    def optimize_images(self, file_item: FileItem, result: dict) -> dict:
        """Optimizar im√°genes autom√°ticamente"""
        try:
            file_ext = os.path.splitext(file_item.path)[1].lower()

            if file_ext in [".jpg", ".jpeg", ".png", ".bmp"]:
                optimized_folder = os.path.join(result["destination"], "Optimized")
                os.makedirs(optimized_folder, exist_ok=True)

                optimized_name = f"optimized_{result['final_name']}"
                optimized_path = os.path.join(optimized_folder, optimized_name)

                # En una implementaci√≥n real se optimizar√≠a la imagen
                import shutil

                shutil.copy2(file_item.path, optimized_path)

                result["message"] += f"üñºÔ∏è Imagen optimizada: {optimized_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error optimizando imagen: {str(e)}\n"

        return result

    def encrypt_file(self, file_item: FileItem, result: dict) -> dict:
        """Encriptar archivo autom√°ticamente"""
        try:
            encrypted_folder = os.path.join(result["destination"], "Encrypted")
            os.makedirs(encrypted_folder, exist_ok=True)

            encrypted_name = f"encrypted_{result['final_name']}.enc"
            encrypted_path = os.path.join(encrypted_folder, encrypted_name)

            # Encriptaci√≥n simple (en una implementaci√≥n real se usar√≠a una librer√≠a de encriptaci√≥n)
            with open(file_item.path, "rb") as f:
                data = f.read()

            # XOR simple con clave fija (solo para demostraci√≥n)
            key = b"MySecretKey123"
            encrypted_data = bytes(
                a ^ b for a, b in zip(data, key * (len(data) // len(key) + 1))
            )

            with open(encrypted_path, "wb") as f:
                f.write(encrypted_data)

            result["message"] += f"üîí Archivo encriptado: {encrypted_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error encriptando: {str(e)}\n"

        return result

    def scan_for_viruses(self, file_item: FileItem, result: dict) -> dict:
        """Escanear archivo en busca de virus"""
        try:
            # Simulaci√≥n de escaneo (en una implementaci√≥n real se usar√≠a un antivirus)
            file_size = os.path.getsize(file_item.path)

            # Simular escaneo basado en tama√±o y extensi√≥n
            suspicious_extensions = [".exe", ".bat", ".cmd", ".scr", ".pif"]
            file_ext = os.path.splitext(file_item.path)[1].lower()

            if file_ext in suspicious_extensions:
                result["message"] += (
                    f"üîç Archivo escaneado: {result['final_name']} (‚ö† Extensi√≥n sospechosa)\n"
                )
            else:
                result["message"] += (
                    f"üîç Archivo escaneado: {result['final_name']} (‚úì Limpio)\n"
                )

        except Exception as e:
            result["message"] += f"‚ö† Error escaneando: {str(e)}\n"

        return result

    def sync_to_cloud(self, file_item: FileItem, result: dict) -> dict:
        """Sincronizar con servicios en la nube"""
        try:
            cloud_folder = os.path.join(result["destination"], "Cloud_Sync")
            os.makedirs(cloud_folder, exist_ok=True)

            # Simular sincronizaci√≥n (en una implementaci√≥n real se usar√≠a API de cloud)
            cloud_name = f"cloud_{result['final_name']}"
            cloud_path = os.path.join(cloud_folder, cloud_name)

            import shutil

            shutil.copy2(file_item.path, cloud_path)

            result["message"] += f"‚òÅÔ∏è Preparado para sincronizaci√≥n: {cloud_name}\n"

        except Exception as e:
            result["message"] += f"‚ö† Error preparando sincronizaci√≥n: {str(e)}\n"

        return result


class FileWatcher(QObject):
    """Observador de cambios en archivos"""

    file_changed = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.timer = QTimer()
        self.timer.timeout.connect(self.check_files)
        self.files_to_watch: Dict[str, float] = {}
        self.timer.start(2000)  # Verificar cada 2 segundos

    def add_file(self, filepath: str):
        """Agregar archivo para observar"""
        if os.path.exists(filepath):
            self.files_to_watch[filepath] = os.path.getmtime(filepath)

    def remove_file(self, filepath: str):
        """Remover archivo del observador"""
        if filepath in self.files_to_watch:
            del self.files_to_watch[filepath]

    def check_files(self):
        """Verificar si alg√∫n archivo ha cambiado"""
        for filepath, old_mtime in list(self.files_to_watch.items()):
            if os.path.exists(filepath):
                current_mtime = os.path.getmtime(filepath)
                if current_mtime != old_mtime:
                    self.files_to_watch[filepath] = current_mtime
                    self.file_changed.emit(filepath)
            else:
                # El archivo fue eliminado
                self.file_changed.emit(filepath)
                del self.files_to_watch[filepath]


class ItemWidget(QFrame):
    """Widget personalizado para mostrar un archivo o carpeta con mejoras de rendimiento"""

    item_removed = pyqtSignal(str)
    item_opened = pyqtSignal(str)

    def __init__(self, file_item: FileItem, parent=None):
        super().__init__(parent)
        self.file_item = file_item
        self.performance_manager = PerformanceManager()
        self.is_hovered = False
        self.animation_enabled = True
        self.setup_ui()
        self.setup_style()
        self.setup_animations()

    def setup_ui(self):
        """Configurar la interfaz del widget"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 8, 10, 8)
        layout.setSpacing(10)

        # Icono mejorado seg√∫n tipo de archivo
        icon_label = QLabel()
        icon_emoji = self.get_file_icon(self.file_item)
        icon_label.setText(icon_emoji)
        icon_label.setFixedSize(32, 32)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        icon_label.setStyleSheet("""
            font-size: 20pt;
            background-color: transparent;
            border: none;
        """)  # Hacer el emoji m√°s grande y sin fondo

        # Informaci√≥n del archivo
        info_layout = QVBoxLayout()
        info_layout.setSpacing(2)

        # Nombre
        name_label = QLabel(self.file_item.name)
        name_font = QFont()
        name_font.setBold(True)
        name_font.setPointSize(10)
        name_label.setFont(name_font)
        name_label.setStyleSheet("color: #ffffff; background-color: transparent;")

        # Ruta y detalles
        details = f"üìç {self.file_item.path}"
        if self.file_item.size is not None and not self.file_item.is_directory:
            size_mb = self.file_item.size / (1024 * 1024)
            details += f" | üìä {size_mb:.1f} MB"
        details += f" | üïí {self.file_item.last_modified}"

        details_label = QLabel(details)
        details_label.setStyleSheet(
            "color: #cccccc; font-size: 8pt; background-color: transparent;"
        )
        details_label.setWordWrap(True)

        info_layout.addWidget(name_label)
        info_layout.addWidget(details_label)

        # Descripci√≥n si existe
        if self.file_item.description:
            desc_label = QLabel(f"üí¨ {self.file_item.description}")
            desc_label.setStyleSheet(
                "color: #aaaaaa; font-size: 8pt; font-style: italic; background-color: transparent;"
            )
            desc_label.setWordWrap(True)
            info_layout.addWidget(desc_label)

        # Botones
        buttons_layout = QHBoxLayout()

        open_btn = QPushButton("Abrir")
        open_btn.setFixedSize(60, 25)
        open_btn.setToolTip("Abrir archivo o carpeta")
        open_btn.clicked.connect(self.open_item)

        # Bot√≥n de automatizaci√≥n
        auto_btn = QPushButton("‚öôÔ∏è")
        auto_btn.setFixedSize(30, 25)
        auto_btn.setToolTip("Configurar reglas de automatizaci√≥n")
        auto_btn.clicked.connect(self.configure_automation)
        auto_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                border: none;
                border-radius: 4px;
                color: white;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)

        # Indicador visual si tiene reglas configuradas
        if self.file_item.auto_destination or self.file_item.auto_rename_pattern:
            auto_btn.setStyleSheet("""
                QPushButton {
                    background-color: #ffc107;
                    border: none;
                    border-radius: 4px;
                    color: white;
                    font-size: 12pt;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #e0a800;
                }
            """)
            auto_btn.setToolTip("‚ö° Automatizaci√≥n configurada - Click para editar")

        remove_btn = QPushButton("√ó")
        remove_btn.setFixedSize(25, 25)
        remove_btn.setToolTip("Eliminar de la lista")
        remove_btn.clicked.connect(self.remove_item)
        remove_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                border: none;
                border-radius: 12px;
                color: white;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
        """)

        buttons_layout.addWidget(open_btn)
        buttons_layout.addWidget(auto_btn)
        buttons_layout.addWidget(remove_btn)

        layout.addWidget(icon_label)
        layout.addLayout(info_layout, 1)
        layout.addLayout(buttons_layout)

    def setup_style(self):
        """Configurar el estilo del widget"""
        self.setFixedHeight(80)
        self.setStyleSheet("""
            ItemWidget {
                background-color: #484848;
                border: 1px solid #606060;
                border-radius: 8px;
                margin: 2px;
            }
            ItemWidget:hover {
                background-color: #555555;
                border-color: #808080;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                font-weight: bold;
                padding: 4px;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QCheckBox {
                margin: 2px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
            QCheckBox::indicator:unchecked {
                background-color: #ffffff;
                border: 2px solid #555555;
                border-radius: 3px;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
                border: 2px solid #4a90e2;
                border-radius: 3px;
            }
            QLabel {
                background-color: transparent;
            }
        """)

    def setup_animations(self):
        """Configurar animaciones suaves"""
        from PyQt6.QtCore import QPropertyAnimation, QEasingCurve

        try:
            from PyQt6.QtWidgets import QGraphicsOpacityEffect
        except ImportError:
            # Fallback si no est√° disponible
            self.animation_enabled = False
            return

        if not self.animation_enabled:
            return

        # Efecto de opacidad para animaciones
        self.opacity_effect = QGraphicsOpacityEffect()
        self.setGraphicsEffect(self.opacity_effect)

        # Animaci√≥n de fade in
        self.fade_in_animation = QPropertyAnimation(self.opacity_effect, b"opacity")
        self.fade_in_animation.setDuration(300)
        self.fade_in_animation.setStartValue(0.0)
        self.fade_in_animation.setEndValue(1.0)
        self.fade_in_animation.setEasingCurve(QEasingCurve.Type.OutCubic)

        # Iniciar fade in
        self.fade_in_animation.start()

    def enterEvent(self, event):
        """Evento al entrar con el mouse"""
        self.is_hovered = True
        self.update_hover_style()
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Evento al salir con el mouse"""
        self.is_hovered = False
        self.update_hover_style()
        super().leaveEvent(event)

    def update_hover_style(self):
        """Actualizar estilo en hover"""
        if self.is_hovered:
            self.setStyleSheet(
                self.styleSheet()
                + """
                ItemWidget {
                    background-color: #454545;
                    border-color: #777777;
                }
            """
            )
        else:
            self.setup_style()

    def contextMenuEvent(self, event):
        """Mostrar men√∫ contextual al hacer clic derecho"""
        menu = QMenu(self)

        # Acci√≥n para abrir
        open_action = menu.addAction("üìÇ Abrir")
        open_action.triggered.connect(self.open_item)

        # Acci√≥n para actualizar
        refresh_action = menu.addAction("üîÑ Actualizar")
        refresh_action.triggered.connect(self.refresh_item_info)

        menu.addSeparator()

        # Acci√≥n para eliminar
        delete_action = menu.addAction("üóëÔ∏è Eliminar")
        delete_action.triggered.connect(self.remove_item)

        # Mostrar el men√∫ en la posici√≥n del cursor
        menu.exec(event.globalPos())

    def refresh_item_info(self):
        """Actualizar informaci√≥n del item"""
        # Verificar si el archivo/carpeta todav√≠a existe
        if not os.path.exists(self.file_item.path):
            QMessageBox.warning(
                self,
                "Archivo No Encontrado",
                f"El archivo o carpeta ya no existe:\n{self.file_item.path}\n\n"
                "Se eliminar√° de la lista.",
            )
            self.remove_item()
            return

        # Actualizar informaci√≥n del archivo
        try:
            if os.path.isfile(self.file_item.path):
                self.file_item.size = os.path.getsize(self.file_item.path)
                self.file_item.modified = os.path.getmtime(self.file_item.path)

            # Actualizar el nombre en caso de que haya cambiado
            self.file_item.name = os.path.basename(self.file_item.path)

            # Limpiar cach√© para forzar actualizaci√≥n
            if hasattr(self, "performance_manager"):
                self.performance_manager.clear_cache()

            # Actualizar la UI
            self.update_info()

            QMessageBox.information(
                self, "Actualizado", f"Informaci√≥n actualizada:\n{self.file_item.name}"
            )
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo actualizar:\n{str(e)}")

    def get_file_info_cached(self):
        """Obtener informaci√≥n de archivo usando cach√©"""
        return self.performance_manager.get_file_info(self.file_item.path)

    def get_file_icon(self, file_item):
        """Obtener icono emoji espec√≠fico seg√∫n tipo de archivo"""
        return get_file_icon_by_extension(file_item.path, file_item.is_directory)

    def open_item(self):
        """Abrir el archivo o carpeta"""
        self.item_opened.emit(self.file_item.path)

    def configure_automation(self):
        """Abrir di√°logo de configuraci√≥n de automatizaci√≥n"""
        dialog = AutomationRulesDialog(self.file_item, self)
        if dialog.exec():
            # Guardar datos despu√©s de configurar
            if hasattr(self.parent(), "parent") and hasattr(
                self.parent().parent(), "save_data"
            ):
                self.parent().parent().save_data()
            print(f"‚úì Reglas de automatizaci√≥n guardadas para: {self.file_item.name}")

    def is_selected_for_batch(self):
        """Verificar si est√° seleccionado para operaciones masivas"""
        # Checkbox eliminado - siempre retorna False
        return False

    def set_batch_selection(self, selected):
        """Establecer selecci√≥n para operaciones masivas"""
        # Checkbox eliminado - m√©todo vac√≠o para compatibilidad
        pass

    def remove_item(self):
        """Eliminar el item de la lista"""
        # Emitir se√±al de eliminaci√≥n directamente
        self.item_removed.emit(self.file_item.path)
        print(f"Se√±al de eliminaci√≥n emitida para: {self.file_item.path}")

    def update_info(self):
        """Actualizar informaci√≥n del archivo usando cach√©"""
        cached_info = self.get_file_info_cached()
        if cached_info and cached_info != self.file_item:
            # Actualizar informaci√≥n si ha cambiado
            self.file_item.size = cached_info.get("size")
            self.file_item.last_modified = datetime.fromtimestamp(
                cached_info.get("modified", time.time())
            ).strftime("%Y-%m-%d %H:%M:%S")
            self.setup_ui()  # Refrescar UI con nueva informaci√≥n


class DropArea(QScrollArea):
    """√Årea de arrastre y soltado"""

    files_dropped = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.items: List[FileItem] = []
        self.item_widgets: Dict[str, ItemWidget] = {}
        self.multi_clipboard = MultiClipboard()  # Sistema de clipboard m√∫ltiple
        self.setup_ui()
        self.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def setup_ui(self):
        """Configurar la interfaz del √°rea de arrastre"""
        self.setWidgetResizable(True)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        # Widget contenedor
        self.container = QWidget()
        self.layout = QVBoxLayout(self.container)
        self.layout.setSpacing(5)
        self.layout.setContentsMargins(10, 10, 10, 10)

        # Etiqueta de instrucciones
        self.instruction_label = QLabel(
            "üéØ Arrastra archivos y carpetas aqu√≠\n\n"
            "üìÇ Los elementos se guardar√°n autom√°ticamente\n"
            "üîÑ Se detectar√°n cambios en los archivos\n"
            "‚ú® Haz doble clic para abrir elementos\n\n"
            "üìã Funcionalidades de clipboard:\n"
            "‚Ä¢ Clic derecho para pegar\n"
            "‚Ä¢ Ctrl+V para pegar desde teclado\n\n"
            "‚ö° NUEVO: Pegado R√°pido (Ctrl+Alt+V):\n"
            "‚Ä¢ Pega directamente en directorio actual\n"
            "‚Ä¢ Sin necesidad de seleccionar destino\n"
            "‚Ä¢ Ctrl+Shift+D para cambiar directorio\n\n"
            "üîÑ OPCI√ìN: Inicio en segundo plano:\n"
            "‚Ä¢ Marca la casilla para iniciar minimizado\n"
            "‚Ä¢ La app ir√° directo a la bandeja del sistema\n"
            "‚Ä¢ Ctrl+Alt+V estar√° activo desde el inicio"
        )
        self.instruction_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.instruction_label.setStyleSheet("""
            QLabel {
                color: #888888;
                font-size: 11pt;
                padding: 30px;
                border: 2px dashed #555555;
                border-radius: 10px;
                background-color: #404040;
                line-height: 1.4;
            }
        """)

        self.layout.addWidget(self.instruction_label)
        self.layout.addStretch()

        self.setWidget(self.container)
        self.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #3d3d3d;
            }
            QScrollBar:vertical {
                background-color: #4a4a4a;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #6a6a6a;
                border-radius: 6px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #6a6a6a;
            }
        """)

    def dragEnterEvent(self, event: QDragEnterEvent):
        """Evento cuando se arrastra algo sobre el √°rea"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
            self.setStyleSheet(
                self.styleSheet()
                + """
                QScrollArea {
                    border: 2px dashed #4a90e2;
                }
            """
            )

    def dragLeaveEvent(self, event):
        """Evento cuando se deja de arrastrar"""
        self.setStyleSheet("""
            QScrollArea {
                border: none;
                background-color: #262626;
            }
            QScrollBar:vertical {
                background-color: #3a3a3a;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #5a5a5a;
                border-radius: 6px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #6a6a6a;
            }
        """)

    def dropEvent(self, event: QDropEvent):
        """Evento cuando se sueltan archivos"""
        self.dragLeaveEvent(event)
        urls = []
        for url in event.mimeData().urls():
            if url.isLocalFile():
                # Normalizar ruta para soportar rutas de red UNC correctamente
                path = normalize_network_path(url.toLocalFile())
                urls.append(path)

        if urls:
            self.files_dropped.emit(urls)

        event.acceptProposedAction()

    def add_item(self, file_item: FileItem):
        """Agregar un item al √°rea con optimizaci√≥n de rendimiento"""
        if file_item.path in self.item_widgets:
            return  # Ya existe

        # Ocultar instrucciones si es el primer item
        if not self.items:
            self.instruction_label.hide()

        self.items.append(file_item)

        # Usar weak reference para mejor gesti√≥n de memoria
        widget = ItemWidget(file_item)
        widget.item_removed.connect(self.remove_item)
        widget.item_opened.connect(self.open_item)

        self.item_widgets[file_item.path] = widget

        # Inserci√≥n optimizada
        insert_position = self.layout.count() - 1
        self.layout.insertWidget(insert_position, widget)

        # Lazy loading para mejor rendimiento con muchos elementos
        if len(self.items) > 100:
            widget.animation_enabled = (
                False  # Desactivar animaciones con muchos elementos
            )

        # Trigger plugin hook
        if hasattr(self.parent(), "plugin_manager"):
            self.parent().plugin_manager.trigger_hook("file_added", file_item.path)

        # Actualizar barra de estado del parent si existe
        if hasattr(self.parent(), "update_status_bar"):
            self.parent().update_status_bar()

    def _on_selection_changed(self):
        """Manejar cambio en selecci√≥n de checkbox"""
        if hasattr(self.parent(), "update_status_bar"):
            self.parent().update_status_bar()

    def remove_item(self, path: str):
        """Remover un item del √°rea"""
        print(f"DropArea.remove_item llamado para: {path}")
        print(f"Widgets disponibles: {list(self.item_widgets.keys())}")

        if path in self.item_widgets:
            print(f"Widget encontrado, eliminando: {path}")
            widget = self.item_widgets[path]

            # Remover del layout primero
            self.layout.removeWidget(widget)

            # Eliminar widget
            widget.setParent(None)
            widget.deleteLater()
            del self.item_widgets[path]

            # Remover del listado
            self.items = [item for item in self.items if item.path != path]
            print(f"Items restantes: {len(self.items)}")

            # Mostrar instrucciones si no hay items
            if not self.items:
                self.instruction_label.show()

            # Guardar datos despu√©s de eliminar
            if hasattr(self.parent(), "save_data"):
                print("Guardando datos...")
                self.parent().save_data()

            # Actualizar barra de estado del parent si existe
            if hasattr(self.parent(), "update_status_bar"):
                self.parent().update_status_bar()

            # Actualizar contador de elementos si existe
            if hasattr(self.parent(), "update_items_count"):
                self.parent().update_items_count()
        else:
            print(f"WARNING: Path no encontrado en item_widgets: {path}")

    def open_item(self, path: str):
        """Abrir un archivo o carpeta"""
        try:
            if sys.platform == "win32":
                os.startfile(path)
            elif sys.platform == "darwin":
                os.system(f"open '{path}'")
            else:
                os.system(f"xdg-open '{path}'")
        except Exception as e:
            QMessageBox.warning(
                self, "Error", f"No se pudo abrir el archivo:\n{str(e)}"
            )

    def clear_all(self):
        """Limpiar todos los items"""
        for widget in self.item_widgets.values():
            widget.deleteLater()
        self.item_widgets.clear()
        self.items.clear()
        self.instruction_label.show()

        # Actualizar barra de estado del parent si existe
        if hasattr(self.parent(), "update_status_bar"):
            self.parent().update_status_bar()

        # Actualizar contador de elementos si existe
        if hasattr(self.parent(), "update_items_count"):
            self.parent().update_items_count()

    def refresh_display(self):
        """Refrescar la visualizaci√≥n de items seg√∫n el orden actual"""
        # Eliminar todos los widgets del layout
        for widget in self.item_widgets.values():
            self.layout.removeWidget(widget)

        # Volver a a√±adir en el nuevo orden
        for item in self.items:
            if item.path in self.item_widgets:
                widget = self.item_widgets[item.path]
                insert_position = self.layout.count() - 1
                self.layout.insertWidget(insert_position, widget)

    def show_context_menu(self, position):
        """Mostrar men√∫ contextual"""
        context_menu = QMenu(self)

        clipboard_items = self.multi_clipboard.get_items()

        if clipboard_items:
            clipboard_count = len(clipboard_items)
            paste_action = context_menu.addAction(
                f"üìã Pegar Elementos ({clipboard_count})"
            )
            paste_action.triggered.connect(self.paste_items_with_selection)

            context_menu.addSeparator()

            # Mostrar algunos elementos del clipboard
            show_count = min(3, len(clipboard_items))
            for i, item in enumerate(clipboard_items[:show_count]):
                item_type = "üìÅ" if item["is_directory"] else "üìÑ"
                info_action = context_menu.addAction(
                    f"{item_type} {item['name'][:30]}..."
                )
                info_action.setEnabled(False)

            if len(clipboard_items) > show_count:
                more_action = context_menu.addAction(
                    f"... y {len(clipboard_items) - show_count} m√°s"
                )
                more_action.setEnabled(False)
        else:
            empty_action = context_menu.addAction("üìã Clipboard vac√≠o")
            empty_action.setEnabled(False)

        context_menu.addSeparator()
        clear_clipboard_action = context_menu.addAction("üóëÔ∏è Limpiar clipboard")
        clear_clipboard_action.triggered.connect(self.clear_clipboard)

        if not context_menu.isEmpty():
            context_menu.exec(self.mapToGlobal(position))

    def paste_items_with_selection(self):
        """Pegar elementos con selecci√≥n del clipboard m√∫ltiple"""
        clipboard_items = self.multi_clipboard.get_items()

        if not clipboard_items:
            QMessageBox.warning(
                self,
                "‚ö†Ô∏è Clipboard Vac√≠o",
                "No hay elementos en el clipboard.",
            )
            return

        # Mostrar di√°logo de selecci√≥n
        dialog = PasteSelectionDialog(clipboard_items, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_items = dialog.get_selected_items()
            self.paste_selected_items(selected_items)

    def paste_selected_items(self, selected_items):
        """Pegar elementos seleccionados espec√≠ficos con automatizaci√≥n"""
        if not selected_items:
            return

        try:
            # Determinar directorio de destino
            current_dir = os.getcwd()
            if hasattr(self, "parent") and hasattr(self.parent(), "current_directory"):
                current_dir = self.parent().current_directory

            # Crear motor de automatizaci√≥n
            automation_engine = FileAutomationEngine()

            pasted_files = []
            errors = []

            for item in selected_items:
                try:
                    source_path = item["path"]

                    # Verificar que el archivo origen a√∫n existe
                    if not os.path.exists(source_path):
                        errors.append(f"{item['name']}: El archivo origen ya no existe")
                        continue

                    # Buscar el FileItem correspondiente en la lista
                    matching_item = None
                    for stored_item in self.items:
                        if stored_item.path == source_path:
                            matching_item = stored_item
                            break

                    # Si hay un FileItem con configuraci√≥n, procesar con automatizaci√≥n
                    if matching_item and (
                        matching_item.auto_rename_pattern
                        or matching_item.folder_files_patterns
                    ):
                        # Procesar con motor de automatizaci√≥n
                        auto_result = automation_engine.process_file_with_automation(
                            matching_item, current_dir
                        )

                        destination_name = auto_result["final_name"]
                        destination_path = os.path.join(
                            auto_result["destination"], destination_name
                        )
                    else:
                        # Proceso normal sin automatizaci√≥n
                        source_name = os.path.basename(source_path)
                        destination_path = os.path.join(current_dir, source_name)

                    # Manejar archivos existentes
                    counter = 1
                    original_dest = destination_path
                    while os.path.exists(destination_path):
                        name, ext = os.path.splitext(os.path.basename(original_dest))
                        if item["is_directory"]:
                            new_name = f"{name} - Copia ({counter})"
                        else:
                            new_name = f"{name} - Copia ({counter}){ext}"
                        destination_path = os.path.join(
                            os.path.dirname(original_dest), new_name
                        )
                        counter += 1

                    # Copiar archivo o carpeta
                    if item["is_directory"]:
                        import shutil

                        shutil.copytree(source_path, destination_path)

                        # Renombrar archivos y subcarpetas internos si hay patrones configurados
                        if matching_item and hasattr(
                            automation_engine, "apply_rename_pattern"
                        ):
                            auto_result = (
                                automation_engine.process_file_with_automation(
                                    matching_item, current_dir
                                )
                            )
                            if auto_result.get("folder_files"):
                                for original_name, new_name in auto_result[
                                    "folder_files"
                                ].items():
                                    if original_name != new_name:
                                        try:
                                            old_file_path = os.path.join(
                                                destination_path, original_name
                                            )
                                            new_file_path = os.path.join(
                                                destination_path, new_name
                                            )

                                            if os.path.exists(old_file_path):
                                                os.rename(old_file_path, new_file_path)
                                                print(
                                                    f"  ‚úì Renombrado: {original_name} ‚Üí {new_name}"
                                                )
                                        except Exception as e:
                                            print(
                                                f"  ‚úó Error renombrando {original_name}: {e}"
                                            )
                    else:
                        import shutil

                        shutil.copy2(source_path, destination_path)

                    # Crear FileItem y agregarlo
                    file_item = FileItem(
                        path=destination_path,
                        name=os.path.basename(destination_path),
                        is_directory=os.path.isdir(destination_path),
                        size=os.path.getsize(destination_path)
                        if os.path.isfile(destination_path)
                        else None,
                        date_added=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        last_modified=datetime.fromtimestamp(
                            os.path.getmtime(destination_path)
                        ).strftime("%Y-%m-%d %H:%M:%S"),
                        description="",
                    )

                    self.add_item(file_item)
                    pasted_files.append(destination_path)

                except Exception as e:
                    errors.append(f"{item['name']}: {str(e)}")

            # Actualizar barra de estado
            if hasattr(self.parent(), "update_status_bar"):
                self.parent().update_status_bar()

            # Mostrar resultado
            if pasted_files:
                if errors:
                    QMessageBox.warning(
                        self,
                        "Pegado Parcial",
                        f"‚úÖ {len(pasted_files)} elementos pegados exitosamente.\n"
                        f"‚ùå {len(errors)} errores:\n\n"
                        + "\n".join(errors[:3])
                        + (f"\n... y {len(errors) - 3} m√°s" if len(errors) > 3 else ""),
                    )
                else:
                    QMessageBox.information(
                        self,
                        "‚úÖ Pegado Exitoso",
                        f"Todos los elementos ({len(pasted_files)}) fueron pegados exitosamente.\n\nüéâ ¬°Ya puedes acceder a tus copias!",
                    )
            else:
                QMessageBox.critical(
                    self, "‚ùå Error", "No se pudo pegar ning√∫n elemento."
                )

        except Exception as e:
            QMessageBox.critical(
                self,
                "‚ùå Error al Pegar",
                f"Error durante el proceso de pegado:\n\n{str(e)}",
            )

    def clear_clipboard(self):
        """Limpiar el clipboard m√∫ltiple"""
        count = self.multi_clipboard.count()
        self.multi_clipboard.clear_all()

        # Actualizar barra de estado del parent si existe
        if hasattr(self.parent(), "update_status_bar"):
            self.parent().update_status_bar()

        QMessageBox.information(
            self,
            "üìã Clipboard",
            f"üóëÔ∏è Clipboard limpiado exitosamente.\n{count} elementos eliminados.",
        )

    def update_item(self, path: str):
        """Actualizar informaci√≥n de un item"""
        if path in self.item_widgets and os.path.exists(path):
            # Encontrar el item y actualizarlo
            for i, item in enumerate(self.items):
                if item.path == path:
                    stat = os.stat(path)
                    self.items[i].last_modified = datetime.fromtimestamp(
                        stat.st_mtime
                    ).strftime("%Y-%m-%d %H:%M")
                    if not item.is_directory:
                        self.items[i].size = stat.st_size

                    # Recrear el widget con la nueva informaci√≥n
                    old_widget = self.item_widgets[path]
                    new_widget = ItemWidget(self.items[i])
                    new_widget.item_removed.connect(self.remove_item)
                    new_widget.item_opened.connect(self.open_item)

                    # Reemplazar en el layout
                    index = self.layout.indexOf(old_widget)
                    self.layout.insertWidget(index, new_widget)
                    old_widget.deleteLater()
                    self.item_widgets[path] = new_widget
                    break


class AddDescriptionDialog(QDialog):
    """Di√°logo para agregar descripci√≥n a un archivo"""

    def __init__(self, filename: str, current_description: str = "", parent=None):
        super().__init__(parent)
        self.filename = filename
        self.setWindowTitle(f"Agregar descripci√≥n - {filename}")
        set_window_icon(self)
        self.setFixedSize(400, 200)
        self.setup_ui(current_description)
        self.setup_style()

    def setup_ui(self, current_description: str):
        """Configurar la interfaz del di√°logo"""
        layout = QVBoxLayout(self)

        # Etiqueta
        label = QLabel(f"Descripci√≥n para: {self.filename}")
        label.setWordWrap(True)

        # Campo de texto
        self.text_edit = QTextEdit()
        self.text_edit.setPlainText(current_description)
        self.text_edit.setMaximumHeight(80)

        # Botones
        buttons = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)

        layout.addWidget(label)
        layout.addWidget(self.text_edit)
        layout.addWidget(buttons)

    def setup_style(self):
        """Configurar el estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #ffffff;
                color: #333333;
            }
            QLabel {
                color: #ffffff;
                font-weight: bold;
            }
            QTextEdit {
                background-color: #3a3a3a;
                border: 1px solid #555555;
                border-radius: 4px;
                color: #ffffff;
                padding: 5px;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
        """)

    def get_description(self) -> str:
        """Obtener la descripci√≥n ingresada"""
        return self.text_edit.toPlainText().strip()


class SearchDialog(QDialog):
    """Di√°logo de b√∫squeda para filtrar elementos"""

    def __init__(self, parent=None, items=None):
        super().__init__(parent)
        self.items = items or []
        self.setWindowTitle("üîç Buscar Elementos")
        set_window_icon(self)
        self.setFixedSize(550, 250)
        self.search_term = ""
        self.setup_ui()
        self.setup_style()

    def setup_ui(self):
        """Configurar la interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)

        # T√≠tulo
        title_label = QLabel("üîç Buscar en la lista de elementos")
        title_font = QFont()
        title_font.setPointSize(12)
        title_font.setBold(True)
        title_label.setFont(title_font)
        layout.addWidget(title_label)

        # Informaci√≥n
        info_label = QLabel(f"Total de elementos: {len(self.items)}")
        info_label.setStyleSheet("color: #888888; font-size: 10pt;")
        layout.addWidget(info_label)

        # Campo de b√∫squeda
        search_layout = QHBoxLayout()
        search_label = QLabel("Buscar:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Escribe el nombre, ruta o descripci√≥n...")
        self.search_input.returnPressed.connect(self.accept)  # Enter para buscar
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_input)
        layout.addLayout(search_layout)

        # Opciones de b√∫squeda
        options_label = QLabel(
            "üí° Tip: La b√∫squeda es sensible a may√∫sculas/min√∫sculas"
        )
        options_label.setStyleSheet(
            "color: #888888; font-size: 9pt; font-style: italic;"
        )
        layout.addWidget(options_label)

        layout.addStretch()

        # Botones
        buttons_layout = QHBoxLayout()

        self.clear_btn = QPushButton("üóëÔ∏è Limpiar")
        self.clear_btn.clicked.connect(self.clear_search)
        self.clear_btn.setFixedWidth(100)
        buttons_layout.addWidget(self.clear_btn)

        self.show_all_btn = QPushButton("üëÅÔ∏è Mostrar Todos")
        self.show_all_btn.clicked.connect(self.show_all_and_close)
        self.show_all_btn.setFixedWidth(120)
        self.show_all_btn.setToolTip("Mostrar todos los elementos y cerrar b√∫squeda")
        buttons_layout.addWidget(self.show_all_btn)

        buttons_layout.addStretch()

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)
        self.cancel_btn.setFixedWidth(100)
        buttons_layout.addWidget(self.cancel_btn)

        self.search_btn = QPushButton("üîç Buscar")
        self.search_btn.clicked.connect(self.accept)
        self.search_btn.setDefault(True)
        self.search_btn.setFixedWidth(100)
        buttons_layout.addWidget(self.search_btn)

        layout.addLayout(buttons_layout)

        # Foco en el campo de b√∫squeda
        self.search_input.setFocus()

    def setup_style(self):
        """Configurar el estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #ffffff;
                color: #333333;
            }
            QLabel {
                color: #ffffff;
            }
            QLineEdit {
                background-color: #3a3a3a;
                border: 2px solid #555555;
                border-radius: 4px;
                color: #ffffff;
                padding: 8px;
                font-size: 11pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 10px 16px;
                font-weight: bold;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QPushButton:pressed {
                background-color: #2d5f8d;
            }
            QPushButton#clear_btn {
                background-color: #666666;
            }
            QPushButton#clear_btn:hover {
                background-color: #777777;
            }
            QPushButton#show_all_btn {
                background-color: #5cb85c;
            }
            QPushButton#show_all_btn:hover {
                background-color: #4cae4c;
            }
        """)

        # IDs para los botones
        self.clear_btn.setObjectName("clear_btn")
        self.show_all_btn.setObjectName("show_all_btn")

    def clear_search(self):
        """Limpiar el campo de b√∫squeda"""
        self.search_input.clear()
        self.search_input.setFocus()

    def show_all_and_close(self):
        """Mostrar todos los elementos y cerrar el di√°logo"""
        # Establecer un valor especial para indicar que queremos mostrar todos
        self.search_term = "__SHOW_ALL__"
        self.accept()

    def get_search_term(self) -> str:
        """Obtener el t√©rmino de b√∫squeda"""
        return self.search_input.text().strip()


class AutomationRulesDialog(QDialog):
    """Di√°logo para configurar reglas de automatizaci√≥n de archivos"""

    def __init__(self, file_item: FileItem, parent=None):
        super().__init__(parent)
        self.file_item = file_item
        self.setWindowTitle(f"‚öôÔ∏è Reglas de Automatizaci√≥n - {file_item.name}")
        set_window_icon(self)
        self.setModal(True)
        self.setFixedSize(700, 650)  # Ventana m√°s grande para evitar scroll horizontal
        self.setup_ui()
        self.setup_style()
        self.load_current_rules()

    def setup_ui(self):
        """Configurar interfaz"""
        # Layout principal
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Crear √°rea de scroll
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        # Widget contenedor para el contenido
        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setSpacing(12)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel(f"‚öôÔ∏è Configurar Automatizaci√≥n")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        layout.addWidget(title_label)

        # Info del archivo
        item_type = "Carpeta" if self.file_item.is_directory else "Archivo"
        info_label = QLabel(f"üìÑ {item_type}: <b>{self.file_item.name}</b>")
        info_label.setStyleSheet("color: #888; margin-bottom: 10px;")
        layout.addWidget(info_label)

        # Si es una carpeta, detectar archivos dentro
        if self.file_item.is_directory:
            self.detect_folder_files()

        # --- Secci√≥n 1: Carpeta de Destino Autom√°tica ---
        dest_group = QGroupBox("üéØ Carpeta de Destino Autom√°tica")
        dest_layout = QVBoxLayout(dest_group)

        dest_info = QLabel(
            "<b>Formatos de b√∫squeda:</b><br>"
            "‚Ä¢ <b>Palabras clave:</b> 'cm, control, material' - Busca carpetas con alguna palabra<br>"
            "‚Ä¢ <b>Ruta jer√°rquica:</b> 'Proyectos/2024' - Busca ruta completa<br>"
            "‚Ä¢ <b>B√∫squeda anidada:</b> 'Carpeta A -> Carpeta B' - Busca Carpeta B dentro de Carpeta A<br>"
            "‚Ä¢ <b>Ruta absoluta:</b> 'C:/MiCarpeta' - Usa directamente<br><br>"
            "<b>Creaci√≥n autom√°tica:</b><br>"
            "‚Ä¢ Si no encuentra la carpeta y 'Crear carpeta si no existe' est√° activado<br>"
            "‚Ä¢ Para patrones anidados: construye toda la estructura de carpetas en orden<br>"
            "‚Ä¢ Si no encuentra una carpeta intermedia, la crea y contin√∫a con la siguiente<br><br>"
            "<i>Ejemplos:</i><br>"
            "‚Ä¢ 'cm, control' ‚Üí encuentra 'CM y Control de Material', 'Control Material', etc.<br>"
            "‚Ä¢ 'Proyectos -> 2024' ‚Üí busca '2024' dentro de 'Proyectos', si no existe crea '2024' dentro de 'Proyectos'<br>"
            "‚Ä¢ 'A -> B -> C -> D' ‚Üí busca A, luego B dentro de A, luego C dentro de B, luego D dentro de C. Si alguna no existe, la crea y contin√∫a"
        )
        dest_info.setWordWrap(True)
        dest_info.setStyleSheet(
            "color: #aaa; font-size: 9pt; margin-bottom: 8px; background: #2a2a2a; padding: 8px; border-radius: 4px;"
        )
        dest_layout.addWidget(dest_info)

        dest_input_layout = QHBoxLayout()
        dest_input_layout.addWidget(QLabel("üîç Patr√≥n:"))
        self.dest_input = QLineEdit()
        self.dest_input.setPlaceholderText(
            "Ej: cm, control, material  o  Proyectos/2024  o  Carpeta A -> Carpeta B"
        )
        dest_input_layout.addWidget(self.dest_input, 1)

        browse_dest_btn = QPushButton("üìÇ")
        browse_dest_btn.setToolTip("Examinar carpeta")
        browse_dest_btn.clicked.connect(self.browse_destination)
        browse_dest_btn.setMaximumWidth(50)
        dest_input_layout.addWidget(browse_dest_btn)

        dest_layout.addLayout(dest_input_layout)

        # Checkbox para crear carpeta si no existe
        self.create_folder_check = QCheckBox(
            "üìÅ Crear carpeta autom√°ticamente si no existe en el directorio actual"
        )
        self.create_folder_check.setChecked(True)
        self.create_folder_check.setToolTip(
            "Si no se encuentra la carpeta, se crear√° en el directorio donde pegues con Ctrl+Alt+V"
        )
        dest_layout.addWidget(self.create_folder_check)

        layout.addWidget(dest_group)

        # --- Secci√≥n 2: Verificaci√≥n de Duplicados ---
        dup_group = QGroupBox("‚úÖ Verificaci√≥n de Duplicados")
        dup_layout = QVBoxLayout(dup_group)

        self.check_duplicates_check = QCheckBox(
            "Verificar si el archivo ya existe antes de pegar"
        )
        self.check_duplicates_check.setChecked(True)
        dup_layout.addWidget(self.check_duplicates_check)

        self.skip_if_exists_check = QCheckBox(
            "‚ùå Saltar si ya existe (no sobrescribir)"
        )
        self.skip_if_exists_check.setChecked(True)
        self.skip_if_exists_check.setEnabled(False)
        dup_layout.addWidget(self.skip_if_exists_check)

        # Checkbox para saltar en pegado repetido
        self.skip_repeat_paste_check = QCheckBox(
            "üîÑ Saltar archivos existentes al pegar de nuevo"
        )
        self.skip_repeat_paste_check.setChecked(True)
        self.skip_repeat_paste_check.setToolTip(
            "Evita crear archivos duplicados cuando pegas el mismo archivo m√∫ltiples veces"
        )
        dup_layout.addWidget(self.skip_repeat_paste_check)

        # Conectar para habilitar/deshabilitar
        self.check_duplicates_check.toggled.connect(
            lambda checked: self.skip_if_exists_check.setEnabled(checked)
        )

        layout.addWidget(dup_group)

        # --- Secci√≥n 3: Renombrado Autom√°tico ---
        rename_group = QGroupBox("üè∑Ô∏è Renombrado Autom√°tico al Pegar")
        rename_layout = QVBoxLayout(rename_group)

        rename_info = QLabel(
            "<b>Variables principales:</b><br>"
            "‚Ä¢ Archivo: <code>{name}</code>, <code>{ext}</code>, <code>{original}</code><br>"
            "‚Ä¢ Carpeta: <code>{folder_name}</code>, <code>{parent_folder}</code>, <code>{client}</code> <span style='color: #4CAF50;'>(espacios‚Üí\"_\")</span><br>"
            "‚Ä¢ Niveles: <code>{folder_parent:N}</code>, <code>{folder_prefix:PV}</code><br>"
            "‚Ä¢ Fecha/Hora: <code>{date}</code>, <code>{time}</code>, <code>{year}</code>, <code>{month}</code><br>"
            "‚Ä¢ Contadores: <code>{counter:3}</code>, <code>{random:6}</code><br>"
            "‚Ä¢ Transform: <code>{upper:texto}</code>, <code>{lower:texto}</code><br>"
            "<br><i>Click en ‚ùì para ver la gu√≠a completa con todos los ejemplos</i>"
        )
        rename_info.setWordWrap(True)
        rename_info.setStyleSheet(
            "color: #aaa; font-size: 9pt; margin-bottom: 8px; background: #2a2a2a; padding: 8px; border-radius: 4px;"
        )
        rename_layout.addWidget(rename_info)

        rename_input_layout = QHBoxLayout()
        rename_input_layout.addWidget(QLabel("üìù Patr√≥n:"))
        self.rename_input = QLineEdit()
        self.rename_input.setPlaceholderText("Dejar vac√≠o para no renombrar")
        rename_input_layout.addWidget(self.rename_input, 1)

        help_btn = QPushButton("‚ùì")
        help_btn.setToolTip("Ver ayuda completa")
        help_btn.clicked.connect(self.show_rename_help)
        help_btn.setMaximumWidth(50)
        rename_input_layout.addWidget(help_btn)

        rename_layout.addLayout(rename_input_layout)

        # Botones de patrones predefinidos
        patterns_layout = QVBoxLayout()
        patterns_title = QLabel("<b>üìã Patrones Predefinidos:</b>")
        patterns_title.setStyleSheet(
            "color: #4a90e2; font-size: 10pt; margin-top: 8px;"
        )
        patterns_layout.addWidget(patterns_title)

        # Primera fila de patrones
        patterns_row1 = QHBoxLayout()
        patterns_row1.addWidget(
            self.create_pattern_button("üìÖ Fecha + Nombre", "{date}_{name}{ext}")
        )
        patterns_row1.addWidget(
            self.create_pattern_button("üïê Hora + Nombre", "{time_short}_{name}{ext}")
        )
        patterns_row1.addWidget(
            self.create_pattern_button(
                "üìÅ Carpeta + Nombre", "{folder_name}_{name}{ext}"
            )
        )
        patterns_row1.addWidget(
            self.create_pattern_button("üî¢ Contador", "{name}_{counter:3}{ext}")
        )
        patterns_layout.addLayout(patterns_row1)

        # Segunda fila de patrones
        patterns_row2 = QHBoxLayout()
        patterns_row2.addWidget(
            self.create_pattern_button(
                "üë§ Usuario + Fecha", "{user}_{date}_{name}{ext}"
            )
        )
        patterns_row2.addWidget(
            self.create_pattern_button(
                "üñ•Ô∏è PC + Timestamp", "{computer}_{timestamp}_{name}{ext}"
            )
        )
        patterns_row2.addWidget(
            self.create_pattern_button("üîí UUID + Nombre", "{uuid_short}_{name}{ext}")
        )
        patterns_row2.addWidget(
            self.create_pattern_button("üìä Hash + Nombre", "{hash_short}_{name}{ext}")
        )
        patterns_layout.addLayout(patterns_row2)

        # Tercera fila de patrones
        patterns_row3 = QHBoxLayout()
        patterns_row3.addWidget(
            self.create_pattern_button(
                "üîÑ Snake Case", "{snake:{folder_name}}_{name}{ext}"
            )
        )
        patterns_row3.addWidget(
            self.create_pattern_button(
                "üîó Kebab Case", "{kebab:{folder_name}}_{name}{ext}"
            )
        )
        patterns_row3.addWidget(
            self.create_pattern_button("üìè Tama√±o + Nombre", "{size_human}_{name}{ext}")
        )
        patterns_row3.addWidget(
            self.create_pattern_button(
                "üéØ Cliente + Proyecto", "{client}_{folder_prefix:PV}_{name}{ext}"
            )
        )
        patterns_layout.addLayout(patterns_row3)

        # Cuarta fila de patrones avanzados
        patterns_row4 = QHBoxLayout()
        patterns_row4.addWidget(
            self.create_pattern_button(
                "üî§ Camel Case", "{camel:{folder_name}}_{name}{ext}"
            )
        )
        patterns_row4.addWidget(
            self.create_pattern_button(
                "üßπ Limpio + Fecha", "{clean:{folder_name}}_{date}{ext}"
            )
        )
        patterns_row4.addWidget(
            self.create_pattern_button(
                "üîÑ Reemplazar", "{replace:{name}|_|-}_{date}{ext}"
            )
        )
        patterns_row4.addWidget(
            self.create_pattern_button(
                "üìù Slug + A√±o", "{slug:{folder_name}}_{year}{ext}"
            )
        )
        patterns_layout.addLayout(patterns_row4)

        rename_layout.addLayout(patterns_layout)

        # Vista previa
        self.rename_preview = QLabel("Vista previa: --")
        self.rename_preview.setStyleSheet(
            "color: #4a90e2; font-family: 'Consolas', monospace; padding: 8px; background: #2a2a2a; border-radius: 4px;"
        )
        rename_layout.addWidget(self.rename_preview)

        # Actualizar vista previa en tiempo real
        self.rename_input.textChanged.connect(self.update_rename_preview)

        layout.addWidget(rename_group)

        # --- Secci√≥n 4: Automatizaciones Avanzadas ---
        advanced_group = QGroupBox("üöÄ Automatizaciones Avanzadas")
        advanced_layout = QVBoxLayout(advanced_group)

        advanced_info = QLabel(
            "<b>Funciones autom√°ticas adicionales:</b><br>"
            "‚Ä¢ <b>Organizaci√≥n:</b> Clasificar archivos por tipo autom√°ticamente<br>"
            "‚Ä¢ <b>Procesamiento:</b> Comprimir, convertir, optimizar archivos<br>"
            "‚Ä¢ <b>Seguridad:</b> Encriptar, escanear virus, crear respaldos<br>"
            "‚Ä¢ <b>Integraci√≥n:</b> Sincronizar con la nube, extraer metadatos"
        )
        advanced_info.setWordWrap(True)
        advanced_info.setStyleSheet(
            "color: #aaa; font-size: 9pt; margin-bottom: 12px; background: #2a2a2a; padding: 10px; border-radius: 6px;"
        )
        advanced_layout.addWidget(advanced_info)

        # Crear grid de checkboxes para las automatizaciones
        automation_grid = QGridLayout()
        automation_grid.setSpacing(10)

        # Primera fila - Organizaci√≥n
        self.organize_check = QCheckBox("üìÅ Organizar por tipo de archivo")
        self.organize_check.setToolTip(
            "Clasifica autom√°ticamente en carpetas por tipo (PDF, Word, Excel, etc.)"
        )
        automation_grid.addWidget(self.organize_check, 0, 0)

        self.compress_check = QCheckBox("üóúÔ∏è Comprimir archivos grandes (>10MB)")
        self.compress_check.setToolTip(
            "Comprime autom√°ticamente archivos que superen 10MB"
        )
        automation_grid.addWidget(self.compress_check, 0, 1)

        # Segunda fila - Procesamiento
        self.backup_check = QCheckBox("üíæ Crear respaldo autom√°tico")
        self.backup_check.setToolTip("Crea una copia de respaldo con timestamp")
        automation_grid.addWidget(self.backup_check, 1, 0)

        self.convert_check = QCheckBox("üîÑ Convertir formato autom√°ticamente")
        self.convert_check.setToolTip(
            "Convierte formatos obsoletos a modernos (doc‚Üídocx, etc.)"
        )
        automation_grid.addWidget(self.convert_check, 1, 1)

        # Tercera fila - Metadatos e Im√°genes
        self.metadata_check = QCheckBox("üìä Extraer metadatos")
        self.metadata_check.setToolTip(
            "Extrae y guarda informaci√≥n del archivo en JSON"
        )
        automation_grid.addWidget(self.metadata_check, 2, 0)

        self.watermark_check = QCheckBox("üè∑Ô∏è Agregar marca de agua (im√°genes)")
        self.watermark_check.setToolTip("Agrega marca de agua a archivos de imagen")
        automation_grid.addWidget(self.watermark_check, 2, 1)

        # Cuarta fila - Optimizaci√≥n
        self.optimize_check = QCheckBox("üñºÔ∏è Optimizar im√°genes")
        self.optimize_check.setToolTip("Optimiza autom√°ticamente archivos de imagen")
        automation_grid.addWidget(self.optimize_check, 3, 0)

        self.encrypt_check = QCheckBox("üîí Encriptar archivo")
        self.encrypt_check.setToolTip("Encripta el archivo para mayor seguridad")
        automation_grid.addWidget(self.encrypt_check, 3, 1)

        # Quinta fila - Seguridad y Cloud
        self.virus_check = QCheckBox("üîç Escanear virus")
        self.virus_check.setToolTip("Escanear archivo en busca de amenazas")
        automation_grid.addWidget(self.virus_check, 4, 0)

        self.cloud_check = QCheckBox("‚òÅÔ∏è Preparar para sincronizaci√≥n")
        self.cloud_check.setToolTip(
            "Prepara archivo para sincronizaci√≥n con servicios en la nube"
        )
        automation_grid.addWidget(self.cloud_check, 4, 1)

        advanced_layout.addLayout(automation_grid)
        layout.addWidget(advanced_group)

        # --- Secci√≥n 5: Archivos y subcarpetas dentro de la carpeta (solo si es carpeta) ---
        if self.file_item.is_directory and hasattr(self, "folder_files"):
            files_group = QGroupBox("üìÅ Contenido Detectado en la Carpeta")
            files_layout = QVBoxLayout(files_group)

            total_items = len(self.folder_files) + len(self.folder_subfolders)
            files_info = QLabel(
                f"Se detectaron <b>{len(self.folder_files)}</b> archivos y <b>{len(self.folder_subfolders)}</b> subcarpetas dentro de esta carpeta.<br>"
                "Puedes configurar un patr√≥n de renombrado individual para cada elemento."
            )
            files_info.setWordWrap(True)
            files_info.setStyleSheet(
                "color: #aaa; font-size: 9pt; margin-bottom: 8px; background: #2a2a2a; padding: 8px; border-radius: 4px;"
            )
            files_layout.addWidget(files_info)

            # Scroll area para la lista de archivos
            files_scroll = QScrollArea()
            files_scroll.setWidgetResizable(True)
            files_scroll.setMaximumHeight(300)
            files_scroll.setStyleSheet("""
                QScrollArea {
                    background-color: #1a1a1a;
                    border: 1px solid #c0c0c0;
                    border-radius: 4px;
                }
            """)

            files_container = QWidget()
            files_container_layout = QVBoxLayout(files_container)
            files_container_layout.setSpacing(8)

            # Inicializar diccionario de patrones si no existe
            if self.file_item.folder_files_patterns is None:
                self.file_item.folder_files_patterns = {}

            self.file_pattern_inputs = {}

            for file_path in self.folder_files:
                file_name = os.path.basename(file_path)
                file_widget = QWidget()
                file_widget.setStyleSheet("""
                    QWidget {
                        background-color: #ffffff;
                        border-radius: 4px;
                        padding: 8px;
                    }
                """)
                file_layout = QVBoxLayout(file_widget)
                file_layout.setSpacing(4)

                # Nombre del archivo con icono
                file_icon = get_file_icon_by_extension(file_path, False)
                name_label = QLabel(f"{file_icon} <b>{file_name}</b>")
                name_label.setStyleSheet("color: #ffffff; font-size: 10pt;")
                file_layout.addWidget(name_label)

                # Campo de patr√≥n
                pattern_layout = QHBoxLayout()
                pattern_layout.addWidget(QLabel("Patr√≥n:"))

                pattern_input = QLineEdit()
                pattern_input.setPlaceholderText(
                    "Dejar vac√≠o para usar patr√≥n de la carpeta"
                )
                # Cargar patr√≥n guardado si existe
                if file_name in self.file_item.folder_files_patterns:
                    pattern_input.setText(
                        self.file_item.folder_files_patterns[file_name]
                    )

                pattern_input.setStyleSheet("""
                    QLineEdit {
                        background-color: #1a1a1a;
                        color: #ffffff;
                        border: 1px solid #c0c0c0;
                        border-radius: 3px;
                        padding: 4px;
                    }
                """)
                pattern_layout.addWidget(pattern_input, 1)

                # Bot√≥n para copiar patr√≥n de la carpeta
                copy_btn = QPushButton("üìã")
                copy_btn.setFixedWidth(30)
                copy_btn.setToolTip("Copiar patr√≥n de la carpeta")
                copy_btn.clicked.connect(
                    lambda checked, inp=pattern_input: inp.setText(
                        self.rename_input.text()
                    )
                )
                copy_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #3a3a3a;
                        border: none;
                        border-radius: 3px;
                        padding: 4px;
                    }
                    QPushButton:hover {
                        background-color: #4a4a4a;
                    }
                """)
                pattern_layout.addWidget(copy_btn)

                file_layout.addLayout(pattern_layout)

                # Guardar referencia al input
                self.file_pattern_inputs[file_name] = pattern_input

                files_container_layout.addWidget(file_widget)

            # Agregar subcarpetas si existen
            if hasattr(self, "folder_subfolders") and self.folder_subfolders:
                # Separador
                separator = QFrame()
                separator.setFrameShape(QFrame.Shape.HLine)
                separator.setStyleSheet("color: #555; margin: 10px 0;")
                files_container_layout.addWidget(separator)
                
                # T√≠tulo para subcarpetas
                subfolders_title = QLabel("üìÅ Subcarpetas Detectadas:")
                subfolders_title.setStyleSheet("color: #4a90e2; font-size: 11pt; font-weight: bold; margin: 10px 0 5px 0;")
                files_container_layout.addWidget(subfolders_title)
                
                # Inicializar diccionario de patrones para subcarpetas
                if self.file_item.folder_subfolders_patterns is None:
                    self.file_item.folder_subfolders_patterns = {}
                
                self.subfolder_pattern_inputs = {}
                
                for subfolder_path in self.folder_subfolders:
                    subfolder_name = os.path.basename(subfolder_path)
                    subfolder_widget = QWidget()
                    subfolder_widget.setStyleSheet("""
                        QWidget {
                            background-color: #ffffff;
                            border-radius: 4px;
                            padding: 8px;
                        }
                    """)
                    subfolder_layout = QVBoxLayout(subfolder_widget)
                    subfolder_layout.setSpacing(4)
                    
                    # Nombre de la subcarpeta con icono
                    name_label = QLabel(f"üìÅ <b>{subfolder_name}</b>")
                    name_label.setStyleSheet("color: #ffffff; font-size: 10pt;")
                    subfolder_layout.addWidget(name_label)
                    
                    # Input para patr√≥n de renombrado
                    pattern_layout = QHBoxLayout()
                    pattern_input = QLineEdit()
                    pattern_input.setPlaceholderText("Patr√≥n de renombrado para la subcarpeta...")
                    pattern_input.setStyleSheet("""
                        QLineEdit {
                            background-color: #3a3a3a;
                            border: 1px solid #555;
                            border-radius: 4px;
                            padding: 6px;
                            color: #ffffff;
                        }
                        QLineEdit:focus {
                            border-color: #4a90e2;
                        }
                    """)
                    
                    # Cargar patr√≥n existente si existe
                    if subfolder_name in self.file_item.folder_subfolders_patterns:
                        pattern_input.setText(self.file_item.folder_subfolders_patterns[subfolder_name])
                    
                    pattern_layout.addWidget(pattern_input, 1)
                    
                    # Bot√≥n para copiar patr√≥n de la carpeta
                    copy_btn = QPushButton("üìã")
                    copy_btn.setFixedWidth(30)
                    copy_btn.setToolTip("Copiar patr√≥n de la carpeta")
                    copy_btn.clicked.connect(
                        lambda checked, inp=pattern_input: inp.setText(
                            self.rename_input.text()
                        )
                    )
                    copy_btn.setStyleSheet("""
                        QPushButton {
                            background-color: #3a3a3a;
                            border: 1px solid #555;
                            border-radius: 4px;
                            color: #ffffff;
                            font-weight: bold;
                        }
                        QPushButton:hover {
                            background-color: #217346;
                        }
                    """)
                    pattern_layout.addWidget(copy_btn)
                    
                    subfolder_layout.addLayout(pattern_layout)
                    
                    # Guardar referencia al input
                    self.subfolder_pattern_inputs[subfolder_name] = pattern_input
                    
                    files_container_layout.addWidget(subfolder_widget)

            files_scroll.setWidget(files_container)
            files_layout.addWidget(files_scroll)

            layout.addWidget(files_group)

        # Botones
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        clear_btn = QPushButton("üóëÔ∏è Limpiar")
        clear_btn.clicked.connect(self.clear_all_rules)
        button_layout.addWidget(clear_btn)

        cancel_btn = QPushButton("‚ùå Cancelar")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)

        save_btn = QPushButton("üíæ Guardar")
        save_btn.clicked.connect(self.save_rules)
        save_btn.setDefault(True)
        button_layout.addWidget(save_btn)

        layout.addLayout(button_layout)

        # Configurar el scroll area
        scroll_area.setWidget(content_widget)
        main_layout.addWidget(scroll_area)

    def detect_folder_files(self):
        """Detectar archivos y subcarpetas dentro de una carpeta"""
        self.folder_files = []
        self.folder_subfolders = []
        try:
            if os.path.exists(self.file_item.path) and os.path.isdir(
                self.file_item.path
            ):
                # Listar archivos y subdirectorios
                for item in os.listdir(self.file_item.path):
                    item_path = os.path.join(self.file_item.path, item)
                    if os.path.isfile(item_path):
                        self.folder_files.append(item_path)
                    elif os.path.isdir(item_path):
                        self.folder_subfolders.append(item_path)

                # Ordenar por nombre
                self.folder_files.sort(key=lambda x: os.path.basename(x).lower())
                self.folder_subfolders.sort(key=lambda x: os.path.basename(x).lower())

                # Guardar en el item
                self.file_item.folder_files_detected = self.folder_files.copy()
                self.file_item.folder_subfolders_detected = self.folder_subfolders.copy()

                print(
                    f"‚úì Detectados {len(self.folder_files)} archivos y {len(self.folder_subfolders)} subcarpetas en '{self.file_item.name}'"
                )
        except Exception as e:
            print(f"Error detectando archivos en carpeta: {e}")
            self.folder_files = []
            self.folder_subfolders = []

    def setup_style(self):
        """Configurar estilos"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QScrollArea > QWidget > QWidget {
                background-color: transparent;
            }
            QScrollBar:vertical {
                background-color: #ffffff;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 6px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #357abd;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
            QScrollBar:horizontal {
                background-color: #ffffff;
                height: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:horizontal {
                background-color: #217346;
                border-radius: 6px;
                min-width: 20px;
            }
            QScrollBar::handle:horizontal:hover {
                background-color: #357abd;
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                width: 0px;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #3a3a3a;
                border-radius: 8px;
                margin-top: 12px;
                padding-top: 15px;
                color: #4a90e2;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 15px;
                padding: 0 5px;
            }
            QLabel {
                color: #cccccc;
            }
            QLineEdit {
                background-color: #ffffff;
                border: 1px solid #444;
                border-radius: 4px;
                padding: 8px;
                color: #ffffff;
                font-size: 10pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
            QCheckBox {
                color: #cccccc;
                spacing: 8px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #555;
                border-radius: 4px;
                background-color: #ffffff;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
                border-color: #4a90e2;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 5px;
                color: white;
                padding: 10px 20px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QPushButton:pressed {
                background-color: #2d5f8d;
            }
        """)

    def load_current_rules(self):
        """Cargar reglas actuales del archivo"""
        self.dest_input.setText(self.file_item.auto_destination or "")
        self.create_folder_check.setChecked(self.file_item.auto_create_folder)
        self.check_duplicates_check.setChecked(self.file_item.auto_check_duplicates)
        self.skip_if_exists_check.setChecked(self.file_item.auto_skip_if_exists)
        self.skip_repeat_paste_check.setChecked(self.file_item.auto_skip_on_repeat_paste)
        self.rename_input.setText(self.file_item.auto_rename_pattern or "")

        # Cargar nuevas automatizaciones avanzadas
        self.organize_check.setChecked(self.file_item.auto_organize_by_type)
        self.compress_check.setChecked(self.file_item.auto_compress_large_files)
        self.backup_check.setChecked(self.file_item.auto_backup)
        self.convert_check.setChecked(self.file_item.auto_convert_format)
        self.metadata_check.setChecked(self.file_item.auto_extract_metadata)
        self.watermark_check.setChecked(self.file_item.auto_watermark)
        self.optimize_check.setChecked(self.file_item.auto_optimize_images)
        self.encrypt_check.setChecked(self.file_item.auto_encrypt)
        self.virus_check.setChecked(self.file_item.auto_scan_virus)
        self.cloud_check.setChecked(self.file_item.auto_cloud_sync)

        self.update_rename_preview()

    def create_pattern_button(self, text: str, pattern: str) -> QPushButton:
        """Crear bot√≥n de patr√≥n predefinido"""
        button = QPushButton(text)
        button.setToolTip(f"Patr√≥n: {pattern}")
        button.setStyleSheet("""
            QPushButton {
                background-color: #3a3a3a;
                border: 1px solid #555;
                border-radius: 4px;
                padding: 6px 8px;
                color: #ffffff;
                font-size: 9pt;
                text-align: left;
            }
            QPushButton:hover {
                background-color: #217346;
                border-color: #4a90e2;
            }
            QPushButton:pressed {
                background-color: #357abd;
            }
        """)
        button.clicked.connect(lambda: self.apply_pattern(pattern))
        return button

    def apply_pattern(self, pattern: str):
        """Aplicar patr√≥n predefinido al campo de entrada"""
        self.rename_input.setText(pattern)
        self.update_rename_preview()

    def browse_destination(self):
        """Examinar carpeta de destino"""
        folder = QFileDialog.getExistingDirectory(
            self, "Seleccionar Carpeta de Destino", os.path.expanduser("~")
        )
        if folder:
            folder = normalize_network_path(folder)
            self.dest_input.setText(folder)

    def update_rename_preview(self):
        """Actualizar vista previa del renombrado con todas las nuevas variables"""
        pattern = self.rename_input.text().strip()
        if not pattern:
            self.rename_preview.setText("Vista previa: (sin cambios)")
            return

        from datetime import datetime, timedelta
        import random
        import re

        # Datos de ejemplo para la vista previa
        example_folder = "Carpeta_Ejemplo"
        example_parent = "Proyectos_Activos"
        example_client = "Cliente_ABC"
        example_file = "documento_existente.txt"

        # Separar nombre y extensi√≥n del archivo actual
        name_no_ext, ext = os.path.splitext(self.file_item.name)

        preview = pattern
        now = datetime.now()

        # ARCHIVO
        preview = preview.replace("{original}", self.file_item.name)
        preview = preview.replace("{name}", name_no_ext)
        preview = preview.replace("{ext}", ext)

        # {name:N} y {name:N:M}
        name_slice_pattern = r"\{name:(\d+)(?::(\d+))?\}"
        for match in re.finditer(name_slice_pattern, preview):
            start = int(match.group(1))
            end = int(match.group(2)) if match.group(2) else None
            if end:
                sliced = (
                    name_no_ext[start:end] if len(name_no_ext) > start else name_no_ext
                )
            else:
                sliced = name_no_ext[:start]
            preview = preview.replace(match.group(0), sliced)

        # CARPETA
        preview = preview.replace("{folder_name}", example_folder)
        preview = preview.replace("{parent_folder}", example_parent)
        preview = preview.replace("{client}", example_client)
        preview = preview.replace("{file:0}", example_file.replace(".txt", ""))
        preview = preview.replace("{file:1}", "segundo_archivo")

        # Carpetas ancestros con niveles
        folder_parent_pattern = r"\{folder_parent:(\d+)\}"
        for match in re.finditer(folder_parent_pattern, preview):
            level = int(match.group(1))
            if level == 0:
                preview = preview.replace(match.group(0), example_folder)
            elif level == 1:
                preview = preview.replace(match.group(0), example_parent)
            elif level == 2:
                preview = preview.replace(match.group(0), "Documentos")
            else:
                preview = preview.replace(match.group(0), f"Nivel{level}")

        # B√∫squeda por prefijo (ejemplo con PV)
        folder_prefix_pattern = r"\{folder_prefix:([^}]+)\}"
        for match in re.finditer(folder_prefix_pattern, preview):
            prefix = match.group(1)
            preview = preview.replace(match.group(0), f"{prefix}12345-NombreProyecto")

        # B√∫squeda por contenido
        folder_contains_pattern = r"\{folder_contains:([^}]+)\}"
        for match in re.finditer(folder_contains_pattern, preview):
            text = match.group(1)
            preview = preview.replace(match.group(0), f"Carpeta_{text}_Ejemplo")

        # FECHA
        preview = preview.replace("{date}", now.strftime("%Y-%m-%d"))
        preview = preview.replace("{date_short}", now.strftime("%Y%m%d"))
        preview = preview.replace("{year}", now.strftime("%Y"))
        preview = preview.replace("{month}", now.strftime("%m"))
        preview = preview.replace("{day}", now.strftime("%d"))

        # HORA
        preview = preview.replace("{time}", now.strftime("%H-%M-%S"))
        preview = preview.replace("{time_short}", now.strftime("%H%M%S"))
        preview = preview.replace("{hour}", now.strftime("%H"))
        preview = preview.replace("{minute}", now.strftime("%M"))
        preview = preview.replace("{second}", now.strftime("%S"))
        preview = preview.replace("{timestamp}", str(int(now.timestamp())))

        # CONTADORES
        preview = preview.replace("{counter}", "1")
        preview = preview.replace("{counter:3}", "001")
        preview = preview.replace("{counter:4}", "0001")

        # ALEATORIOS
        if "{random}" in preview:
            preview = preview.replace("{random}", "5738")
        random_pattern = r"\{random:(\d+)\}"
        for match in re.finditer(random_pattern, preview):
            digits = int(match.group(1))
            example_random = "".join(str(random.randint(0, 9)) for _ in range(digits))
            preview = preview.replace(match.group(0), example_random)

        # TRANSFORMACIONES
        upper_pattern = r"\{upper:([^}]+)\}"
        for match in re.finditer(upper_pattern, preview):
            text = match.group(1)
            preview = preview.replace(match.group(0), text.upper())

        lower_pattern = r"\{lower:([^}]+)\}"
        for match in re.finditer(lower_pattern, preview):
            text = match.group(1)
            preview = preview.replace(match.group(0), text.lower())

        title_pattern = r"\{title:([^}]+)\}"
        for match in re.finditer(title_pattern, preview):
            text = match.group(1)
            preview = preview.replace(match.group(0), text.title())

        self.rename_preview.setText(f"Vista previa: <b>{preview}</b>")

    def show_rename_help(self):
        """Mostrar ayuda completa sobre renombrado"""
        help_dialog = QDialog(self)
        help_dialog.setWindowTitle("üè∑Ô∏è Gu√≠a Completa de Variables de Renombrado")
        help_dialog.setMinimumSize(700, 600)

        layout = QVBoxLayout(help_dialog)

        # Crear √°rea de scroll para el contenido
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)

        help_text = QLabel(
            "<h2>üìÅ ARCHIVO</h2>"
            "<b><code>{original}</code></b> - Nombre original completo con extensi√≥n<br>"
            "<b><code>{name}</code></b> - Nombre sin extensi√≥n<br>"
            "<b><code>{ext}</code></b> - Solo la extensi√≥n (con punto)<br>"
            "<b><code>{name:5}</code></b> - Primeros 5 caracteres del nombre<br>"
            "<b><code>{name:0:10}</code></b> - Caracteres del 0 al 10<br>"
            "<br><hr><br>"
            "<h2>üìÇ CARPETA</h2>"
            "<p style='color: #4CAF50; font-weight: bold;'>‚ú® Los espacios se reemplazan autom√°ticamente por \"_\"</p>"
            "<b><code>{folder_name}</code></b> - Nombre de la carpeta destino<br>"
            "<b><code>{parent_folder}</code></b> - Carpeta padre directa<br>"
            "<b><code>{client}</code></b> - Carpeta 2 niveles arriba (carpeta del cliente)<br>"
            "<b><code>{folder_parent:0}</code></b> - Carpeta actual (nivel 0)<br>"
            "<b><code>{folder_parent:1}</code></b> - Carpeta padre (nivel 1)<br>"
            "<b><code>{folder_parent:2}</code></b> - Carpeta abuelo (nivel 2)<br>"
            "<b><code>{folder_prefix:PV}</code></b> - Busca carpeta ancestro que empiece con 'PV'<br>"
            "<b><code>{folder_contains:texto}</code></b> - Busca carpeta ancestro que contenga 'texto'<br>"
            "<b><code>{file:0}</code></b> - Primer archivo existente en la carpeta<br>"
            "<b><code>{file:1}</code></b> - Segundo archivo existente<br>"
            "<i>Nota: {file:0} hasta {file:19} | B√∫squeda ancestros hasta 10 niveles</i><br>"
            "<br>"
            "<p style='background: #2a2a2a; padding: 8px; border-left: 3px solid #4CAF50;'>"
            '<b>Ejemplo:</b> Si la carpeta es "PV 12345 Cliente" ‚Üí se convierte en "PV_12345_Cliente"</p>'
            "<br><hr><br>"
            "<h2>üìÖ FECHA</h2>"
            "<b><code>{date}</code></b> - Fecha completa (2024-01-15)<br>"
            "<b><code>{date_short}</code></b> - Fecha sin guiones (20240115)<br>"
            "<b><code>{year}</code></b> - A√±o (2024)<br>"
            "<b><code>{month}</code></b> - Mes (01)<br>"
            "<b><code>{day}</code></b> - D√≠a (15)<br>"
            "<br><hr><br>"
            "<h2>üïê HORA</h2>"
            "<b><code>{time}</code></b> - Hora completa (14-30-45)<br>"
            "<b><code>{time_short}</code></b> - Hora sin guiones (143045)<br>"
            "<b><code>{hour}</code></b> - Hora (14)<br>"
            "<b><code>{minute}</code></b> - Minuto (30)<br>"
            "<b><code>{second}</code></b> - Segundo (45)<br>"
            "<b><code>{timestamp}</code></b> - Unix timestamp (1705328445)<br>"
            "<br><hr><br>"
            "<h2>üî¢ CONTADORES</h2>"
            "<b><code>{counter}</code></b> - Contador autom√°tico (1, 2, 3...)<br>"
            "<b><code>{counter:3}</code></b> - Contador con relleno (001, 002, 003...)<br>"
            "<b><code>{random}</code></b> - N√∫mero aleatorio de 4 d√≠gitos<br>"
            "<b><code>{random:6}</code></b> - N√∫mero aleatorio de 6 d√≠gitos<br>"
            "<b><code>{uuid}</code></b> - UUID √∫nico (a1b2c3d4-e5f6-7890-abcd-ef1234567890)<br>"
            "<b><code>{uuid_short}</code></b> - UUID corto (a1b2c3d4)<br>"
            "<b><code>{hash}</code></b> - Hash MD5 del nombre original<br>"
            "<b><code>{hash_short}</code></b> - Primeros 8 caracteres del hash<br>"
            "<br><hr><br>"
            "<h2>üî§ TRANSFORMACIONES</h2>"
            "<b><code>{upper:texto}</code></b> - CONVIERTE A MAY√öSCULAS<br>"
            "<b><code>{lower:TEXTO}</code></b> - convierte a min√∫sculas<br>"
            "<b><code>{title:texto}</code></b> - Convierte A T√≠tulo<br>"
            "<b><code>{camel:texto}</code></b> - ConvierteACamelCase<br>"
            "<b><code>{snake:texto}</code></b> - convierte_a_snake_case<br>"
            "<b><code>{kebab:texto}</code></b> - convierte-a-kebab-case<br>"
            "<b><code>{reverse:texto}</code></b> - otxeT (invierte texto)<br>"
            "<b><code>{clean:texto}</code></b> - Limpia caracteres especiales<br>"
            "<b><code>{slug:texto}</code></b> - convierte-a-slug-url-friendly<br>"
            "<br><hr><br>"
            "<h2>üìä INFORMACI√ìN DEL SISTEMA</h2>"
            "<b><code>{user}</code></b> - Nombre del usuario actual<br>"
            "<b><code>{computer}</code></b> - Nombre del equipo<br>"
            "<b><code>{os}</code></b> - Sistema operativo (Windows, Linux, macOS)<br>"
            "<b><code>{version}</code></b> - Versi√≥n de la aplicaci√≥n<br>"
            "<b><code>{size}</code></b> - Tama√±o del archivo en bytes<br>"
            "<b><code>{size_kb}</code></b> - Tama√±o en KB<br>"
            "<b><code>{size_mb}</code></b> - Tama√±o en MB<br>"
            "<b><code>{size_human}</code></b> - Tama√±o legible (1.5 MB)<br>"
            "<br><hr><br>"
            "<h2>üéØ PATRONES AVANZADOS</h2>"
            "<b><code>{match:patr√≥n}</code></b> - Extrae texto que coincida con patr√≥n<br>"
            "<b><code>{replace:buscar|reemplazar}</code></b> - Reemplaza texto<br>"
            "<b><code>{substr:inicio:fin}</code></b> - Subcadena desde inicio hasta fin<br>"
            "<b><code>{pad:5:0}</code></b> - Rellena con ceros hasta 5 caracteres<br>"
            "<b><code>{trim:texto}</code></b> - Elimina espacios al inicio y final<br>"
            "<b><code>{repeat:3}</code></b> - Repite el texto 3 veces<br>"
            "<br><hr><br>"
            "<h2>üí° EJEMPLOS PR√ÅCTICOS</h2>"
            "<b>Ejemplo 1:</b> <code>{date}_{name}{ext}</code><br>"
            "‚Üí <i>2024-01-15_documento.pdf</i><br><br>"
            "<b>Ejemplo 2:</b> <code>{folder_name}_{counter:3}{ext}</code><br>"
            "‚Üí <i>MiCarpeta_001.xlsx</i><br><br>"
            "<b>Ejemplo 3:</b> <code>{upper:{name}}_backup{ext}</code><br>"
            "‚Üí <i>DOCUMENTO_backup.docx</i><br><br>"
            "<b>Ejemplo 4:</b> <code>{year}{month}{day}_{time_short}_{name:10}{ext}</code><br>"
            "‚Üí <i>20240115_143045_documento.pdf</i><br><br>"
            "<b>Ejemplo 5:</b> <code>Copia_de_{file:0}_{random:4}{ext}</code><br>"
            "‚Üí <i>Copia_de_original_7384.txt</i><br><br>"
            "<b>Ejemplo 6:</b> <code>{parent_folder}_{folder_name}_{name}{ext}</code><br>"
            "‚Üí <i>Proyectos_2024_informe.pdf</i><br><br>"
            "<b>Ejemplo 7:</b> <code>{folder_prefix:PV}_{name}{ext}</code><br>"
            "‚Üí <i>PV_12345_Proyecto_Cliente_documento.pdf</i><br>"
            "<i>Busca hacia arriba hasta encontrar carpeta que empiece con 'PV'</i><br><br>"
            "<b>Ejemplo 8:</b> <code>{folder_parent:2}_{date}_{name:10}{ext}</code><br>"
            "‚Üí <i>Mis_Documentos_2024-01-15_documento_.pdf</i><br>"
            '<i>Usa la carpeta 2 niveles arriba (abuelo), espacios ‚Üí "_"</i><br><br>'
            "<b>Ejemplo 9:</b> <code>{folder_contains:proyecto}_{counter:3}{ext}</code><br>"
            "‚Üí <i>Mi_Proyecto_2024_001.xlsx</i><br>"
            "<i>Busca carpeta ancestro que contenga 'proyecto', espacios ‚Üí \"_\"</i><br><br>"
            "<b>Ejemplo 10:</b> <code>{client}_{folder_prefix:PV}_{name}{ext}</code><br>"
            "‚Üí <i>Cliente_ABC_S.A._PV_12345_documento.pdf</i><br>"
            '<i>Combina nombre del cliente con proyecto PV, espacios ‚Üí "_"</i><br><br>'
            "<b>Ejemplo 11:</b> <code>{client}_{date}_{counter:3}{ext}</code><br>"
            "‚Üí <i>Cliente_XYZ_Ltda_2024-01-15_001.docx</i><br>"
            '<i>Cliente + fecha + contador, espacios ‚Üí "_"</i><br><br>'
            "<b>Ejemplo 12:</b> <code>{uuid_short}_{name}{ext}</code><br>"
            "‚Üí <i>a1b2c3d4_documento.pdf</i><br>"
            "<i>UUID corto + nombre original</i><br><br>"
            "<b>Ejemplo 13:</b> <code>{snake:{folder_name}}_{date}{ext}</code><br>"
            "‚Üí <i>mi_proyecto_2024_2024-01-15.pdf</i><br>"
            "<i>Nombre de carpeta en snake_case + fecha</i><br><br>"
            "<b>Ejemplo 14:</b> <code>{user}_{computer}_{timestamp}{ext}</code><br>"
            "‚Üí <i>usuario_PC-OFICINA_1705328445.docx</i><br>"
            "<i>Usuario + computadora + timestamp √∫nico</i><br><br>"
            "<b>Ejemplo 15:</b> <code>{size_human}_{name}{ext}</code><br>"
            "‚Üí <i>1.5_MB_documento.pdf</i><br>"
            "<i>Tama√±o legible + nombre original</i><br><br>"
            "<b>Ejemplo 16:</b> <code>{kebab:{folder_name}}_{hash_short}{ext}</code><br>"
            "‚Üí <i>mi-proyecto-2024_a1b2c3d4.xlsx</i><br>"
            "<i>Nombre de carpeta en kebab-case + hash corto</i><br><br>"
            "<b>Ejemplo 17:</b> <code>{replace:{name}|_|-}_{date}{ext}</code><br>"
            "‚Üí <i>documento-importante_2024-01-15.pdf</i><br>"
            "<i>Reemplaza guiones bajos por guiones + fecha</i><br><br>"
            "<b>Ejemplo 18:</b> <code>{upper:{folder_name}}_{counter:4}{ext}</code><br>"
            "‚Üí <i>MI_PROYECTO_0001.docx</i><br>"
            "<i>Nombre de carpeta en may√∫sculas + contador con relleno</i><br><br>"
            "<b>Ejemplo 19:</b> <code>{clean:{folder_name}}_{os}_{user}{ext}</code><br>"
            "‚Üí <i>Proyecto2024_Windows_usuario.pdf</i><br>"
            "<i>Nombre limpio + sistema operativo + usuario</i><br><br>"
            "<b>Ejemplo 20:</b> <code>{slug:{folder_name}}_{year}_{month}_{day}{ext}</code><br>"
            "‚Üí <i>mi-proyecto-importante_2024_01_15.xlsx</i><br>"
            "<i>Nombre en formato slug + fecha separada</i><br>"
        )

        help_text.setWordWrap(True)
        help_text.setTextFormat(Qt.TextFormat.RichText)
        help_text.setStyleSheet("padding: 15px; background: #1a1a1a; color: #fff;")
        scroll_layout.addWidget(help_text)

        scroll.setWidget(scroll_content)
        layout.addWidget(scroll)

        # Bot√≥n cerrar
        close_btn = QPushButton("Cerrar")
        close_btn.clicked.connect(help_dialog.accept)
        layout.addWidget(close_btn)

        help_dialog.setStyleSheet("""
            QDialog { background-color: #ffffff; color: #fff; }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 5px;
                color: white;
                padding: 10px 20px;
                font-weight: bold;
            }
            QPushButton:hover { background-color: #357abd; }
            QScrollArea { border: none; background: transparent; }
        """)

        help_dialog.exec()

    def clear_all_rules(self):
        """Limpiar todas las reglas"""
        self.dest_input.clear()
        self.create_folder_check.setChecked(True)
        self.check_duplicates_check.setChecked(True)
        self.skip_if_exists_check.setChecked(True)
        self.skip_repeat_paste_check.setChecked(True)
        self.rename_input.clear()

        # Limpiar nuevas automatizaciones avanzadas
        self.organize_check.setChecked(False)
        self.compress_check.setChecked(False)
        self.backup_check.setChecked(False)
        self.convert_check.setChecked(False)
        self.metadata_check.setChecked(False)
        self.watermark_check.setChecked(False)
        self.optimize_check.setChecked(False)
        self.encrypt_check.setChecked(False)
        self.virus_check.setChecked(False)
        self.cloud_check.setChecked(False)

        # Limpiar patrones de archivos y subcarpetas
        if hasattr(self, "file_pattern_inputs"):
            for pattern_input in self.file_pattern_inputs.values():
                pattern_input.clear()
        
        if hasattr(self, "subfolder_pattern_inputs"):
            for pattern_input in self.subfolder_pattern_inputs.values():
                pattern_input.clear()

        self.update_rename_preview()

    def save_rules(self):
        """Guardar reglas en el archivo"""
        self.file_item.auto_destination = self.dest_input.text().strip()
        self.file_item.auto_create_folder = self.create_folder_check.isChecked()
        self.file_item.auto_check_duplicates = self.check_duplicates_check.isChecked()
        self.file_item.auto_skip_if_exists = self.skip_if_exists_check.isChecked()
        self.file_item.auto_skip_on_repeat_paste = self.skip_repeat_paste_check.isChecked()
        self.file_item.auto_rename_pattern = self.rename_input.text().strip()

        # Guardar nuevas automatizaciones avanzadas
        self.file_item.auto_organize_by_type = self.organize_check.isChecked()
        self.file_item.auto_compress_large_files = self.compress_check.isChecked()
        self.file_item.auto_backup = self.backup_check.isChecked()
        self.file_item.auto_convert_format = self.convert_check.isChecked()
        self.file_item.auto_extract_metadata = self.metadata_check.isChecked()
        self.file_item.auto_watermark = self.watermark_check.isChecked()
        self.file_item.auto_optimize_images = self.optimize_check.isChecked()
        self.file_item.auto_encrypt = self.encrypt_check.isChecked()
        self.file_item.auto_scan_virus = self.virus_check.isChecked()
        self.file_item.auto_cloud_sync = self.cloud_check.isChecked()

        # Guardar patrones de archivos dentro de carpetas
        if self.file_item.is_directory and hasattr(self, "file_pattern_inputs"):
            self.file_item.folder_files_patterns = {}
            for file_name, pattern_input in self.file_pattern_inputs.items():
                pattern = pattern_input.text().strip()
                if pattern:  # Solo guardar si hay un patr√≥n
                    self.file_item.folder_files_patterns[file_name] = pattern

            print(
                f"‚úì Guardados patrones para {len(self.file_item.folder_files_patterns)} archivos internos"
            )
        
        # Guardar patrones de subcarpetas
        if self.file_item.is_directory and hasattr(self, "subfolder_pattern_inputs"):
            self.file_item.folder_subfolders_patterns = {}
            for subfolder_name, pattern_input in self.subfolder_pattern_inputs.items():
                pattern = pattern_input.text().strip()
                if pattern:  # Solo guardar si hay un patr√≥n
                    self.file_item.folder_subfolders_patterns[subfolder_name] = pattern

            print(
                f"‚úì Guardados patrones para {len(self.file_item.folder_subfolders_patterns)} subcarpetas"
            )

        message = f"Reglas guardadas para <b>{self.file_item.name}</b>"
        if self.file_item.is_directory and hasattr(self, "folder_files"):
            message += f"<br>Incluyendo {len(self.folder_files)} archivos detectados"

        QMessageBox.information(self, "‚úÖ Guardado", message)

        self.accept()


class CopyToFolderDialog(QDialog):
    """Di√°logo para copiar archivos seleccionados a una carpeta destino"""

    def __init__(self, selected_items, parent=None):
        super().__init__(parent)
        self.selected_items = selected_items
        self.setWindowTitle("üìã Copiar a Carpeta Destino")
        set_window_icon(self)
        self.setMinimumSize(600, 400)
        self.resize(700, 500)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        # Restaurar geometr√≠a
        self.geometry_manager.restore_window_geometry(
            self, "copy_to_folder", (700, 500)
        )

    def setup_ui(self):
        """Configurar la interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel("üìÇ Seleccionar Carpeta Destino y Configuraci√≥n")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Informaci√≥n de elementos a copiar
        info_label = QLabel(f"Se copiar√°n {len(self.selected_items)} elementos:")
        info_label.setStyleSheet("color: #cccccc; font-weight: bold;")
        layout.addWidget(info_label)

        # Lista de elementos
        self.items_list = QListWidget()
        self.items_list.setMaximumHeight(100)
        for item in self.selected_items:
            icon = get_file_icon_by_extension(item.path, item.is_directory)
            self.items_list.addItem(f"{icon} {item.name}")
        layout.addWidget(self.items_list)

        # Selecci√≥n de carpeta destino
        folder_group = QGroupBox("üìÇ Carpeta Destino")
        folder_layout = QVBoxLayout(folder_group)

        # Campo de ruta destino
        path_layout = QHBoxLayout()
        self.destination_path = QLineEdit()
        self.destination_path.setPlaceholderText(
            "Selecciona la carpeta donde copiar los archivos..."
        )
        self.destination_path.setReadOnly(True)

        self.browse_btn = QPushButton("üîç Examinar")
        self.browse_btn.clicked.connect(self.browse_destination)
        self.browse_btn.setFixedWidth(100)

        path_layout.addWidget(self.destination_path)
        path_layout.addWidget(self.browse_btn)
        folder_layout.addLayout(path_layout)

        layout.addWidget(folder_group)

        # Configuraci√≥n de carpeta
        config_group = QGroupBox("‚öôÔ∏è Configuraci√≥n de Copia")
        config_layout = QGridLayout(config_group)

        # Nombre de carpeta personalizada
        config_layout.addWidget(QLabel("Nombre de carpeta:"), 0, 0)
        self.folder_name = QLineEdit()
        self.folder_name.setPlaceholderText(
            "Opcional: nombre personalizado para nueva carpeta"
        )
        config_layout.addWidget(self.folder_name, 0, 1)

        # Opciones de copia
        self.create_subfolder_check = QCheckBox(
            "Crear subcarpeta con el nombre especificado"
        )
        self.create_subfolder_check.setChecked(True)
        config_layout.addWidget(self.create_subfolder_check, 1, 0, 1, 2)

        self.overwrite_check = QCheckBox("Sobrescribir archivos existentes")
        config_layout.addWidget(self.overwrite_check, 2, 0, 1, 2)

        self.keep_structure_check = QCheckBox("Mantener estructura de carpetas")
        self.keep_structure_check.setChecked(True)
        config_layout.addWidget(self.keep_structure_check, 3, 0, 1, 2)

        layout.addWidget(config_group)

        # Barra de progreso
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)

        # Etiqueta de estado
        self.status_label = QLabel("Selecciona una carpeta destino para continuar")
        self.status_label.setStyleSheet("color: #888888; font-style: italic;")
        layout.addWidget(self.status_label)

        # Botones de acci√≥n
        buttons_layout = QHBoxLayout()

        self.copy_btn = QPushButton("üìã Copiar Archivos")
        self.copy_btn.setEnabled(False)
        self.copy_btn.clicked.connect(self.start_copy_process)

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.copy_btn)
        buttons_layout.addWidget(self.cancel_btn)

        layout.addLayout(buttons_layout)

        # Conexiones
        self.destination_path.textChanged.connect(self.validate_inputs)
        self.folder_name.textChanged.connect(self.validate_inputs)
        self.create_subfolder_check.toggled.connect(self.validate_inputs)

    def setup_style(self):
        """Configurar el estilo del di√°logo"""
        self.setStyleSheet(
            self.theme_manager.get_stylesheet("dialog")
            + """
            QListWidget {
                background-color: #ffffff;
                border: 1px solid #555555;
                border-radius: 4px;
                color: #ffffff;
                alternate-background-color: #3a3a3a;
            }
            QCheckBox {
                color: #ffffff;
                spacing: 8px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
            QCheckBox::indicator:unchecked {
                background-color: #ffffff;
                border: 2px solid #555555;
                border-radius: 3px;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
                border: 2px solid #4a90e2;
                border-radius: 3px;
            }
            QProgressBar {
                border: 2px solid #555555;
                border-radius: 5px;
                text-align: center;
                font-weight: bold;
            }
            QProgressBar::chunk {
                background-color: #28a745;
                border-radius: 3px;
            }
        """
        )

    def browse_destination(self):
        """Abrir di√°logo para seleccionar carpeta destino"""
        folder_path = QFileDialog.getExistingDirectory(
            self, "Seleccionar Carpeta Destino", os.path.expanduser("~")
        )

        if folder_path:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            folder_path = normalize_network_path(folder_path)
            self.destination_path.setText(folder_path)
            self.status_label.setText(f"Carpeta seleccionada: {folder_path}")

    def validate_inputs(self):
        """Validar entradas y habilitar bot√≥n de copia"""
        has_destination = bool(self.destination_path.text().strip())

        if self.create_subfolder_check.isChecked():
            has_folder_name = bool(self.folder_name.text().strip())
            self.copy_btn.setEnabled(has_destination and has_folder_name)

            if has_destination and not has_folder_name:
                self.status_label.setText("Ingresa un nombre para la subcarpeta")
            elif has_destination and has_folder_name:
                self.status_label.setText("Listo para copiar")
        else:
            self.copy_btn.setEnabled(has_destination)
            if has_destination:
                self.status_label.setText("Listo para copiar")

    def start_copy_process(self):
        """Iniciar el proceso de copia"""
        try:
            destination_base = self.destination_path.text().strip()

            # Verificar que se haya seleccionado una carpeta destino v√°lida
            if not destination_base or not os.path.exists(destination_base):
                QMessageBox.warning(
                    self, "Error", "Por favor selecciona una carpeta destino v√°lida."
                )
                return

            # Determinar carpeta final
            if self.create_subfolder_check.isChecked():
                folder_name = self.folder_name.text().strip()
                if not folder_name:
                    QMessageBox.warning(
                        self, "Error", "Por favor ingresa un nombre para la subcarpeta."
                    )
                    return

                final_destination = os.path.join(destination_base, folder_name)

                # Crear carpeta si no existe
                try:
                    if not os.path.exists(final_destination):
                        os.makedirs(final_destination)
                        self.status_label.setText(f"Carpeta creada: {folder_name}")
                    elif not self.overwrite_check.isChecked():
                        # Verificar si queremos continuar con carpeta existente
                        result = QMessageBox.question(
                            self,
                            "Carpeta Existe",
                            f"La carpeta '{folder_name}' ya existe.\n¬øDeseas continuar copiando archivos all√≠?",
                            QMessageBox.StandardButton.Yes
                            | QMessageBox.StandardButton.No,
                        )
                        if result == QMessageBox.StandardButton.No:
                            return
                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"No se pudo crear la carpeta '{folder_name}':\n{str(e)}",
                    )
                    return
            else:
                final_destination = destination_base

            # Verificar permisos de escritura
            if not os.access(final_destination, os.W_OK):
                QMessageBox.critical(
                    self,
                    "Error de Permisos",
                    f"No tienes permisos de escritura en:\n{final_destination}",
                )
                return

            # Iniciar proceso de copia
            self.copy_files_to_destination(final_destination)

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error durante la copia:\n{str(e)}")

    def copy_files_to_destination(self, destination):
        """Copiar archivos a la carpeta destino"""
        self.progress_bar.setVisible(True)
        self.progress_bar.setMaximum(len(self.selected_items))
        self.copy_btn.setEnabled(False)

        copied_files = []
        errors = []

        for i, item in enumerate(self.selected_items):
            try:
                source_path = item.path
                item_name = os.path.basename(source_path)

                # Verificar que el archivo origen existe
                if not os.path.exists(source_path):
                    errors.append(f"{item_name}: Archivo origen no existe")
                    continue

                dest_path = os.path.join(destination, item_name)

                # Debug: mostrar rutas
                self.status_label.setText(f"Copiando {item_name}...")

                # Manejar archivos existentes
                if os.path.exists(dest_path) and not self.overwrite_check.isChecked():
                    # Crear nombre √∫nico
                    base_name, ext = os.path.splitext(item_name)
                    counter = 1
                    original_dest = dest_path
                    while os.path.exists(dest_path):
                        if item.is_directory:
                            new_name = f"{base_name} - Copia ({counter})"
                        else:
                            new_name = f"{base_name} - Copia ({counter}){ext}"
                        dest_path = os.path.join(destination, new_name)
                        counter += 1

                # Copiar archivo o carpeta
                import shutil

                if item.is_directory:
                    if os.path.exists(dest_path) and self.overwrite_check.isChecked():
                        shutil.rmtree(dest_path)
                    shutil.copytree(source_path, dest_path)
                else:
                    # Para archivos, usar copy2 que preserva metadatos
                    shutil.copy2(source_path, dest_path)

                copied_files.append(dest_path)

                # Verificar que el archivo se copi√≥ correctamente
                if os.path.exists(dest_path):
                    self.status_label.setText(f"‚úÖ Copiado: {item_name}")
                else:
                    errors.append(
                        f"{item_name}: La copia fall√≥ - archivo destino no existe"
                    )

            except Exception as e:
                errors.append(f"{item_name}: {str(e)}")

            self.progress_bar.setValue(i + 1)
            # Peque√±a pausa para actualizar UI
            QApplication.processEvents()

        # Mostrar resultado
        if copied_files:
            if errors:
                QMessageBox.warning(
                    self,
                    "Copia Completada con Errores",
                    f"‚úÖ {len(copied_files)} archivos copiados exitosamente.\n"
                    f"‚ùå {len(errors)} errores:\n\n" + "\n".join(errors[:5]),
                )
            else:
                QMessageBox.information(
                    self,
                    "Copia Exitosa",
                    f"‚úÖ Todos los archivos ({len(copied_files)}) fueron copiados exitosamente a:\n"
                    f"üìÅ {destination}\n\nLos archivos han sido copiados f√≠sicamente a la ubicaci√≥n seleccionada.",
                )
            self.accept()
        else:
            if errors:
                QMessageBox.critical(
                    self,
                    "Error de Copia",
                    f"‚ùå No se pudo copiar ning√∫n archivo.\n\nErrores:\n"
                    + "\n".join(errors[:3]),
                )
            else:
                QMessageBox.critical(
                    self, "Error de Copia", "‚ùå No se pudo copiar ning√∫n archivo."
                )

        self.copy_btn.setEnabled(True)
        self.progress_bar.setVisible(False)

    def closeEvent(self, event):
        """Guardar geometr√≠a al cerrar"""
        self.geometry_manager.save_window_geometry("copy_to_folder", self.geometry())
        super().closeEvent(event)


class PasteSelectionDialog(QDialog):
    """Di√°logo para seleccionar elementos espec√≠ficos del clipboard m√∫ltiple"""

    def __init__(self, clipboard_items, parent=None):
        super().__init__(parent)
        self.clipboard_items = clipboard_items
        self.selected_items = []
        self.setWindowTitle("üìã Seleccionar Elementos para Pegar")
        set_window_icon(self)
        self.setMinimumSize(600, 400)
        self.resize(800, 600)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        self.restore_geometry()

    def setup_ui(self):
        """Configurar la interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel("üìã Clipboard M√∫ltiple - Seleccionar Elementos")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Informaci√≥n
        info_label = QLabel(
            f"Tienes {len(self.clipboard_items)} elementos en el clipboard. Selecciona cu√°les pegar:"
        )
        info_label.setStyleSheet(
            "color: #cccccc; font-weight: bold; margin-bottom: 5px;"
        )
        layout.addWidget(info_label)

        # Lista de elementos con checkboxes
        self.items_tree = QTreeWidget()
        self.items_tree.setHeaderLabels(
            ["", "Nombre", "Tipo", "Tama√±o", "Modificado", "Agregado"]
        )
        self.items_tree.setRootIsDecorated(False)
        self.items_tree.setAlternatingRowColors(True)

        # Poblar lista
        for item in self.clipboard_items:
            tree_item = QTreeWidgetItem()

            # Checkbox
            tree_item.setFlags(tree_item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            tree_item.setCheckState(0, Qt.CheckState.Checked)  # Seleccionar por defecto

            # Icono y nombre
            icon = "üìÅ" if item["is_directory"] else "üìÑ"
            tree_item.setText(1, f"{icon} {item['name']}")

            # Tipo
            tree_item.setText(2, "Carpeta" if item["is_directory"] else "Archivo")

            # Tama√±o
            if item.get("size"):
                size_mb = item["size"] / (1024 * 1024)
                tree_item.setText(3, f"{size_mb:.1f} MB")
            else:
                tree_item.setText(3, "N/A")

            # Fecha modificaci√≥n
            tree_item.setText(4, item.get("modified", "N/A"))

            # Hora agregado al clipboard
            tree_item.setText(5, item.get("added_time", "N/A"))

            # Guardar datos del item
            tree_item.setData(0, Qt.ItemDataRole.UserRole, item)

            # Color por tipo
            if item["is_directory"]:
                tree_item.setBackground(1, QColor(54, 162, 235, 30))  # Azul
            else:
                tree_item.setBackground(1, QColor(75, 192, 192, 30))  # Verde

            self.items_tree.addTopLevelItem(tree_item)

        # Ajustar columnas
        for i in range(6):
            self.items_tree.resizeColumnToContents(i)

        layout.addWidget(self.items_tree)

        # Botones de selecci√≥n
        selection_layout = QHBoxLayout()

        self.select_all_btn = QPushButton("‚òëÔ∏è Seleccionar Todo")
        self.select_all_btn.clicked.connect(self.select_all)

        self.select_none_btn = QPushButton("‚òê Deseleccionar Todo")
        self.select_none_btn.clicked.connect(self.select_none)

        self.select_files_btn = QPushButton("üìÑ Solo Archivos")
        self.select_files_btn.clicked.connect(self.select_files_only)

        self.select_folders_btn = QPushButton("üìÅ Solo Carpetas")
        self.select_folders_btn.clicked.connect(self.select_folders_only)

        selection_layout.addWidget(self.select_all_btn)
        selection_layout.addWidget(self.select_none_btn)
        selection_layout.addWidget(self.select_files_btn)
        selection_layout.addWidget(self.select_folders_btn)
        selection_layout.addStretch()

        layout.addLayout(selection_layout)

        # Informaci√≥n de selecci√≥n
        self.selection_info = QLabel("Todos los elementos seleccionados")
        self.selection_info.setStyleSheet("color: #888888; font-style: italic;")
        layout.addWidget(self.selection_info)

        # Botones de acci√≥n
        buttons_layout = QHBoxLayout()

        self.paste_btn = QPushButton("üìã Pegar Seleccionados")
        self.paste_btn.clicked.connect(self.accept_selection)

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.paste_btn)
        buttons_layout.addWidget(self.cancel_btn)

        layout.addLayout(buttons_layout)

        # Conectar se√±ales
        self.items_tree.itemChanged.connect(self.update_selection_info)
        self.update_selection_info()

    def setup_style(self):
        """Configurar el estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QTreeWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                alternate-background-color: #3a3a3a;
                selection-background-color: #217346;
            }
            QTreeWidget::item {
                padding: 5px;
                border: none;
            }
            QTreeWidget::item:hover {
                background-color: #454545;
            }
            QHeaderView::section {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 8px;
                border: 1px solid #555555;
                font-weight: bold;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 8px 16px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QLabel {
                color: #cccccc;
            }
        """)

    def select_all(self):
        """Seleccionar todos los elementos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Checked)

    def select_none(self):
        """Deseleccionar todos los elementos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Unchecked)

    def select_files_only(self):
        """Seleccionar solo archivos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item_data = item.data(0, Qt.ItemDataRole.UserRole)
            if item_data:
                if item_data["is_directory"]:
                    item.setCheckState(0, Qt.CheckState.Unchecked)
                else:
                    item.setCheckState(0, Qt.CheckState.Checked)

    def select_folders_only(self):
        """Seleccionar solo carpetas"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item_data = item.data(0, Qt.ItemDataRole.UserRole)
            if item_data:
                if item_data["is_directory"]:
                    item.setCheckState(0, Qt.CheckState.Checked)
                else:
                    item.setCheckState(0, Qt.CheckState.Unchecked)

    def update_selection_info(self):
        """Actualizar informaci√≥n de selecci√≥n"""
        selected_count = 0
        files_count = 0
        folders_count = 0

        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                selected_count += 1
                item_data = item.data(0, Qt.ItemDataRole.UserRole)
                if item_data:
                    if item_data["is_directory"]:
                        folders_count += 1
                    else:
                        files_count += 1

        if selected_count == 0:
            self.selection_info.setText("Ning√∫n elemento seleccionado")
            self.paste_btn.setEnabled(False)
        else:
            info_text = f"{selected_count} elementos seleccionados"
            if files_count > 0 and folders_count > 0:
                info_text += f" ({files_count} archivos, {folders_count} carpetas)"
            elif files_count > 0:
                info_text += f" ({files_count} archivos)"
            elif folders_count > 0:
                info_text += f" ({folders_count} carpetas)"

            self.selection_info.setText(info_text)
            self.paste_btn.setEnabled(True)

    def accept_selection(self):
        """Aceptar selecci√≥n y cerrar di√°logo"""
        self.selected_items = []

        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                item_data = item.data(0, Qt.ItemDataRole.UserRole)
                if item_data:
                    self.selected_items.append(item_data)

        if self.selected_items:
            self.accept()
        else:
            QMessageBox.information(
                self,
                "Sin Selecci√≥n",
                "Por favor selecciona al menos un elemento para pegar.",
            )

    def get_selected_items(self):
        """Obtener elementos seleccionados"""
        return self.selected_items

    def restore_geometry(self):
        """Restaurar geometr√≠a de la ventana"""
        self.geometry_manager.restore_window_geometry(
            self, "paste_selection", (800, 600)
        )

    def closeEvent(self, event):
        """Guardar geometr√≠a al cerrar"""
        self.geometry_manager.save_window_geometry("paste_selection", self.geometry())
        super().closeEvent(event)


class ClipboardManagerDialog(QDialog):
    """Di√°logo para gestionar elementos del clipboard m√∫ltiple"""

    def __init__(self, multi_clipboard, parent=None):
        super().__init__(parent)
        self.multi_clipboard = multi_clipboard
        self.setWindowTitle("üóÇÔ∏è Gestionar Clipboard M√∫ltiple")
        set_window_icon(self)
        self.setMinimumSize(700, 500)
        self.resize(900, 700)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        self.restore_geometry()

    def setup_ui(self):
        """Configurar la interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel("üóÇÔ∏è Gesti√≥n de Clipboard M√∫ltiple")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Informaci√≥n
        clipboard_count = self.multi_clipboard.count()
        info_label = QLabel(
            f"Elementos en clipboard: {clipboard_count} (m√°ximo: {self.multi_clipboard.max_items})"
        )
        info_label.setStyleSheet("color: #cccccc; font-weight: bold;")
        layout.addWidget(info_label)

        # Lista de elementos
        self.items_tree = QTreeWidget()
        self.items_tree.setHeaderLabels(
            ["", "Nombre", "Tipo", "Ruta", "Tama√±o", "Modificado", "Agregado"]
        )
        self.items_tree.setRootIsDecorated(False)
        self.items_tree.setAlternatingRowColors(True)
        self.items_tree.setSelectionMode(QTreeWidget.SelectionMode.ExtendedSelection)

        self.refresh_clipboard_list()
        layout.addWidget(self.items_tree)

        # Botones de gesti√≥n
        buttons_layout = QHBoxLayout()

        self.remove_selected_btn = QPushButton("üóëÔ∏è Eliminar Seleccionados")
        self.remove_selected_btn.clicked.connect(self.remove_selected_items)

        self.clear_all_btn = QPushButton("üóëÔ∏è Limpiar Todo")
        self.clear_all_btn.clicked.connect(self.clear_all_items)

        self.paste_selected_btn = QPushButton("üìã Pegar Seleccionados")
        self.paste_selected_btn.clicked.connect(self.paste_selected_items)

        self.refresh_btn = QPushButton("üîÑ Actualizar")
        self.refresh_btn.clicked.connect(self.refresh_clipboard_list)

        buttons_layout.addWidget(self.remove_selected_btn)
        buttons_layout.addWidget(self.clear_all_btn)
        buttons_layout.addWidget(self.paste_selected_btn)
        buttons_layout.addWidget(self.refresh_btn)
        buttons_layout.addStretch()

        layout.addLayout(buttons_layout)

        # Bot√≥n cerrar
        close_layout = QHBoxLayout()
        self.close_btn = QPushButton("‚ùå Cerrar")
        self.close_btn.clicked.connect(self.accept)
        close_layout.addStretch()
        close_layout.addWidget(self.close_btn)
        layout.addLayout(close_layout)

        # Conectar se√±ales
        self.items_tree.itemSelectionChanged.connect(self.update_button_states)
        self.update_button_states()

    def setup_style(self):
        """Configurar estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QTreeWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 5px;
                alternate-background-color: #3a3a3a;
                selection-background-color: #217346;
            }
            QTreeWidget::item {
                padding: 5px;
                border: none;
            }
            QTreeWidget::item:hover {
                background-color: #454545;
            }
            QHeaderView::section {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 8px;
                border: 1px solid #555555;
                font-weight: bold;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 8px 16px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QPushButton:disabled {
                background-color: #6c757d;
            }
            QLabel {
                color: #cccccc;
            }
        """)

    def refresh_clipboard_list(self):
        """Actualizar lista de elementos del clipboard"""
        self.items_tree.clear()

        clipboard_items = self.multi_clipboard.get_items()

        for i, item in enumerate(clipboard_items):
            tree_item = QTreeWidgetItem()

            # N√∫mero de orden
            tree_item.setText(0, str(i + 1))

            # Icono y nombre
            icon = "üìÅ" if item["is_directory"] else "üìÑ"
            tree_item.setText(1, f"{icon} {item['name']}")

            # Tipo
            tree_item.setText(2, "Carpeta" if item["is_directory"] else "Archivo")

            # Ruta
            tree_item.setText(3, item["path"])

            # Tama√±o
            if item.get("size"):
                size_mb = item["size"] / (1024 * 1024)
                tree_item.setText(4, f"{size_mb:.1f} MB")
            else:
                tree_item.setText(4, "N/A")

            # Fecha modificaci√≥n
            tree_item.setText(5, item.get("modified", "N/A"))

            # Hora agregado
            tree_item.setText(6, item.get("added_time", "N/A"))

            # Guardar referencia al item
            tree_item.setData(0, Qt.ItemDataRole.UserRole, item)

            # Color por antig√ºedad (m√°s recientes m√°s brillantes)
            if i < 3:  # Los 3 m√°s recientes
                tree_item.setBackground(1, QColor(74, 144, 226, 50))
            elif i < 10:  # Los siguientes 7
                tree_item.setBackground(1, QColor(74, 144, 226, 25))

            # Verificar si el archivo a√∫n existe
            if not os.path.exists(item["path"]):
                # Marcar como no disponible
                for col in range(7):
                    tree_item.setForeground(col, QColor(200, 200, 200, 100))
                tree_item.setText(2, tree_item.text(2) + " (No disponible)")

            self.items_tree.addTopLevelItem(tree_item)

        # Ajustar columnas
        for i in range(7):
            self.items_tree.resizeColumnToContents(i)

    def update_button_states(self):
        """Actualizar estado de botones seg√∫n selecci√≥n"""
        selected_items = self.items_tree.selectedItems()
        has_selection = len(selected_items) > 0
        has_items = self.multi_clipboard.count() > 0

        self.remove_selected_btn.setEnabled(has_selection)
        self.paste_selected_btn.setEnabled(has_selection)
        self.clear_all_btn.setEnabled(has_items)

    def remove_selected_items(self):
        """Eliminar elementos seleccionados del clipboard"""
        selected_items = self.items_tree.selectedItems()

        if not selected_items:
            return

        # Confirmar eliminaci√≥n
        result = QMessageBox.question(
            self,
            "Confirmar Eliminaci√≥n",
            f"¬øEliminar {len(selected_items)} elementos del clipboard?\n\nEsta acci√≥n no se puede deshacer.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if result == QMessageBox.StandardButton.Yes:
            # Eliminar elementos
            for item in selected_items:
                item_data = item.data(0, Qt.ItemDataRole.UserRole)
                if item_data:
                    self.multi_clipboard.remove_item(item_data["path"])

            # Actualizar lista
            self.refresh_clipboard_list()
            self.update_button_states()

    def clear_all_items(self):
        """Limpiar todo el clipboard"""
        if self.multi_clipboard.count() == 0:
            return

        result = QMessageBox.question(
            self,
            "Confirmar Limpieza",
            f"¬øLimpiar todo el clipboard ({self.multi_clipboard.count()} elementos)?\n\nEsta acci√≥n no se puede deshacer.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if result == QMessageBox.StandardButton.Yes:
            self.multi_clipboard.clear_all()
            self.refresh_clipboard_list()
            self.update_button_states()

    def paste_selected_items(self):
        """Pegar elementos seleccionados"""
        selected_items = self.items_tree.selectedItems()

        if not selected_items:
            return

        # Obtener datos de elementos seleccionados
        items_to_paste = []
        for item in selected_items:
            item_data = item.data(0, Qt.ItemDataRole.UserRole)
            if item_data and os.path.exists(item_data["path"]):
                items_to_paste.append(item_data)

        if not items_to_paste:
            QMessageBox.warning(
                self,
                "Sin Elementos V√°lidos",
                "Los elementos seleccionados no est√°n disponibles para pegar.",
            )
            return

        # Mostrar di√°logo de selecci√≥n espec√≠fica
        dialog = PasteSelectionDialog(items_to_paste, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_for_paste = dialog.get_selected_items()
            if selected_for_paste and hasattr(self.parent(), "drop_area"):
                self.parent().drop_area.paste_selected_items(selected_for_paste)
                self.accept()

    def restore_geometry(self):
        """Restaurar geometr√≠a de la ventana"""
        self.geometry_manager.restore_window_geometry(
            self, "clipboard_manager", (900, 700)
        )

    def closeEvent(self, event):
        """Guardar geometr√≠a al cerrar"""
        self.geometry_manager.save_window_geometry("clipboard_manager", self.geometry())
        super().closeEvent(event)


class FileCard(QWidget):
    """Tarjeta visual para mostrar archivo o carpeta estilo Explorador de Windows"""

    double_clicked = pyqtSignal(str)  # Emite la ruta al hacer doble clic
    context_menu_requested = pyqtSignal(str, object)  # Emite ruta y posici√≥n

    def __init__(self, path, is_directory=True, parent=None):
        super().__init__(parent)
        self.path = path
        self.is_directory = is_directory
        self.setup_ui()
        self.setAcceptDrops(True)

        # Hacer draggable
        self.is_dragging = False
        self.drag_start_position = None

    def setup_ui(self):
        """Configurar UI de la tarjeta"""
        self.setFixedSize(140, 170)  # Aumentado de 120x140 a 140x170
        self.setCursor(Qt.CursorShape.PointingHandCursor)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)  # M√°s padding interno
        layout.setSpacing(6)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Icono grande
        icon_label = QLabel()
        icon = "üìÅ" if self.is_directory else "üìÑ"

        # Detectar tipo de archivo para icono espec√≠fico
        if not self.is_directory:
            ext = os.path.splitext(self.path)[1].lower()
            icon_map = {
                ".pdf": "üìï",
                ".doc": "üìò",
                ".docx": "üìò",
                ".xls": "üìó",
                ".xlsx": "üìó",
                ".csv": "üìó",
                ".txt": "üìù",
                ".py": "üêç",
                ".js": "üìú",
                ".jpg": "üñºÔ∏è",
                ".jpeg": "üñºÔ∏è",
                ".png": "üñºÔ∏è",
                ".gif": "üñºÔ∏è",
                ".mp4": "üé¨",
                ".avi": "üé¨",
                ".mkv": "üé¨",
                ".mp3": "üéµ",
                ".wav": "üéµ",
                ".flac": "üéµ",
                ".zip": "üì¶",
                ".rar": "üì¶",
                ".7z": "üì¶",
            }
            icon = icon_map.get(ext, "üìÑ")

        icon_label.setText(icon)
        icon_label.setStyleSheet("""
            QLabel {
                font-size: 56px;
                padding: 8px;
            }
        """)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(icon_label)

        # Nombre del archivo/carpeta
        name = os.path.basename(self.path)
        if len(name) > 18:
            name = name[:15] + "..."

        name_label = QLabel(name)
        name_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 11pt;
                background: transparent;
                padding: 3px;
                font-weight: 500;
            }
        """)
        name_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        name_label.setWordWrap(True)
        name_label.setToolTip(os.path.basename(self.path))
        layout.addWidget(name_label)

        # Estilo de la tarjeta
        self.setStyleSheet("""
            FileCard {
                background-color: #ffffff;
                border: 2px solid #3a3a3a;
                border-radius: 8px;
            }
            FileCard:hover {
                background-color: #3a3a3a;
                border: 2px solid #4a90e2;
            }
        """)

    def mouseDoubleClickEvent(self, event):
        """Manejar doble clic"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.double_clicked.emit(self.path)

    def mousePressEvent(self, event):
        """Manejar click del mouse para drag"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_start_position = event.pos()
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Iniciar drag si se mueve el mouse"""
        if not (event.buttons() & Qt.MouseButton.LeftButton):
            return
        if not self.drag_start_position:
            return
        if (event.pos() - self.drag_start_position).manhattanLength() < 10:
            return

        # Iniciar drag
        drag = QDrag(self)
        mime_data = QMimeData()
        mime_data.setText(self.path)
        drag.setMimeData(mime_data)

        # Crear pixmap para mostrar mientras se arrastra
        pixmap = QPixmap(self.size())
        self.render(pixmap)
        drag.setPixmap(
            pixmap.scaled(
                100,
                120,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation,
            )
        )
        drag.setHotSpot(pixmap.rect().center())

        # Cambiar estilo mientras se arrastra
        self.setStyleSheet("""
            FileCard {
                background-color: #1a1a1a;
                border: 2px dashed #4a90e2;
                border-radius: 8px;
                opacity: 0.5;
            }
        """)

        drag.exec(Qt.DropAction.MoveAction)

        # Restaurar estilo
        self.setStyleSheet("""
            FileCard {
                background-color: #ffffff;
                border: 2px solid #3a3a3a;
                border-radius: 8px;
            }
            FileCard:hover {
                background-color: #3a3a3a;
                border: 2px solid #4a90e2;
            }
        """)

    def contextMenuEvent(self, event):
        """Manejar men√∫ contextual"""
        self.context_menu_requested.emit(self.path, event.globalPos())


class CategoryConfigDialog(QDialog):
    """Di√°logo para configurar color e icono de una categor√≠a"""

    def __init__(self, category_name, current_color, current_icon, parent=None):
        super().__init__(parent)
        self.category_name = category_name
        self.selected_color = current_color
        self.selected_icon = current_icon
        self.setup_ui()

    def setup_ui(self):
        """Configurar interfaz del di√°logo"""
        self.setWindowTitle(f"Configurar: {self.category_name}")
        self.setMinimumWidth(500)

        layout = QVBoxLayout(self)
        layout.setSpacing(20)
        layout.setContentsMargins(20, 20, 20, 20)

        # T√≠tulo
        title = QLabel(f"‚öôÔ∏è Configurar Categor√≠a: {self.category_name}")
        title.setStyleSheet("""
            QLabel {
                font-size: 16pt;
                font-weight: bold;
                color: #4a90e2;
                padding: 10px;
            }
        """)
        layout.addWidget(title)

        # Selector de icono
        icon_group = QGroupBox("üìå Icono de la Categor√≠a")
        icon_group.setStyleSheet("""
            QGroupBox {
                font-size: 12pt;
                font-weight: bold;
                padding: 15px;
                border: 2px solid #4a90e2;
                border-radius: 8px;
                margin-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                left: 10px;
                padding: 0 5px;
            }
        """)
        icon_layout = QVBoxLayout(icon_group)

        # Grid de iconos predefinidos
        icon_grid_widget = QWidget()
        icon_grid = QGridLayout(icon_grid_widget)
        icon_grid.setSpacing(10)

        self.icon_buttons = []
        icons_list = [
            "üìÅ",
            "üìÇ",
            "üìä",
            "üìà",
            "üìâ",
            "üìã",
            "üìå",
            "üìç",
            "üìé",
            "üìù",
            "üíº",
            "üè¢",
            "üè†",
            "üöó",
            "‚úàÔ∏è",
            "üéì",
            "üíª",
            "üì±",
            "üé®",
            "üéµ",
            "üé¨",
            "üì∑",
            "üéÆ",
            "‚öΩ",
            "üèÜ",
            "üí∞",
            "üí≥",
            "üõí",
            "üéÅ",
            "‚≠ê",
            "‚ù§Ô∏è",
            "üî•",
            "üíé",
            "üîë",
            "üîí",
            "üìß",
            "üìû",
            "‚öôÔ∏è",
            "üîß",
            "üî®",
        ]

        for i, icon in enumerate(icons_list):
            btn = QPushButton(icon)
            btn.setFixedSize(50, 50)
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setStyleSheet("""
                QPushButton {
                    font-size: 24pt;
                    background-color: #3a3a3a;
                    border: 2px solid #5a5a5a;
                    border-radius: 8px;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                    border: 2px solid #4a90e2;
                }
                QPushButton:checked {
                    background-color: #217346;
                    border: 3px solid #ffffff;
                }
            """)
            btn.setCheckable(True)
            if icon == self.selected_icon:
                btn.setChecked(True)
            btn.clicked.connect(lambda checked, ic=icon: self.select_icon(ic))
            icon_grid.addWidget(btn, i // 10, i % 10)
            self.icon_buttons.append(btn)

        icon_layout.addWidget(icon_grid_widget)
        layout.addWidget(icon_group)

        # Selector de color
        color_group = QGroupBox("üé® Color de la Categor√≠a")
        color_group.setStyleSheet("""
            QGroupBox {
                font-size: 12pt;
                font-weight: bold;
                padding: 15px;
                border: 2px solid #4a90e2;
                border-radius: 8px;
                margin-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                subcontrol-position: top left;
                left: 10px;
                padding: 0 5px;
            }
        """)
        color_layout = QVBoxLayout(color_group)

        # Colores predefinidos
        color_palette_widget = QWidget()
        color_palette = QGridLayout(color_palette_widget)
        color_palette.setSpacing(10)

        self.color_buttons = []
        colors_list = [
            ("#4a90e2", "Azul"),
            ("#9c27b0", "P√∫rpura"),
            ("#00b4d8", "Cyan"),
            ("#4caf50", "Verde"),
            ("#ff6b35", "Naranja"),
            ("#f72585", "Rosa"),
            ("#00f5ff", "Turquesa"),
            ("#ff4500", "Rojo"),
            ("#ffd60a", "Amarillo"),
            ("#a67c52", "Marr√≥n"),
            ("#7aa2f7", "Azul Claro"),
            ("#ff7f50", "Coral"),
        ]

        for i, (color, name) in enumerate(colors_list):
            btn = QPushButton(name)
            btn.setFixedSize(90, 40)
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    color: #ffffff;
                    font-weight: bold;
                    border: 2px solid #5a5a5a;
                    border-radius: 8px;
                }}
                QPushButton:hover {{
                    border: 3px solid #ffffff;
                }}
                QPushButton:checked {{
                    border: 4px solid #ffffff;
                }}
            """)
            btn.setCheckable(True)
            if color == self.selected_color:
                btn.setChecked(True)
            btn.clicked.connect(lambda checked, c=color: self.select_color(c))
            color_palette.addWidget(btn, i // 4, i % 4)
            self.color_buttons.append(btn)

        color_layout.addWidget(color_palette_widget)

        # Color personalizado
        custom_color_layout = QHBoxLayout()
        custom_color_label = QLabel("Color personalizado:")
        custom_color_label.setStyleSheet("font-size: 11pt;")
        custom_color_layout.addWidget(custom_color_label)

        self.custom_color_btn = QPushButton("üé® Elegir color...")
        self.custom_color_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.custom_color_btn.setStyleSheet("""
            QPushButton {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 8px 15px;
                border: 2px solid #4a90e2;
                border-radius: 6px;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #4a4a4a;
            }
        """)
        self.custom_color_btn.clicked.connect(self.pick_custom_color)
        custom_color_layout.addWidget(self.custom_color_btn)
        custom_color_layout.addStretch()

        color_layout.addLayout(custom_color_layout)
        layout.addWidget(color_group)

        # Previsualizaci√≥n
        preview_label = QLabel("Vista previa:")
        preview_label.setStyleSheet("font-size: 12pt; font-weight: bold;")
        layout.addWidget(preview_label)

        self.preview_widget = QWidget()
        self.preview_widget.setFixedHeight(60)
        self.update_preview()
        layout.addWidget(self.preview_widget)

        # Botones
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        cancel_btn = QPushButton("‚ùå Cancelar")
        cancel_btn.setFixedWidth(120)
        cancel_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: #ffffff;
                padding: 10px;
                border: none;
                border-radius: 6px;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
        """)
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)

        save_btn = QPushButton("üíæ Guardar")
        save_btn.setFixedWidth(120)
        save_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: #ffffff;
                padding: 10px;
                border: none;
                border-radius: 6px;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)
        save_btn.clicked.connect(self.accept)
        button_layout.addWidget(save_btn)

        layout.addLayout(button_layout)

    def select_icon(self, icon):
        """Seleccionar un icono"""
        self.selected_icon = icon
        # Desmarcar otros botones
        for btn in self.icon_buttons:
            if btn.text() != icon:
                btn.setChecked(False)
        self.update_preview()

    def select_color(self, color):
        """Seleccionar un color"""
        self.selected_color = color
        # Desmarcar otros botones
        for btn in self.color_buttons:
            btn.setChecked(False)
        # Marcar el bot√≥n seleccionado
        for btn in self.color_buttons:
            if color in btn.styleSheet():
                btn.setChecked(True)
        self.update_preview()

    def pick_custom_color(self):
        """Abrir selector de color personalizado"""
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor

        current_color = QColor(self.selected_color)
        color = QColorDialog.getColor(current_color, self, "Seleccionar Color")
        if color.isValid():
            self.selected_color = color.name()
            # Desmarcar todos los botones de color predefinido
            for btn in self.color_buttons:
                btn.setChecked(False)
            self.update_preview()

    def update_preview(self):
        """Actualizar la previsualizaci√≥n"""
        self.preview_widget.setStyleSheet(f"""
            QWidget {{
                background-color: {self.selected_color};
                border: 3px solid #ffffff;
                border-radius: 8px;
            }}
        """)

        # Agregar texto de previsualizaci√≥n si no existe
        if not self.preview_widget.layout():
            layout = QHBoxLayout(self.preview_widget)
            layout.setContentsMargins(15, 0, 15, 0)
            preview_label = QLabel(f"{self.selected_icon} {self.category_name}")
            preview_label.setStyleSheet("""
                QLabel {
                    color: #ffffff;
                    font-size: 18pt;
                    font-weight: bold;
                    background: transparent;
                }
            """)
            layout.addWidget(preview_label)
        else:
            # Actualizar el label existente
            label = self.preview_widget.findChild(QLabel)
            if label:
                label.setText(f"{self.selected_icon} {self.category_name}")

    def get_config(self):
        """Obtener la configuraci√≥n seleccionada"""
        return self.selected_color, self.selected_icon


class CategoryBlock(QWidget):
    """Bloque visual de categor√≠a con grid de archivos estilo Explorador de Windows"""

    items_changed = pyqtSignal()
    category_deleted = pyqtSignal(str)  # Se√±al para eliminar categor√≠a

    def __init__(self, category_name, parent=None, custom_color=None, custom_icon=None):
        super().__init__(parent)
        self.category_name = category_name
        self.items = []  # Lista de rutas
        self.is_collapsed = False
        self.file_cards = []
        self.columns = 5  # Columnas por defecto
        self.custom_color = custom_color or "#4a90e2"  # Color por defecto
        self.custom_icon = custom_icon or "üìÅ"  # Icono por defecto
        self.setup_ui()

        # Habilitar drag and drop
        self.setAcceptDrops(True)

        # Tama√±o m√≠nimo y pol√≠tica de tama√±o (aumentado para tarjetas m√°s grandes)
        self.setMinimumWidth(550)  # De 450 a 550
        self.setMinimumHeight(250)  # De 200 a 250
        # Preferred permite crecer pero mantiene un tama√±o base
        self.setSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum)

    def setup_ui(self):
        """Configurar UI del bloque de categor√≠a"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # Header de la categor√≠a (colapsable)
        self.header_widget = QWidget()
        self.header_widget.setStyleSheet(f"""
            QWidget {{
                background-color: {self.custom_color};
                border-radius: 8px;
                padding: 5px;
            }}
        """)
        self.header_widget.setCursor(Qt.CursorShape.PointingHandCursor)
        header_layout = QHBoxLayout(self.header_widget)
        header_layout.setContentsMargins(15, 10, 15, 10)

        # Flecha de colapsar/expandir
        self.arrow_label = QLabel("‚ñº")
        self.arrow_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 12pt;
                font-weight: bold;
            }
        """)
        header_layout.addWidget(self.arrow_label)

        # Icono y nombre de la categor√≠a
        self.category_label = QLabel(f"{self.custom_icon} {self.category_name}")
        self.category_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 14pt;
                font-weight: bold;
            }
        """)
        self.category_label.setToolTip(
            "Arrastra archivos aqu√≠ para agregarlos a esta categor√≠a"
        )
        header_layout.addWidget(self.category_label)

        # Bot√≥n de configuraci√≥n
        config_btn = QPushButton("‚öôÔ∏è")
        config_btn.setFixedSize(30, 30)
        config_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        config_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 5px;
                font-size: 14pt;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.3);
            }
        """)
        config_btn.setToolTip("Configurar color e icono de la categor√≠a")
        config_btn.clicked.connect(self.configure_category)
        header_layout.addWidget(config_btn)

        # Bot√≥n de eliminar categor√≠a (solo si no es "Sin Categor√≠a")
        if self.category_name != "Sin Categor√≠a":
            delete_btn = QPushButton("üóëÔ∏è")
            delete_btn.setFixedSize(30, 30)
            delete_btn.setCursor(Qt.CursorShape.PointingHandCursor)
            delete_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgba(255, 68, 68, 0.3);
                    border: none;
                    border-radius: 5px;
                    font-size: 14pt;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: rgba(255, 68, 68, 0.6);
                }
            """)
            delete_btn.setToolTip("Eliminar esta categor√≠a")
            delete_btn.clicked.connect(self.delete_category)
            header_layout.addWidget(delete_btn)

        # Contador de elementos
        self.count_label = QLabel("(0 elementos)")
        self.count_label.setStyleSheet("""
            QLabel {
                color: #aaaaaa;
                font-size: 10pt;
                font-style: italic;
            }
        """)
        header_layout.addWidget(self.count_label)

        header_layout.addStretch()

        # Hacer el header clickeable
        self.header_widget.mousePressEvent = lambda e: self.toggle_collapse()

        main_layout.addWidget(self.header_widget)

        # Contenedor para el grid de archivos
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(10, 10, 10, 10)
        self.content_layout.setSpacing(10)

        # Scroll area para el grid
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        scroll.setStyleSheet("""
            QScrollArea {
                background-color: #1a1a1a;
                border: 2px solid #3a3a3a;
                border-radius: 8px;
            }
            QScrollBar:vertical {
                background-color: #ffffff;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 6px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5aa0f2;
            }
        """)

        # Widget interno del grid
        self.grid_widget = QWidget()
        self.grid_widget.setAcceptDrops(True)
        # Usar un layout vertical para agregar separadores
        self.grid_container_layout = QVBoxLayout(self.grid_widget)
        self.grid_container_layout.setContentsMargins(20, 20, 20, 20)
        self.grid_container_layout.setSpacing(0)
        self.grid_container_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        # Propagar eventos de drop del grid_widget al bloque padre
        self.grid_widget.dragEnterEvent = lambda e: self.dragEnterEvent(e)
        self.grid_widget.dragMoveEvent = lambda e: self.dragMoveEvent(e)
        self.grid_widget.dragLeaveEvent = lambda e: self.dragLeaveEvent(e)
        self.grid_widget.dropEvent = lambda e: self.dropEvent(e)

        scroll.setWidget(self.grid_widget)
        self.content_layout.addWidget(scroll)

        main_layout.addWidget(self.content_widget)

        # Estilo del bloque con color personalizado en el borde
        self.update_block_style()

    def toggle_collapse(self):
        """Alternar entre colapsado y expandido"""
        self.is_collapsed = not self.is_collapsed
        self.content_widget.setVisible(not self.is_collapsed)
        self.arrow_label.setText("‚ñ∂" if self.is_collapsed else "‚ñº")

    def add_item(self, path):
        """Agregar archivo o carpeta al bloque"""
        if path not in self.items:
            self.items.append(path)
            self.refresh_grid()
            self.items_changed.emit()

    def remove_item(self, path):
        """Eliminar archivo o carpeta del bloque"""
        if path in self.items:
            self.items.remove(path)
            self.refresh_grid()
            self.items_changed.emit()

    def clear_items(self):
        """Limpiar todos los elementos"""
        self.items.clear()
        self.refresh_grid()
        self.items_changed.emit()

    def refresh_grid(self):
        """Refrescar el grid de tarjetas con separadores"""
        # Limpiar layout
        while self.grid_container_layout.count():
            item = self.grid_container_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        self.file_cards.clear()

        # Calcular columnas seg√∫n el ancho disponible
        # Cada tarjeta es 140px + 20px spacing = 160px
        width = self.width()
        if width < 550:
            columns = 2  # M√≠nimo 2 tarjetas
        elif width < 700:
            columns = 3
        elif width < 850:
            columns = 4
        else:
            columns = 5

        self.columns = columns

        # Agregar tarjetas con separadores
        current_row_widget = None
        current_row_layout = None

        # Filtrar items existentes primero para evitar saltos que dejen current_row_layout en None
        valid_items = [p for p in self.items if os.path.exists(p)]

        for idx, path in enumerate(valid_items):
            # Crear nueva fila si es necesario
            if idx % columns == 0:
                current_row_widget = QWidget()
                current_row_layout = QHBoxLayout(current_row_widget)
                current_row_layout.setContentsMargins(0, 0, 0, 0)
                current_row_layout.setSpacing(20)
                current_row_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
                self.grid_container_layout.addWidget(current_row_widget)

            is_dir = os.path.isdir(path)
            card = FileCard(path, is_dir, self)
            card.double_clicked.connect(self.open_item)
            card.context_menu_requested.connect(self.show_item_context_menu)

            # Asegurarse de que current_row_layout est√© inicializado
            if current_row_layout is None:
                current_row_widget = QWidget()
                current_row_layout = QHBoxLayout(current_row_widget)
                current_row_layout.setContentsMargins(0, 0, 0, 0)
                current_row_layout.setSpacing(20)
                current_row_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)
                self.grid_container_layout.addWidget(current_row_widget)

            current_row_layout.addWidget(card)
            self.file_cards.append(card)

            # Agregar l√≠nea separadora despu√©s de cada fila (excepto la √∫ltima)
            if (idx + 1) % columns == 0 and (idx + 1) < len(valid_items):
                separator = QFrame()
                separator.setFrameShape(QFrame.Shape.HLine)
                separator.setStyleSheet(f"""
                    QFrame {{
                        background-color: {self.custom_color};
                        min-height: 2px;
                        max-height: 2px;
                        margin: 15px 0px;
                        border: none;
                    }}
                """)
                self.grid_container_layout.addWidget(separator)

        # Agregar stretch al final
        self.grid_container_layout.addStretch()

        # Actualizar contador
        self.count_label.setText(f"({len(self.items)} elementos)")

    def resizeEvent(self, event):
        """Adaptar grid al cambiar tama√±o"""
        super().resizeEvent(event)

        # Calcular nuevas columnas
        width = self.width()
        if width < 550:
            new_columns = 2
        elif width < 700:
            new_columns = 3
        elif width < 850:
            new_columns = 4
        else:
            new_columns = 5

        # Solo refrescar si cambi√≥ el n√∫mero de columnas
        if new_columns != self.columns and self.items:
            self.refresh_grid()

    def open_item(self, path):
        """Abrir archivo o carpeta"""
        try:
            if os.name == "nt":  # Windows
                os.startfile(path)
            elif os.name == "posix":  # macOS o Linux
                if sys.platform == "darwin":
                    subprocess.run(["open", path])
                else:
                    subprocess.run(["xdg-open", path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo abrir: {e}")

    def show_item_context_menu(self, path, pos):
        """Mostrar men√∫ contextual para un elemento"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #4a90e2;
                padding: 5px;
            }
            QMenu::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
        """)

        open_action = menu.addAction("üìÇ Abrir")
        open_action.triggered.connect(lambda: self.open_item(path))

        menu.addSeparator()

        remove_action = menu.addAction("üóëÔ∏è Eliminar de Favoritos")
        remove_action.triggered.connect(lambda: self.remove_item(path))

        menu.addSeparator()

        reveal_action = menu.addAction("üìç Mostrar en Explorador")
        reveal_action.triggered.connect(lambda: self.reveal_in_explorer(path))

        copy_path_action = menu.addAction("üìã Copiar Ruta")
        copy_path_action.triggered.connect(lambda: self.copy_path_to_clipboard(path))

        menu.exec(pos)

    def reveal_in_explorer(self, path):
        """Mostrar archivo/carpeta en el explorador"""
        try:
            if os.name == "nt":  # Windows
                if os.path.isdir(path):
                    os.startfile(path)
                else:
                    subprocess.run(["explorer", "/select,", path])
            elif os.name == "posix":
                if sys.platform == "darwin":  # macOS
                    subprocess.run(["open", "-R", path])
                else:  # Linux
                    subprocess.run(["xdg-open", os.path.dirname(path)])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo mostrar en explorador: {e}")

    def copy_path_to_clipboard(self, path):
        """Copiar ruta al portapapeles"""
        clipboard = QApplication.clipboard()
        clipboard.setText(path)

    def dragEnterEvent(self, event):
        """Manejar cuando se arrastra algo sobre este bloque"""
        if event.mimeData().hasText():
            # Verificar si es una ruta de archivo v√°lida
            path = event.mimeData().text()
            if os.path.exists(path):
                event.acceptProposedAction()
                # Resaltar el bloque
                self.setStyleSheet("""
                    CategoryBlock {
                        background-color: #2a3a4a;
                        border: 3px solid #4a90e2;
                        border-radius: 10px;
                    }
                """)
        elif event.mimeData().hasUrls():
            # Archivos arrastrados desde fuera
            event.acceptProposedAction()
            self.setStyleSheet("""
                CategoryBlock {
                    background-color: #2a3a4a;
                    border: 3px solid #4a90e2;
                    border-radius: 10px;
                }
            """)

    def dragMoveEvent(self, event):
        """Mantener resaltado mientras se mueve sobre el bloque"""
        if event.mimeData().hasText() or event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dragLeaveEvent(self, event):
        """Restaurar estilo cuando el drag sale del bloque"""
        self.setStyleSheet("""
            CategoryBlock {
                background-color: #252525;
                border: 2px solid #4a4a4a;
                border-radius: 10px;
            }
        """)

    def dropEvent(self, event):
        """Manejar cuando se suelta algo en este bloque"""
        success = False

        if event.mimeData().hasText():
            # Archivo arrastrado desde otra tarjeta
            path = event.mimeData().text()
            if os.path.exists(path) and path not in self.items:
                # Agregar al bloque actual
                self.add_item(path)

                # Buscar el bloque origen y eliminar de ah√≠
                if hasattr(self.parent(), "category_blocks"):
                    for block in self.parent().category_blocks.values():
                        if block != self and path in block.items:
                            block.remove_item(path)
                            break

                success = True
                event.acceptProposedAction()

        elif event.mimeData().hasUrls():
            # Archivos arrastrados desde fuera de la aplicaci√≥n
            for url in event.mimeData().urls():
                path = url.toLocalFile()
                if path:
                    path = normalize_network_path(path)
                    if os.path.exists(path) and path not in self.items:
                        self.add_item(path)
                        success = True

            if success:
                event.acceptProposedAction()

        # Efecto visual de √©xito
        if success:
            # Resaltar en verde brevemente
            self.setStyleSheet(f"""
                CategoryBlock {{
                    background-color: #2a4a2a;
                    border: 3px solid #4CAF50;
                    border-radius: 10px;
                }}
            """)
            # Restaurar estilo normal despu√©s de 300ms
            QTimer.singleShot(300, self.update_block_style)
        else:
            # Restaurar estilo normal inmediatamente si no hubo √©xito
            self.update_block_style()

    def update_block_style(self):
        """Actualizar el estilo del bloque con el color personalizado"""
        self.setStyleSheet(f"""
            CategoryBlock {{
                background-color: #252525;
                border: 3px solid {self.custom_color};
                border-radius: 10px;
            }}
        """)

    def configure_category(self):
        """Abrir di√°logo para configurar color e icono de la categor√≠a"""
        dialog = CategoryConfigDialog(
            self.category_name, self.custom_color, self.custom_icon, self
        )
        if dialog.exec() == QDialog.DialogCode.Accepted:
            new_color, new_icon = dialog.get_config()
            self.custom_color = new_color
            self.custom_icon = new_icon

            # Actualizar UI
            self.category_label.setText(f"{self.custom_icon} {self.category_name}")
            self.header_widget.setStyleSheet(f"""
                QWidget {{
                    background-color: {self.custom_color};
                    border-radius: 8px;
                    padding: 5px;
                }}
            """)
            self.update_block_style()
            self.refresh_grid()  # Refrescar para actualizar separadores

            # Emitir se√±al para guardar cambios
            self.items_changed.emit()

    def delete_category(self):
        """Eliminar esta categor√≠a"""
        from PyQt6.QtWidgets import QMessageBox

        # Confirmar eliminaci√≥n
        reply = QMessageBox.question(
            self,
            "Eliminar Categor√≠a",
            f"¬øEst√°s seguro de que quieres eliminar la categor√≠a '{self.category_name}'?\n\n"
            f"Esta acci√≥n mover√° todos los elementos a 'Sin Categor√≠a' y no se puede deshacer.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Emitir se√±al para eliminar la categor√≠a
            self.category_deleted.emit(self.category_name)


class FlowLayout(QVBoxLayout):
    """Layout que organiza widgets en filas, ajust√°ndose autom√°ticamente al ancho disponible"""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setSpacing(15)
        self.setContentsMargins(10, 10, 10, 10)
        self.rows = []
        self.row_widgets = []
        self.items_per_row = 2  # Por defecto 2 bloques por fila

    def add_widget_flow(self, widget):
        """Agregar widget al flow layout"""
        # Si no hay filas o la √∫ltima fila est√° llena, crear nueva fila
        if not self.rows or len(self.row_widgets[-1]) >= self.items_per_row:
            row_widget = QWidget()
            row_layout = QHBoxLayout(row_widget)
            row_layout.setContentsMargins(0, 0, 0, 0)
            row_layout.setSpacing(15)
            row_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)

            self.addWidget(row_widget)
            self.rows.append(row_layout)
            self.row_widgets.append([])

        # Agregar widget a la √∫ltima fila con tama√±o fijo seg√∫n items_per_row
        widget.setMinimumWidth(550)  # Ancho m√≠nimo garantizado (aumentado de 450)

        # Si es el √∫nico en la fila, puede expandirse
        if self.items_per_row == 1:
            widget.setSizePolicy(
                QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum
            )
        else:
            # En filas con m√∫ltiples items, mantener tama√±o m√°s controlado
            widget.setSizePolicy(
                QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Minimum
            )

        self.rows[-1].addWidget(widget, 1)  # stretch=1 para distribuci√≥n equitativa
        self.row_widgets[-1].append(widget)

        # Agregar stretch al final de la fila si est√° completa
        if len(self.row_widgets[-1]) >= self.items_per_row:
            self.rows[-1].addStretch()

    def clear_flow(self):
        """Limpiar todos los widgets del layout"""
        while self.count():
            item = self.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        self.rows.clear()
        self.row_widgets.clear()

    def set_items_per_row(self, count):
        """Cambiar cu√°ntos items por fila"""
        self.items_per_row = max(1, count)

    def reflow(self):
        """Reorganizar todos los widgets seg√∫n el nuevo items_per_row"""
        # Guardar todos los widgets actuales
        all_widgets = []
        for row_list in self.row_widgets:
            all_widgets.extend(row_list)

        # Limpiar
        self.clear_flow()

        # Re-agregar
        for widget in all_widgets:
            if widget:
                self.add_widget_flow(widget)


class TaskCard(QWidget):
    """Tarjeta visual para mostrar una tarea con diferentes estilos"""

    task_updated = pyqtSignal(dict)  # Emite la tarea actualizada
    task_deleted = pyqtSignal(str)  # Emite el ID de la tarea eliminada
    selection_changed = pyqtSignal()  # Emite cuando cambia la selecci√≥n

    def __init__(self, task_data, parent=None):
        super().__init__(parent)
        self.task_data = task_data
        self.setup_ui()

    def setup_ui(self):
        """Configurar UI de la tarjeta de tarea"""
        self.setMinimumWidth(300)
        self.setMaximumWidth(600)
        self.setCursor(Qt.CursorShape.PointingHandCursor)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(6)

        # Color seg√∫n el estilo
        style_colors = {
            "urgent": "#ff5555",
            "important": "#ff9f43",
            "normal": "#4a90e2",
            "low": "#26de81",
            "completed": "#888888",
        }

        bg_color = style_colors.get(self.task_data.get("style", "normal"), "#4a90e2")

        # Header con checkboxes y botones
        header_layout = QHBoxLayout()

        # Checkbox para seleccionar (eliminar m√∫ltiple)
        self.select_checkbox = QCheckBox()
        self.select_checkbox.setChecked(False)
        self.select_checkbox.stateChanged.connect(lambda: self.selection_changed.emit())
        self.select_checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #ffffff;
                border-radius: 3px;
                background-color: rgba(255, 255, 255, 0.1);
            }
            QCheckBox::indicator:checked {
                background-color: #ff5555;
                border-color: #ff5555;
            }
        """)
        self.select_checkbox.setToolTip("Seleccionar para eliminar")
        header_layout.addWidget(self.select_checkbox)

        # Checkbox para completar
        self.check_btn = QCheckBox()
        self.check_btn.setChecked(self.task_data.get("completed", False))
        self.check_btn.stateChanged.connect(self.toggle_completed)
        self.check_btn.setStyleSheet("""
            QCheckBox::indicator {
                width: 20px;
                height: 20px;
                border: 2px solid #ffffff;
                border-radius: 4px;
                background-color: transparent;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;
                border-color: #4CAF50;
            }
        """)
        self.check_btn.setToolTip("Marcar como completada")
        header_layout.addWidget(self.check_btn)

        # Badge de prioridad
        priority_names = {
            "urgent": "URGENTE",
            "important": "IMPORTANTE",
            "normal": "NORMAL",
            "low": "BAJA",
            "completed": "COMPLETADA",
        }
        priority_badge = QLabel(
            priority_names.get(self.task_data.get("style", "normal"), "NORMAL")
        )
        priority_badge.setStyleSheet(f"""
            QLabel {{
                background-color: {bg_color};
                color: #ffffff;
                padding: 2px 8px;
                border-radius: 10px;
                font-size: 8pt;
                font-weight: bold;
            }}
        """)
        header_layout.addWidget(priority_badge)

        # T√≠tulo de la tarea
        self.title_label = QLabel(self.task_data.get("title", "Sin t√≠tulo"))
        title_style = (
            "text-decoration: line-through;"
            if self.task_data.get("completed", False)
            else ""
        )
        self.title_label.setStyleSheet(f"""
            QLabel {{
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                {title_style}
            }}
        """)
        self.title_label.setWordWrap(True)
        header_layout.addWidget(self.title_label, 1)

        # Botones de acci√≥n
        edit_btn = QPushButton("‚úèÔ∏è")
        edit_btn.setFixedSize(26, 26)
        edit_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        edit_btn.clicked.connect(self.edit_task)
        edit_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 4px;
                font-size: 10pt;
            }
        """)
        header_layout.addWidget(edit_btn)

        delete_btn = QPushButton("üóëÔ∏è")
        delete_btn.setFixedSize(26, 26)
        delete_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        delete_btn.clicked.connect(self.delete_task)
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 4px;
                font-size: 10pt;
            }
        """)
        header_layout.addWidget(delete_btn)

        layout.addLayout(header_layout)

        # Descripci√≥n
        if self.task_data.get("description"):
            desc_label = QLabel(self.task_data["description"])
            desc_label.setStyleSheet("""
                QLabel {
                    color: #ffffff;
                    font-size: 9pt;
                    padding: 2px;
                }
            """)
            desc_label.setWordWrap(True)
            layout.addWidget(desc_label)

        # Fecha si existe
        if self.task_data.get("due_date"):
            date_label = QLabel(f"üìÖ {self.task_data['due_date']}")
            date_label.setStyleSheet("""
                QLabel {
                    color: #ffffff;
                    font-size: 8pt;
                    font-style: italic;
                }
            """)
            layout.addWidget(date_label)

        # Estilo del card - Borde lateral con color de prioridad
        self.setStyleSheet(f"""
            TaskCard {{
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 {bg_color},
                    stop:0.02 {bg_color},
                    stop:0.02 #2a2a2a,
                    stop:1 #2a2a2a);
                border: 1px solid #c0c0c0;
                border-left: 5px solid {bg_color};
                border-radius: 6px;
            }}
            TaskCard:hover {{
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 {bg_color},
                    stop:0.02 {bg_color},
                    stop:0.02 #353535,
                    stop:1 #353535);
                border-left: 6px solid {bg_color};
            }}
        """)

    def toggle_completed(self, state):
        """Marcar/desmarcar tarea como completada"""
        self.task_data["completed"] = state == 2
        self.task_data["style"] = (
            "completed" if self.task_data["completed"] else "normal"
        )
        self.task_updated.emit(self.task_data)
        # Rehacer UI
        self.clear_layout()
        self.setup_ui()

    def edit_task(self):
        """Editar tarea"""
        dialog = TaskEditDialog(self.task_data, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.task_data = dialog.get_task_data()
            self.task_updated.emit(self.task_data)
            self.clear_layout()
            self.setup_ui()

    def delete_task(self):
        """Eliminar tarea"""
        reply = QMessageBox.question(
            self,
            "Confirmar eliminaci√≥n",
            f"¬øEliminar la tarea '{self.task_data.get('title', 'Sin t√≠tulo')}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )
        if reply == QMessageBox.StandardButton.Yes:
            self.task_deleted.emit(self.task_data["id"])

    def is_selected(self):
        """Verificar si la tarea est√° seleccionada"""
        return self.select_checkbox.isChecked()

    def clear_layout(self):
        """Limpiar el layout actual"""
        while self.layout().count():
            item = self.layout().takeAt(0)
            if item.widget():
                item.widget().deleteLater()


class TaskEditDialog(QDialog):
    """Di√°logo para crear/editar una tarea"""

    def __init__(self, task_data=None, parent=None):
        super().__init__(parent)
        self.task_data = task_data or {
            "id": str(uuid.uuid4()),
            "title": "",
            "description": "",
            "style": "normal",
            "completed": False,
            "due_date": "",
            "created": datetime.now().strftime("%Y-%m-%d %H:%M"),
        }
        self.setup_ui()

    def setup_ui(self):
        """Configurar interfaz del di√°logo"""
        self.setWindowTitle(
            "‚úèÔ∏è Editar Tarea" if self.task_data.get("title") else "‚ûï Nueva Tarea"
        )
        self.setMinimumWidth(450)
        self.setMaximumWidth(550)

        layout = QVBoxLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel("üìù T√≠tulo:")
        title_label.setStyleSheet("font-size: 10pt; font-weight: bold; color: #ffffff;")
        layout.addWidget(title_label)

        self.title_input = QLineEdit(self.task_data.get("title", ""))
        self.title_input.setPlaceholderText("Ingresa el t√≠tulo...")
        self.title_input.setStyleSheet("""
            QLineEdit {
                background-color: #ffffff;
                color: #333333;
                border: 2px solid #4a90e2;
                border-radius: 4px;
                padding: 6px;
                font-size: 10pt;
            }
        """)
        layout.addWidget(self.title_input)

        # Descripci√≥n
        desc_label = QLabel("üìÑ Descripci√≥n (opcional):")
        desc_label.setStyleSheet("font-size: 10pt; font-weight: bold; color: #ffffff;")
        layout.addWidget(desc_label)

        self.desc_input = QTextEdit(self.task_data.get("description", ""))
        self.desc_input.setPlaceholderText("Detalles...")
        self.desc_input.setMaximumHeight(80)
        self.desc_input.setStyleSheet("""
            QTextEdit {
                background-color: #ffffff;
                color: #333333;
                border: 2px solid #4a90e2;
                border-radius: 4px;
                padding: 6px;
                font-size: 9pt;
            }
        """)
        layout.addWidget(self.desc_input)

        # Fecha de vencimiento
        date_label = QLabel("üìÖ Fecha (opcional):")
        date_label.setStyleSheet("font-size: 10pt; font-weight: bold; color: #ffffff;")
        layout.addWidget(date_label)

        self.date_input = QLineEdit(self.task_data.get("due_date", ""))
        self.date_input.setPlaceholderText("Ej: 2025-12-31 o Viernes")
        self.date_input.setStyleSheet("""
            QLineEdit {
                background-color: #ffffff;
                color: #333333;
                border: 2px solid #4a90e2;
                border-radius: 4px;
                padding: 6px;
                font-size: 9pt;
            }
        """)
        layout.addWidget(self.date_input)

        # Estilo/Prioridad
        style_label = QLabel("üé® Prioridad:")
        style_label.setStyleSheet("font-size: 10pt; font-weight: bold; color: #ffffff;")
        layout.addWidget(style_label)

        style_layout = QHBoxLayout()
        style_layout.setSpacing(5)

        self.style_buttons = {}
        styles = [
            ("üî¥", "urgent", "#ff5555"),
            ("üü†", "important", "#ff9f43"),
            ("üîµ", "normal", "#4a90e2"),
            ("üü¢", "low", "#26de81"),
        ]

        for label, style_key, color in styles:
            btn = QPushButton(label)
            btn.setCheckable(True)
            btn.setChecked(self.task_data.get("style") == style_key)
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setFixedSize(50, 35)
            btn.clicked.connect(lambda checked, s=style_key: self.set_style(s))
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    color: #ffffff;
                    border: 2px solid {color};
                    border-radius: 4px;
                    font-size: 16pt;
                }}
                QPushButton:checked {{
                    border: 3px solid #ffffff;
                }}
            """)
            # Tooltip para saber qu√© significa cada color
            tooltips = {
                "urgent": "Urgente",
                "important": "Importante",
                "normal": "Normal",
                "low": "Baja",
            }
            btn.setToolTip(tooltips[style_key])
            style_layout.addWidget(btn)
            self.style_buttons[style_key] = btn

        style_layout.addStretch()
        layout.addLayout(style_layout)

        # Botones
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        cancel_btn = QPushButton("‚ùå Cancelar")
        cancel_btn.setFixedWidth(100)
        cancel_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        cancel_btn.clicked.connect(self.reject)
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: #ffffff;
                padding: 8px;
                border: none;
                border-radius: 4px;
                font-size: 10pt;
                font-weight: bold;
            }
        """)
        button_layout.addWidget(cancel_btn)

        save_btn = QPushButton("üíæ Guardar")
        save_btn.setFixedWidth(100)
        save_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        save_btn.clicked.connect(self.accept)
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: #ffffff;
                padding: 8px;
                border: none;
                border-radius: 4px;
                font-size: 10pt;
                font-weight: bold;
            }
        """)
        button_layout.addWidget(save_btn)

        layout.addLayout(button_layout)

    def set_style(self, style_key):
        """Establecer estilo seleccionado"""
        # Desmarcar otros botones
        for key, btn in self.style_buttons.items():
            btn.setChecked(key == style_key)
        self.task_data["style"] = style_key

    def get_task_data(self):
        """Obtener datos de la tarea"""
        self.task_data["title"] = self.title_input.text()
        self.task_data["description"] = self.desc_input.toPlainText()
        self.task_data["due_date"] = self.date_input.text()
        return self.task_data


class TasksTab(QWidget):
    """Widget para gestionar tareas con diferentes estilos"""

    tasks_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.tasks = []
        self.setup_ui()

    def setup_ui(self):
        """Configurar interfaz de la pesta√±a de tareas"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # Toolbar compacto
        toolbar = QWidget()
        toolbar.setFixedHeight(40)
        toolbar.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                border-bottom: 1px solid #4a90e2;
            }
        """)
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(8, 4, 8, 4)
        toolbar_layout.setSpacing(8)

        # T√≠tulo compacto
        title_label = QLabel("üìù")
        title_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 14pt;
                background: transparent;
            }
        """)
        toolbar_layout.addWidget(title_label)

        # Contador de tareas
        self.count_label = QLabel("0 tareas")
        self.count_label.setStyleSheet("""
            QLabel {
                color: #aaaaaa;
                font-size: 9pt;
            }
        """)
        toolbar_layout.addWidget(self.count_label)

        toolbar_layout.addStretch()

        # Bot√≥n eliminar seleccionadas
        self.delete_selected_btn = QPushButton("üóëÔ∏è")
        self.delete_selected_btn.setFixedSize(30, 30)
        self.delete_selected_btn.setToolTip("Eliminar tareas seleccionadas")
        self.delete_selected_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.delete_selected_btn.clicked.connect(self.delete_selected_tasks)
        self.delete_selected_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                font-size: 14pt;
            }
        """)
        self.delete_selected_btn.setVisible(False)
        toolbar_layout.addWidget(self.delete_selected_btn)

        # Bot√≥n nueva tarea compacto
        new_task_btn = QPushButton("‚ûï")
        new_task_btn.setFixedSize(30, 30)
        new_task_btn.setToolTip("Nueva Tarea")
        new_task_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        new_task_btn.clicked.connect(self.create_new_task)
        new_task_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                font-size: 14pt;
            }
        """)
        toolbar_layout.addWidget(new_task_btn)

        main_layout.addWidget(toolbar)

        # Splitter para dividir tareas y notas
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        self.splitter.setStyleSheet("""
            QSplitter::handle {
                background-color: #217346;
                width: 4px;
            }
        """)

        # ==== PANEL IZQUIERDO: TAREAS ====
        tasks_panel = QWidget()
        tasks_panel_layout = QVBoxLayout(tasks_panel)
        tasks_panel_layout.setContentsMargins(0, 0, 0, 0)

        # √Årea de scroll para las tareas
        tasks_scroll = QScrollArea()
        tasks_scroll.setWidgetResizable(True)
        tasks_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        tasks_scroll.setStyleSheet("""
            QScrollArea {
                background-color: #1a1a1a;
                border: none;
            }
            QScrollBar:vertical {
                background-color: #ffffff;
                width: 14px;
                border-radius: 7px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 7px;
                min-height: 30px;
            }
        """)

        # Widget contenedor de tareas
        self.tasks_container = QWidget()
        self.tasks_layout = QVBoxLayout(self.tasks_container)
        self.tasks_layout.setContentsMargins(10, 10, 10, 10)
        self.tasks_layout.setSpacing(10)
        self.tasks_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        tasks_scroll.setWidget(self.tasks_container)
        tasks_panel_layout.addWidget(tasks_scroll)

        # Mensaje inicial para tareas
        self.empty_label = QLabel(
            "üìù No hay tareas\n\n‚ûï Haz clic en 'Nueva Tarea' para empezar"
        )
        self.empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.empty_label.setStyleSheet("""
            QLabel {
                color: #888888;
                font-size: 16pt;
                padding: 50px;
            }
        """)
        self.tasks_layout.addWidget(self.empty_label)

        # ==== PANEL DERECHO: NOTAS ====
        self.notes_panel = NotesPanel(self)
        self.notes_panel.notes_changed.connect(self.tasks_changed.emit)

        # Agregar paneles al splitter
        self.splitter.addWidget(tasks_panel)
        self.splitter.addWidget(self.notes_panel)

        # Proporci√≥n inicial: 50% tareas, 50% notas
        self.splitter.setStretchFactor(0, 5)
        self.splitter.setStretchFactor(1, 5)

        main_layout.addWidget(self.splitter)

    def create_new_task(self):
        """Crear una nueva tarea"""
        dialog = TaskEditDialog(parent=self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            task_data = dialog.get_task_data()
            self.tasks.append(task_data)
            self.refresh_tasks()
            self.tasks_changed.emit()

    def refresh_tasks(self):
        """Refrescar visualizaci√≥n de tareas"""
        # Limpiar layout
        while self.tasks_layout.count():
            item = self.tasks_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Actualizar contador
        total = len(self.tasks)
        completed = sum(1 for t in self.tasks if t.get("completed", False))
        self.count_label.setText(f"{total} tareas ({completed} completadas)")

        # Mostrar mensaje si no hay tareas
        if not self.tasks:
            self.empty_label = QLabel(
                "üìù No hay tareas\n\n‚ûï Haz clic en 'Nueva Tarea' para empezar"
            )
            self.empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.empty_label.setStyleSheet("""
                QLabel {
                    color: #888888;
                    font-size: 16pt;
                    padding: 50px;
                }
            """)
            self.tasks_layout.addWidget(self.empty_label)
            return

        # Agregar tarjetas de tareas
        for task in self.tasks:
            card = TaskCard(task, self)
            card.task_updated.connect(self.update_task)
            card.task_deleted.connect(self.delete_task)
            card.selection_changed.connect(self.update_delete_button)
            self.tasks_layout.addWidget(card)

        # Actualizar visibilidad del bot√≥n eliminar
        self.update_delete_button()

    def update_task(self, task_data):
        """Actualizar una tarea"""
        for i, task in enumerate(self.tasks):
            if task["id"] == task_data["id"]:
                self.tasks[i] = task_data
                break
        self.refresh_tasks()
        self.tasks_changed.emit()

    def delete_task(self, task_id):
        """Eliminar una tarea"""
        self.tasks = [t for t in self.tasks if t["id"] != task_id]
        self.refresh_tasks()
        self.tasks_changed.emit()

    def delete_selected_tasks(self):
        """Eliminar todas las tareas seleccionadas"""
        # Obtener IDs de tareas seleccionadas
        selected_ids = []
        for i in range(self.tasks_layout.count()):
            widget = self.tasks_layout.itemAt(i).widget()
            if isinstance(widget, TaskCard) and widget.is_selected():
                selected_ids.append(widget.task_data["id"])

        if not selected_ids:
            return

        # Confirmar eliminaci√≥n
        reply = QMessageBox.question(
            self,
            "Confirmar eliminaci√≥n",
            f"¬øEliminar {len(selected_ids)} tarea(s) seleccionada(s)?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Eliminar tareas
            self.tasks = [t for t in self.tasks if t["id"] not in selected_ids]
            self.refresh_tasks()
            self.tasks_changed.emit()

    def update_delete_button(self):
        """Actualizar visibilidad del bot√≥n eliminar seg√∫n tareas seleccionadas"""
        has_selection = False
        for i in range(self.tasks_layout.count()):
            widget = self.tasks_layout.itemAt(i).widget()
            if isinstance(widget, TaskCard) and widget.is_selected():
                has_selection = True
                break

        self.delete_selected_btn.setVisible(has_selection)

    def get_tasks(self):
        """Obtener lista de tareas"""
        return self.tasks.copy()

    def set_tasks(self, tasks):
        """Establecer lista de tareas"""
        self.tasks = tasks
        self.refresh_tasks()

    def get_notes(self):
        """Obtener lista de notas desde el panel de notas"""
        return self.notes_panel.get_notes()

    def set_notes(self, notes):
        """Establecer lista de notas en el panel de notas"""
        self.notes_panel.set_notes(notes)

    def get_splitter_state(self):
        """Obtener estado del splitter (distribuci√≥n tareas/notas)"""
        return self.splitter.saveState().toHex().data().decode()

    def set_splitter_state(self, state_hex):
        """Restaurar estado del splitter"""
        try:
            if state_hex:
                state_bytes = bytes.fromhex(state_hex)
                self.splitter.restoreState(state_bytes)
        except Exception as e:
            print(f"Error restaurando splitter: {e}")


class NoteCard(QWidget):
    """Tarjeta visual para mostrar una nota en la lista"""

    note_selected = pyqtSignal(dict)  # Emite la nota seleccionada
    note_deleted = pyqtSignal(str)  # Emite el ID de la nota eliminada

    def __init__(self, note_data, parent=None):
        super().__init__(parent)
        self.note_data = note_data
        self.is_note_selected = False
        self.setup_ui()

    def set_selected(self, selected):
        """Marcar esta nota como seleccionada visualmente"""
        self.is_note_selected = selected
        self.update_selection_style()

    def setup_ui(self):
        """Configurar UI de la tarjeta de nota - formato cuadrado con icono"""
        self.setFixedSize(110, 130)
        self.setCursor(Qt.CursorShape.PointingHandCursor)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(5)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Obtener icono y color personalizados
        icon = self.note_data.get("icon", "üìå")
        color = self.note_data.get("color", "#ffd633")

        # Calcular color m√°s claro para gradiente
        import re

        if color.startswith("#"):
            r = int(color[1:3], 16)
            g = int(color[3:5], 16)
            b = int(color[5:7], 16)
            r_light = min(255, r + 30)
            g_light = min(255, g + 30)
            b_light = min(255, b + 30)
            color_light = f"#{r_light:02x}{g_light:02x}{b_light:02x}"
        else:
            color_light = color

        # No hay bot√≥n eliminar - se usa men√∫ contextual

        # Icono grande (emoji de nota personalizado)
        self.icon_label = QLabel(icon)
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.icon_label.setStyleSheet("""
            QLabel {
                font-size: 48pt;
                padding: 10px;
                background: transparent;
            }
        """)
        layout.addWidget(self.icon_label)

        # T√≠tulo de la nota
        title = self.note_data.get("title", "Sin t√≠tulo")
        if len(title) > 14:
            title = title[:12] + "..."

        self.title_label = QLabel(title)
        self.title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.title_label.setWordWrap(True)
        self.title_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 10pt;
                font-weight: bold;
                background: transparent;
            }
        """)
        layout.addWidget(self.title_label)

        # Guardar colores para actualizar el estilo despu√©s
        self.color = color
        self.color_light = color_light
        self.update_selection_style()

    def update_selection_style(self):
        """Actualizar el estilo seg√∫n si est√° seleccionada"""
        # Recalcular colores si el color cambi√≥
        if hasattr(self, "note_data"):
            color = self.note_data.get("color", "#ffd633")
            if color != getattr(self, "color", color):
                # Color cambi√≥, recalcular
                import re

                if color.startswith("#"):
                    r = int(color[1:3], 16)
                    g = int(color[3:5], 16)
                    b = int(color[5:7], 16)
                    r_light = min(255, r + 30)
                    g_light = min(255, g + 30)
                    b_light = min(255, b + 30)
                    self.color_light = f"#{r_light:02x}{g_light:02x}{b_light:02x}"
                    self.color = color
                else:
                    self.color = color
                    self.color_light = color

        # Estilo del card - Transparente con borde de selecci√≥n en color personalizado
        if self.is_note_selected:
            border_style = f"border: 4px solid {self.color};"
        else:
            border_style = "border: 2px solid rgba(255, 255, 255, 0.1);"

        self.setStyleSheet(f"""
            NoteCard {{
                background: rgba(42, 42, 42, 0.6);
                {border_style}
                border-radius: 12px;
            }}
            NoteCard:hover {{
                background: rgba(58, 58, 58, 0.8);
                border: 3px solid {self.color};
            }}
        """)

    def mousePressEvent(self, event):
        """Manejar click para seleccionar la nota o mostrar men√∫"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.note_selected.emit(self.note_data)
        elif event.button() == Qt.MouseButton.RightButton:
            self.show_context_menu(event.globalPosition().toPoint())
        super().mousePressEvent(event)

    def show_context_menu(self, pos):
        """Mostrar men√∫ contextual con opciones"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 2px solid #4a90e2;
                border-radius: 6px;
                padding: 5px;
            }
            QMenu::item {
                color: #ffffff;
                padding: 8px 25px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
        """)

        # Acci√≥n de eliminar
        delete_action = menu.addAction("üóëÔ∏è Eliminar nota")
        delete_action.triggered.connect(
            lambda: self.note_deleted.emit(self.note_data["id"])
        )

        menu.exec(pos)


class NotesPanel(QWidget):
    """Panel de notas a la derecha de las tareas"""

    notes_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.notes = []
        self.current_note = None
        self.setup_ui()

    def setup_ui(self):
        """Configurar interfaz del panel de notas"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Header del panel compacto
        header = QWidget()
        header.setFixedHeight(40)
        header.setStyleSheet("""
            QWidget {
                background-color: #ffffff;
                border-bottom: 1px solid #ffa500;
            }
        """)
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(8, 4, 8, 4)

        # T√≠tulo
        title_label = QLabel("üìì")
        title_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 14pt;
            }
        """)
        header_layout.addWidget(title_label)

        header_layout.addStretch()

        # Bot√≥n nueva nota
        new_note_btn = QPushButton("‚ûï")
        new_note_btn.setFixedSize(30, 30)
        new_note_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        new_note_btn.setToolTip("Nueva nota")
        new_note_btn.clicked.connect(self.create_new_note)
        new_note_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffa500;
                color: #ffffff;
                border: none;
                border-radius: 4px;
                font-size: 14pt;
            }
        """)
        header_layout.addWidget(new_note_btn)

        layout.addWidget(header)

        # Splitter vertical: lista arriba, editor abajo
        v_splitter = QSplitter(Qt.Orientation.Vertical)
        v_splitter.setStyleSheet("""
            QSplitter::handle {
                background-color: #ffa500;
                height: 3px;
            }
        """)

        # ==== LISTA DE NOTAS ====
        notes_list_widget = QWidget()
        notes_list_layout = QVBoxLayout(notes_list_widget)
        notes_list_layout.setContentsMargins(0, 0, 0, 0)

        # Scroll para lista de notas
        self.notes_scroll = QScrollArea()
        self.notes_scroll.setWidgetResizable(True)
        self.notes_scroll.setHorizontalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAlwaysOff
        )
        self.notes_scroll.setStyleSheet("""
            QScrollArea {
                background-color: #1a1a1a;
                border: none;
            }
            QScrollBar:vertical {
                background-color: #ffffff;
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #ffa500;
                border-radius: 6px;
                min-height: 20px;
            }
        """)

        # Contenedor de notas - Grid layout para iconos
        self.notes_container = QWidget()
        self.notes_list_layout = QGridLayout(self.notes_container)
        self.notes_list_layout.setContentsMargins(10, 10, 10, 10)
        self.notes_list_layout.setSpacing(10)
        self.notes_list_layout.setAlignment(
            Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignLeft
        )

        self.notes_scroll.setWidget(self.notes_container)
        notes_list_layout.addWidget(self.notes_scroll)

        # ==== EDITOR DE NOTA ====
        editor_widget = QWidget()
        editor_layout = QVBoxLayout(editor_widget)
        editor_layout.setContentsMargins(8, 8, 8, 8)
        editor_layout.setSpacing(8)

        # Selector de icono y color
        style_layout = QHBoxLayout()

        # Label
        style_label = QLabel("Estilo:")
        style_label.setStyleSheet("color: #ffffff; font-size: 10pt; font-weight: bold;")
        style_layout.addWidget(style_label)

        # Selector de icono
        self.icon_buttons = {}
        icons = ["üìå", "üìù", "üí°", "‚≠ê", "‚ù§Ô∏è", "üìã", "‚úÖ", "‚ö†Ô∏è", "üî•", "üéØ"]
        for icon in icons:
            btn = QPushButton(icon)
            btn.setFixedSize(30, 30)
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setCheckable(True)
            btn.clicked.connect(lambda checked, i=icon: self.change_icon(i))
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #ffffff;
                    border: 2px solid #3a3a3a;
                    border-radius: 4px;
                    font-size: 14pt;
                }
                QPushButton:checked {
                    border: 2px solid #ffa500;
                    background-color: #3a3a3a;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            style_layout.addWidget(btn)
            self.icon_buttons[icon] = btn

        style_layout.addStretch()

        # Selector de color
        colors = [
            ("#ffd633", "Amarillo"),
            ("#ff9ff3", "Rosa"),
            ("#a8e6cf", "Verde"),
            ("#ffc4a3", "Naranja"),
            ("#a3d8ff", "Azul"),
            ("#dda3ff", "Morado"),
        ]
        self.color_buttons = {}
        for color, name in colors:
            btn = QPushButton("")
            btn.setFixedSize(25, 25)
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.setCheckable(True)
            btn.setToolTip(name)
            btn.clicked.connect(lambda checked, c=color: self.change_color(c))
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    border: 2px solid #3a3a3a;
                    border-radius: 12px;
                }}
                QPushButton:checked {{
                    border: 3px solid #ffffff;
                }}
                QPushButton:hover {{
                    border: 2px solid #ffa500;
                }}
            """)
            style_layout.addWidget(btn)
            self.color_buttons[color] = btn

        # Bot√≥n para color personalizado
        custom_color_btn = QPushButton("üé®")
        custom_color_btn.setFixedSize(30, 30)
        custom_color_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        custom_color_btn.setToolTip("Color personalizado")
        custom_color_btn.clicked.connect(self.pick_custom_color)
        custom_color_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                    stop:0 #ff0000, stop:0.16 #ffff00, stop:0.33 #00ff00,
                    stop:0.5 #00ffff, stop:0.66 #0000ff, stop:0.83 #ff00ff,
                    stop:1 #ff0000);
                border: 2px solid #3a3a3a;
                border-radius: 4px;
                font-size: 12pt;
            }
            QPushButton:hover {
                border: 2px solid #ffa500;
            }
        """)
        style_layout.addWidget(custom_color_btn)

        editor_layout.addLayout(style_layout)

        # Campo de t√≠tulo
        self.title_input = QLineEdit()
        self.title_input.setPlaceholderText("T√≠tulo de la nota...")
        self.title_input.textChanged.connect(self.on_note_edited)
        self.title_input.setStyleSheet("""
            QLineEdit {
                background-color: #ffffff;
                color: #333333;
                border: 2px solid #ffa500;
                border-radius: 4px;
                padding: 8px;
                font-size: 11pt;
                font-weight: bold;
            }
        """)
        editor_layout.addWidget(self.title_input)

        # √Årea de texto para contenido
        self.content_editor = QTextEdit()
        self.content_editor.setPlaceholderText("Escribe aqu√≠ tus notas...")
        self.content_editor.textChanged.connect(self.on_note_edited)
        self.content_editor.setStyleSheet("""
            QTextEdit {
                background-color: #ffffff;
                color: #333333;
                border: 2px solid #ffa500;
                border-radius: 4px;
                padding: 8px;
                font-size: 10pt;
            }
        """)
        editor_layout.addWidget(self.content_editor)

        # Agregar widgets al splitter
        v_splitter.addWidget(notes_list_widget)
        v_splitter.addWidget(editor_widget)

        # Proporci√≥n: 40% lista, 60% editor
        v_splitter.setStretchFactor(0, 4)
        v_splitter.setStretchFactor(1, 6)

        layout.addWidget(v_splitter)

        # Mensaje inicial
        self.show_empty_message()

    def show_empty_message(self):
        """Mostrar mensaje cuando no hay notas"""
        empty_label = QLabel("üìì No hay notas\n\n‚ûï Crea una nota para empezar")
        empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        empty_label.setStyleSheet("""
            QLabel {
                color: #888888;
                font-size: 14pt;
                padding: 30px;
            }
        """)
        self.notes_list_layout.addWidget(empty_label, 0, 0, 1, -1)  # Span all columns

    def create_new_note(self):
        """Crear una nueva nota"""
        new_note = {
            "id": str(uuid.uuid4()),
            "title": "Nueva Nota",
            "content": "",
            "icon": "üìå",  # Icono por defecto
            "color": "#ffd633",  # Color por defecto (amarillo)
            "created": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "modified": datetime.now().strftime("%Y-%m-%d %H:%M"),
        }
        self.notes.append(new_note)
        self.refresh_notes_list()
        self.select_note(new_note)
        self.notes_changed.emit()

        # Enfocar el t√≠tulo para editar
        self.title_input.selectAll()
        self.title_input.setFocus()

    def refresh_notes_list(self):
        """Refrescar la lista de notas en formato grid"""
        # Guardar ID de nota seleccionada
        selected_id = self.current_note["id"] if self.current_note else None

        # Limpiar lista
        while self.notes_list_layout.count():
            item = self.notes_list_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Mostrar mensaje si no hay notas
        if not self.notes:
            self.show_empty_message()
            return

        # Agregar tarjetas de notas en formato grid
        # Calcular columnas basado en ancho (cada card es 110px + 10px spacing)
        columns = max(2, (self.notes_scroll.width() - 20) // 120)

        row = 0
        col = 0
        for note in reversed(self.notes):  # M√°s reciente primero
            card = NoteCard(note, self)
            card.note_selected.connect(self.select_note)
            card.note_deleted.connect(self.delete_note)

            # Marcar como seleccionada si corresponde
            if selected_id and note["id"] == selected_id:
                card.set_selected(True)

            self.notes_list_layout.addWidget(card, row, col)

            col += 1
            if col >= columns:
                col = 0
                row += 1

    def select_note(self, note_data):
        """Seleccionar y mostrar una nota en el editor"""
        # Guardar nota anterior si hab√≠a cambios
        if self.current_note:
            self.save_current_note(refresh_list=False, emit_signal=True)

        # Desmarcar todas las notas visualmente y actualizar sus colores
        for i in range(self.notes_list_layout.count()):
            item = self.notes_list_layout.itemAt(i)
            if item and item.widget() and isinstance(item.widget(), NoteCard):
                widget = item.widget()
                widget.set_selected(False)
                # Forzar actualizaci√≥n de color
                widget.update_selection_style()

        # Marcar la nota seleccionada
        for i in range(self.notes_list_layout.count()):
            item = self.notes_list_layout.itemAt(i)
            if item and item.widget() and isinstance(item.widget(), NoteCard):
                if item.widget().note_data["id"] == note_data["id"]:
                    item.widget().set_selected(True)
                    break

        # Cargar nueva nota
        self.current_note = note_data
        self.title_input.blockSignals(True)
        self.content_editor.blockSignals(True)

        self.title_input.setText(note_data.get("title", ""))
        self.content_editor.setPlainText(note_data.get("content", ""))

        # Asegurar valores por defecto
        if "icon" not in note_data:
            note_data["icon"] = "üìå"
        if "color" not in note_data:
            note_data["color"] = "#ffd633"

        # Actualizar botones de icono
        for icon, btn in self.icon_buttons.items():
            btn.setChecked(icon == note_data.get("icon", "üìå"))

        # Actualizar botones de color
        for color, btn in self.color_buttons.items():
            btn.setChecked(color == note_data.get("color", "#ffd633"))

        self.title_input.blockSignals(False)
        self.content_editor.blockSignals(False)

        # Habilitar editor
        self.title_input.setEnabled(True)
        self.content_editor.setEnabled(True)

    def change_icon(self, icon):
        """Cambiar icono de la nota actual"""
        if not self.current_note:
            return

        # Desmarcar otros botones
        for i, btn in self.icon_buttons.items():
            btn.setChecked(i == icon)

        # Actualizar nota
        self.current_note["icon"] = icon
        self.save_current_note(refresh_list=True, emit_signal=True)

    def change_color(self, color):
        """Cambiar color de la nota actual"""
        if not self.current_note:
            return

        # Desmarcar otros botones
        for c, btn in self.color_buttons.items():
            btn.setChecked(c == color)

        # Actualizar nota
        self.current_note["color"] = color
        self.save_current_note(refresh_list=True, emit_signal=True)

    def pick_custom_color(self):
        """Seleccionar un color personalizado"""
        if not self.current_note:
            return

        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor

        # Color actual
        current_color = QColor(self.current_note.get("color", "#ffd633"))

        # Abrir selector de color
        color = QColorDialog.getColor(current_color, self, "Seleccionar Color de Fondo")

        if color.isValid():
            # Desmarcar todos los botones predefinidos
            for btn in self.color_buttons.values():
                btn.setChecked(False)

            # Aplicar el color personalizado
            hex_color = color.name()
            self.current_note["color"] = hex_color
            self.save_current_note(refresh_list=True, emit_signal=True)

    def on_note_edited(self):
        """Manejar edici√≥n de la nota actual"""
        if self.current_note:
            # Actualizar autom√°ticamente (auto-guardado)
            self.save_current_note(emit_signal=True)

    def save_current_note(self, refresh_list=False, emit_signal=False):
        """Guardar la nota actual"""
        if not self.current_note:
            return

        # Actualizar datos
        self.current_note["title"] = self.title_input.text() or "Sin t√≠tulo"
        self.current_note["content"] = self.content_editor.toPlainText()
        self.current_note["modified"] = datetime.now().strftime("%Y-%m-%d %H:%M")

        # Actualizar en la lista
        for i, note in enumerate(self.notes):
            if note["id"] == self.current_note["id"]:
                self.notes[i] = self.current_note
                break

        # Solo refrescar lista visual si se solicita expl√≠citamente
        if refresh_list:
            self.refresh_notes_list()

        # Solo emitir se√±al si se solicita (para evitar bucles infinitos en get_notes)
        if emit_signal:
            self.notes_changed.emit()

    def delete_note(self, note_id):
        """Eliminar una nota"""
        # Eliminar de la lista
        self.notes = [n for n in self.notes if n["id"] != note_id]

        # Limpiar editor si era la nota actual
        if self.current_note and self.current_note["id"] == note_id:
            self.current_note = None
            self.title_input.clear()
            self.content_editor.clear()
            self.title_input.setEnabled(False)
            self.content_editor.setEnabled(False)

        self.refresh_notes_list()
        self.notes_changed.emit()

    def get_notes(self):
        """Obtener lista de notas"""
        # Guardar nota actual antes de exportar
        if self.current_note:
            self.save_current_note()
        return self.notes.copy()

    def set_notes(self, notes):
        """Establecer lista de notas"""
        self.notes = notes
        self.refresh_notes_list()

        # Habilitar/deshabilitar editor
        if not notes:
            self.title_input.setEnabled(False)
            self.content_editor.setEnabled(False)


class DirectoryManagerTab(QWidget):
    """Widget para gestionar directorios y archivos favoritos organizados por categor√≠as"""

    directory_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        # Estructura: {categoria_nombre: [lista_de_paths]}
        self.categories = {"Sin Categor√≠a": []}
        self.layout_mode = "auto"  # auto, vertical, horizontal, grid
        self.setup_ui()

        # Habilitar drag and drop
        self.setAcceptDrops(True)

        # Conectar evento de resize para adaptar layout
        self.resize_timer = QTimer()
        self.resize_timer.setSingleShot(True)
        self.resize_timer.timeout.connect(self.adapt_layout_to_size)
        self.resize_timer.setInterval(300)

    def setup_ui(self):
        """Configurar la interfaz del gestor de directorios"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # T√≠tulo y descripci√≥n
        header_layout = QVBoxLayout()

        title_label = QLabel("üìÇ Archivos y Carpetas Favoritos")
        title_label.setStyleSheet("""
            QLabel {
                font-size: 24px;
                font-weight: bold;
                color: #4a90e2;
                padding: 10px;
            }
        """)
        header_layout.addWidget(title_label)

        description_label = QLabel(
            "Organiza tus archivos y carpetas favoritos en categor√≠as personalizadas.\n"
            "Arrastra archivos/carpetas a cualquier categor√≠a o usa los botones.\n"
            "Haz doble clic para abrir | Arrastra entre categor√≠as para mover."
        )
        description_label.setStyleSheet("""
            QLabel {
                font-size: 12px;
                color: #cccccc;
                padding: 0 10px 10px 10px;
            }
        """)
        description_label.setWordWrap(True)
        header_layout.addWidget(description_label)

        layout.addLayout(header_layout)

        # Botones de acci√≥n
        button_layout = QHBoxLayout()

        self.add_dir_btn = QPushButton("‚ûï Agregar Carpeta")
        self.add_dir_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
            QPushButton:pressed {
                background-color: #2868a8;
            }
        """)
        self.add_dir_btn.clicked.connect(self.add_directory)
        button_layout.addWidget(self.add_dir_btn)

        self.add_file_btn = QPushButton("‚ûï Agregar Archivo")
        self.add_file_btn.setStyleSheet("""
            QPushButton {
                background-color: #27ae60;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #229954;
            }
            QPushButton:pressed {
                background-color: #1e8449;
            }
        """)
        self.add_file_btn.clicked.connect(self.add_file)
        button_layout.addWidget(self.add_file_btn)

        self.new_category_btn = QPushButton("üìÅ Nueva Categor√≠a")
        self.new_category_btn.setStyleSheet("""
            QPushButton {
                background-color: #9b59b6;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #8e44ad;
            }
            QPushButton:pressed {
                background-color: #7d3c98;
            }
        """)
        self.new_category_btn.clicked.connect(self.create_new_category)
        button_layout.addWidget(self.new_category_btn)

        self.remove_dir_btn = QPushButton("üóëÔ∏è Eliminar Seleccionado")
        self.remove_dir_btn.setStyleSheet("""
            QPushButton {
                background-color: #e74c3c;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #c0392b;
            }
            QPushButton:pressed {
                background-color: #a93226;
            }
        """)
        self.remove_dir_btn.clicked.connect(self.remove_selected_directory)
        button_layout.addWidget(self.remove_dir_btn)

        self.clear_all_btn = QPushButton("üßπ Limpiar Todo")
        self.clear_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #95a5a6;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #7f8c8d;
            }
            QPushButton:pressed {
                background-color: #6c7a7b;
            }
        """)
        self.clear_all_btn.clicked.connect(self.clear_all_directories)
        button_layout.addWidget(self.clear_all_btn)

        button_layout.addStretch()
        layout.addLayout(button_layout)

        # Barra de herramientas de visualizaci√≥n
        view_toolbar_layout = QHBoxLayout()
        view_toolbar_layout.setContentsMargins(10, 10, 10, 5)

        view_label = QLabel("üëÅÔ∏è Vista:")
        view_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                padding: 5px;
            }
        """)
        view_toolbar_layout.addWidget(view_label)

        # Contador de elementos totales
        self.items_count_label = QLabel("0 elementos totales")
        self.items_count_label.setStyleSheet("""
            QLabel {
                color: #cccccc;
                font-size: 11pt;
                padding: 5px 10px;
                font-weight: bold;
            }
        """)
        view_toolbar_layout.addWidget(self.items_count_label)

        view_toolbar_layout.addStretch()

        # Selector de modo de layout
        layout_label = QLabel("üìê Disposici√≥n:")
        layout_label.setStyleSheet("""
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
        """)
        view_toolbar_layout.addWidget(layout_label)

        self.layout_combo = QComboBox()
        self.layout_combo.addItem("üîÑ Auto (Responsive)", "auto")
        self.layout_combo.addItem("üìã Vertical (1 columna)", "vertical")
        self.layout_combo.addItem("‚¨å Horizontal (2 columnas)", "horizontal")
        self.layout_combo.addItem("‚äû Grid (3+ columnas)", "grid")
        self.layout_combo.currentIndexChanged.connect(self.change_layout_mode)
        self.layout_combo.setFixedWidth(200)
        self.layout_combo.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-size: 10pt;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
            }
        """)
        view_toolbar_layout.addWidget(self.layout_combo)

        # Bot√≥n para expandir/colapsar todo
        self.toggle_all_btn = QPushButton("üìã Expandir Todo")
        self.toggle_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 15px;
                font-size: 10pt;
            }
            QPushButton:hover {
                border: 1px solid #4a90e2;
                background-color: #3a3a3a;
            }
        """)
        self.toggle_all_btn.clicked.connect(self.toggle_all_categories)
        view_toolbar_layout.addWidget(self.toggle_all_btn)

        layout.addLayout(view_toolbar_layout)

        # Contenedor principal con scroll para los bloques de categor√≠as
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setMinimumWidth(
            600
        )  # Ancho m√≠nimo para evitar compresi√≥n excesiva
        self.scroll_area.setHorizontalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAlwaysOff
        )
        self.scroll_area.setVerticalScrollBarPolicy(
            Qt.ScrollBarPolicy.ScrollBarAsNeeded
        )
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                background-color: #1a1a1a;
                border: none;
            }
            QScrollBar:vertical {
                background-color: #ffffff;
                width: 14px;
                border-radius: 7px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 7px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5aa0f2;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)

        # Widget contenedor de bloques con FlowLayout
        self.blocks_container = QWidget()
        self.blocks_layout = FlowLayout(self.blocks_container)
        self.blocks_container.setLayout(self.blocks_layout)

        self.scroll_area.setWidget(self.blocks_container)
        layout.addWidget(self.scroll_area, 1)

        # Diccionario para mantener referencias a los bloques de categor√≠as
        self.category_blocks = {}

        # Informaci√≥n
        info_label = QLabel(
            "üí° Tip: Doble clic para abrir | Arrastra para mover | Click derecho para m√°s opciones | Click en categor√≠a para colapsar | Tarjetas m√°s grandes para mejor visualizaci√≥n"
        )
        info_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                color: #888888;
                padding: 10px;
                font-style: italic;
            }
        """)
        info_label.setWordWrap(True)
        info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(info_label)

        # Cargar categor√≠as iniciales
        self.refresh_blocks()

    def toggle_all_categories(self):
        """Expandir o colapsar todas las categor√≠as"""
        if not self.category_blocks:
            return

        # Verificar si hay alguna colapsada
        any_collapsed = any(
            block.is_collapsed for block in self.category_blocks.values()
        )

        # Si hay alguna colapsada, expandir todas; si no, colapsar todas
        for block in self.category_blocks.values():
            if any_collapsed and block.is_collapsed:
                block.toggle_collapse()
            elif not any_collapsed and not block.is_collapsed:
                block.toggle_collapse()

        # Actualizar texto del bot√≥n
        if any_collapsed:
            self.toggle_all_btn.setText("üìã Colapsar Todo")
        else:
            self.toggle_all_btn.setText("üìã Expandir Todo")

    def change_layout_mode(self):
        """Cambiar el modo de disposici√≥n de categor√≠as"""
        self.layout_mode = self.layout_combo.currentData()
        self.adapt_layout_to_size()

    def adapt_layout_to_size(self):
        """Adaptar el layout seg√∫n el tama√±o de la ventana y el modo seleccionado"""
        width = self.scroll_area.width()

        # Ancho m√≠nimo por bloque: 550px + 15px spacing
        min_block_width = 565

        if self.layout_mode == "vertical":
            # 1 columna
            items_per_row = 1
        elif self.layout_mode == "horizontal":
            # 2 columnas si hay espacio suficiente, sino 1
            if width >= min_block_width * 2:
                items_per_row = 2
            else:
                items_per_row = 1
        elif self.layout_mode == "grid":
            # 3+ columnas seg√∫n ancho, respetando m√≠nimo
            max_cols = max(1, width // min_block_width)
            if max_cols >= 4:
                items_per_row = 4
            elif max_cols >= 3:
                items_per_row = 3
            elif max_cols >= 2:
                items_per_row = 2
            else:
                items_per_row = 1
        else:  # auto (responsive)
            # Calcular autom√°ticamente seg√∫n ancho real disponible
            max_cols = max(1, width // min_block_width)
            items_per_row = min(max_cols, 4)  # M√°ximo 4 columnas

        # Aplicar el nuevo layout si cambi√≥
        if self.blocks_layout.items_per_row != items_per_row:
            self.blocks_layout.set_items_per_row(items_per_row)
            self.blocks_layout.reflow()

    def resizeEvent(self, event):
        """Manejar redimensionamiento de la ventana"""
        super().resizeEvent(event)
        if self.layout_mode in ["auto", "grid"]:
            # Iniciar timer para evitar m√∫ltiples rec√°lculos durante resize
            self.resize_timer.start()

    def refresh_blocks(self):
        """Refrescar los bloques visuales de categor√≠as"""
        # Limpiar bloques existentes
        self.blocks_layout.clear_flow()
        self.category_blocks.clear()

        # Calcular total de elementos
        total_items = 0
        for category_data in self.categories.values():
            if isinstance(category_data, list):
                total_items += len(category_data)
            elif isinstance(category_data, dict):
                total_items += len(category_data.get("paths", []))

        # Actualizar contador de elementos totales
        if total_items == 0:
            self.items_count_label.setText("0 elementos totales")
        elif total_items == 1:
            self.items_count_label.setText("1 elemento total")
        else:
            self.items_count_label.setText(f"{total_items} elementos totales")

        # Ordenar categor√≠as (Sin Categor√≠a primero, luego alfab√©ticamente)
        sorted_categories = sorted(
            self.categories.keys(), key=lambda x: (x != "Sin Categor√≠a", x)
        )

        # Crear un bloque para cada categor√≠a
        for category_name in sorted_categories:
            category_data = self.categories[category_name]

            # Extraer datos seg√∫n el formato
            if isinstance(category_data, list):
                # Formato antiguo: solo rutas
                paths = category_data
                color = "#4a90e2"
                icon = "üìÅ"
            elif isinstance(category_data, dict):
                # Formato nuevo con metadatos
                paths = category_data.get("paths", [])
                color = category_data.get("color", "#4a90e2")
                icon = category_data.get("icon", "üìÅ")
            else:
                paths = []
                color = "#4a90e2"
                icon = "üìÅ"

            # Crear bloque de categor√≠a con color e icono personalizados
            block = CategoryBlock(
                category_name, self, custom_color=color, custom_icon=icon
            )

            # Agregar items al bloque
            for path in paths:
                block.add_item(path)

            # Conectar se√±al de cambios
            block.items_changed.connect(self.on_block_items_changed)
            # Conectar se√±al de eliminaci√≥n de categor√≠a
            block.category_deleted.connect(self.delete_category)

            # Agregar bloque al layout usando FlowLayout
            self.blocks_layout.add_widget_flow(block)
            self.category_blocks[category_name] = block

        # Si no hay categor√≠as, mostrar mensaje
        if not self.categories or total_items == 0:
            empty_label = QLabel(
                "üìÇ No hay archivos favoritos\n\n Arrastra archivos aqu√≠ o usa los botones de arriba para agregar"
            )
            empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            empty_label.setStyleSheet("""
                QLabel {
                    color: #888888;
                    font-size: 16pt;
                    padding: 50px;
                }
            """)
            self.blocks_layout.add_widget_flow(empty_label)

        # Adaptar layout al tama√±o actual
        self.adapt_layout_to_size()

    def on_block_items_changed(self):
        """Manejar cambios en los items de un bloque"""
        # Actualizar estructura de categor√≠as manteniendo metadatos
        for category_name, block in self.category_blocks.items():
            # Obtener datos actuales (o crear nuevos si no existen)
            if category_name in self.categories and isinstance(
                self.categories[category_name], dict
            ):
                # Mantener color e icono existentes
                self.categories[category_name]["paths"] = block.items.copy()
                # Actualizar color e icono por si cambiaron
                self.categories[category_name]["color"] = block.custom_color
                self.categories[category_name]["icon"] = block.custom_icon
            else:
                # Crear nuevo formato con metadatos
                self.categories[category_name] = {
                    "paths": block.items.copy(),
                    "color": block.custom_color,
                    "icon": block.custom_icon,
                }

        # Calcular total
        total_items = 0
        for category_data in self.categories.values():
            if isinstance(category_data, list):
                total_items += len(category_data)
            elif isinstance(category_data, dict):
                total_items += len(category_data.get("paths", []))

        # Actualizar contador
        if total_items == 0:
            self.items_count_label.setText("0 elementos totales")
        elif total_items == 1:
            self.items_count_label.setText("1 elemento total")
        else:
            self.items_count_label.setText(f"{total_items} elementos totales")

        # Emitir se√±al de cambio
        self.directory_changed.emit()

    def create_new_category(self):
        """Crear una nueva categor√≠a"""
        from PyQt6.QtWidgets import QInputDialog

        category_name, ok = QInputDialog.getText(
            self, "Nueva Categor√≠a", "Nombre de la categor√≠a:"
        )

        if ok and category_name:
            if category_name in self.categories:
                QMessageBox.warning(
                    self,
                    "Categor√≠a Existente",
                    f"La categor√≠a '{category_name}' ya existe.",
                )
                return

            self.categories[category_name] = []
            self.refresh_blocks()
            self.directory_changed.emit()

            if hasattr(self.parent(), "statusBar"):
                self.parent().statusBar().showMessage(
                    f"‚úÖ Categor√≠a '{category_name}' creada", 3000
                )

    def extract_category_name(self, text):
        """Extraer el nombre de la categor√≠a del texto del item"""
        # Formato: "üìÅ Nombre Categor√≠a (contador)"
        # Remover emoji al inicio
        if " " in text:
            text = text.split(" ", 1)[1]
        # Remover contador al final
        if "(" in text and text.endswith(")"):
            text = text.rsplit("(", 1)[0].strip()
        return text

    def get_selected_category(self):
        """Obtener la categor√≠a seleccionada o usar 'Sin Categor√≠a' por defecto"""
        # En el nuevo sistema de bloques, preguntamos al usuario la categor√≠a al agregar
        return "Sin Categor√≠a"

    def add_directory(self):
        """Agregar un nuevo directorio"""
        directory = QFileDialog.getExistingDirectory(
            self, "Seleccionar Directorio", "", QFileDialog.Option.ShowDirsOnly
        )

        if directory:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            directory = normalize_network_path(directory)
            category = self.get_selected_category()
            self.add_path_to_category(directory, category)

    def add_file(self):
        """Agregar un nuevo archivo"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Seleccionar Archivo", "", "Todos los archivos (*.*)"
        )

        if file_path:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            file_path = normalize_network_path(file_path)
            category = self.get_selected_category()
            self.add_path_to_category(file_path, category)

    def add_path_to_category(self, path, category="Sin Categor√≠a"):
        """Agregar una ruta (archivo o directorio) a una categor√≠a espec√≠fica"""
        # Verificar si ya existe en alguna categor√≠a
        for cat, cat_data in self.categories.items():
            paths = (
                cat_data.get("paths", []) if isinstance(cat_data, dict) else cat_data
            )
            if path in paths:
                if hasattr(self.parent(), "statusBar"):
                    self.parent().statusBar().showMessage(
                        f"‚ö†Ô∏è Este elemento ya est√° en la categor√≠a '{cat}'", 2000
                    )
                return False

        # Asegurar que la categor√≠a existe
        if category not in self.categories:
            self.categories[category] = {"paths": [], "color": "#4a90e2", "icon": "üìÅ"}

        # Obtener paths seg√∫n el formato
        if isinstance(self.categories[category], list):
            # Formato antiguo: convertir a nuevo formato
            self.categories[category] = {
                "paths": self.categories[category],
                "color": "#4a90e2",
                "icon": "üìÅ",
            }

        # Agregar a la categor√≠a
        self.categories[category]["paths"].append(path)
        self.refresh_blocks()
        self.directory_changed.emit()

        # Mensaje de confirmaci√≥n
        item_name = os.path.basename(path) or path
        item_type = "carpeta" if os.path.isdir(path) else "archivo"
        if hasattr(self.parent(), "statusBar"):
            self.parent().statusBar().showMessage(
                f"‚úÖ {item_type.capitalize()} '{item_name}' agregado a '{category}'",
                3000,
            )
        return True

    def dragEnterEvent(self, event: QDragEnterEvent):
        """Manejar evento cuando se arrastra algo sobre el widget"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event: QDropEvent):
        """Manejar evento cuando se suelta algo en el widget"""
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            added_count = 0
            category = self.get_selected_category()

            for url in urls:
                # Normalizar ruta para soportar rutas de red UNC correctamente
                file_path = normalize_network_path(url.toLocalFile())
                if os.path.exists(file_path):
                    if self.add_path_to_category(file_path, category):
                        added_count += 1

            if added_count > 0:
                if hasattr(self.parent(), "statusBar"):
                    self.parent().statusBar().showMessage(
                        f"‚úÖ Se agregaron {added_count} elemento(s) a '{category}'",
                        3000,
                    )

            event.acceptProposedAction()
        else:
            event.ignore()

    def remove_selected_directory(self):
        """Eliminar categor√≠a o elemento - Ahora pide al usuario que seleccione"""
        # Crear di√°logo para seleccionar qu√© eliminar
        from PyQt6.QtWidgets import QInputDialog

        if not self.categories or all(not paths for paths in self.categories.values()):
            QMessageBox.information(
                self,
                "Sin Elementos",
                "No hay elementos para eliminar. Haz clic derecho sobre cualquier elemento para eliminarlo.",
            )
            return

        # Crear lista de opciones
        items = []
        items.append("‚ùå Cancelar")

        # Agregar categor√≠as
        for category_name in self.categories.keys():
            if category_name != "Sin Categor√≠a":
                count = len(self.categories[category_name])
                items.append(f"üìÅ Categor√≠a: {category_name} ({count} elementos)")

        # Agregar archivos individuales
        for category_name, paths in self.categories.items():
            for path in paths:
                item_name = os.path.basename(path)
                items.append(f"üìÑ {item_name} (en {category_name})")

        item, ok = QInputDialog.getItem(
            self, "Eliminar Elemento", "Selecciona qu√© eliminar:", items, 0, False
        )

        if not ok or item == "‚ùå Cancelar":
            return

        # Procesar eliminaci√≥n
        if item.startswith("üìÅ Categor√≠a:"):
            # Eliminar categor√≠a
            category_name = item.replace("üìÅ Categor√≠a: ", "").split(" (")[0]
            reply = QMessageBox.question(
                self,
                "Confirmar Eliminaci√≥n",
                f"¬øEliminar la categor√≠a '{category_name}' y todos sus elementos?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )
            if reply == QMessageBox.StandardButton.Yes:
                del self.categories[category_name]
                self.refresh_blocks()
                self.directory_changed.emit()
        else:
            # Eliminar elemento individual
            item_name = item.replace("üìÑ ", "").split(" (en ")[0]
            category = item.split(" (en ")[1].rstrip(")")

            # Buscar la ruta completa
            path_to_remove = None
            for path in self.categories[category]:
                if os.path.basename(path) == item_name:
                    path_to_remove = path
                    break

            if path_to_remove:
                self.categories[category].remove(path_to_remove)
                self.refresh_blocks()
                self.directory_changed.emit()

    def clear_all_directories(self):
        """Limpiar todos los favoritos"""
        total_items = sum(len(paths) for paths in self.categories.values())

        if total_items == 0:
            QMessageBox.information(
                self, "Lista Vac√≠a", "No hay elementos en tus favoritos."
            )
            return

        reply = QMessageBox.question(
            self,
            "Confirmar Limpieza",
            f"¬øEst√°s seguro de que quieres eliminar todos los {total_items} elementos de todas las categor√≠as?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Limpiar todas las categor√≠as pero mantener la estructura
            for category in self.categories:
                self.categories[category] = []
            self.refresh_blocks()
            self.directory_changed.emit()

    def open_item(self, item=None, column=None):
        """Abrir archivo o carpeta - Ahora manejado por los bloques"""
        # Los bloques manejan la apertura de archivos autom√°ticamente
        pass

    def show_context_menu(self, position):
        """Mostrar men√∫ contextual - Ahora manejado por los bloques individuales"""
        # Los bloques manejan su propio men√∫ contextual
        pass

    def copy_path_to_clipboard(self, path):
        """Copiar ruta al portapapeles"""
        clipboard = QApplication.clipboard()
        clipboard.setText(path)

        if hasattr(self.parent(), "statusBar"):
            self.parent().statusBar().showMessage(f"üìã Ruta copiada: {path}", 3000)

    def rename_category(self, old_name):
        """Renombrar una categor√≠a"""
        from PyQt6.QtWidgets import QInputDialog

        if old_name == "Sin Categor√≠a":
            QMessageBox.warning(
                self,
                "Categor√≠a Protegida",
                "No puedes renombrar la categor√≠a 'Sin Categor√≠a'.",
            )
            return

        new_name, ok = QInputDialog.getText(
            self, "Renombrar Categor√≠a", "Nuevo nombre:", text=old_name
        )

        if ok and new_name and new_name != old_name:
            if new_name in self.categories:
                QMessageBox.warning(
                    self,
                    "Nombre Existente",
                    f"Ya existe una categor√≠a llamada '{new_name}'.",
                )
                return

            # Renombrar la categor√≠a
            self.categories[new_name] = self.categories.pop(old_name)
            self.refresh_blocks()
            self.directory_changed.emit()

            if hasattr(self.parent(), "statusBar"):
                self.parent().statusBar().showMessage(
                    f"‚úÖ Categor√≠a renombrada: '{old_name}' ‚Üí '{new_name}'", 3000
                )

    def move_to_category(self, path, from_category, to_category):
        """Mover un elemento de una categor√≠a a otra"""
        if from_category in self.categories and path in self.categories[from_category]:
            self.categories[from_category].remove(path)

            if to_category not in self.categories:
                self.categories[to_category] = []

            self.categories[to_category].append(path)
            self.refresh_blocks()
            self.directory_changed.emit()

            item_name = os.path.basename(path) or path
            if hasattr(self.parent(), "statusBar"):
                self.parent().statusBar().showMessage(
                    f"‚úÖ '{item_name}' movido de '{from_category}' a '{to_category}'",
                    3000,
                )

    def delete_category(self, category_name):
        """Eliminar una categor√≠a y mover sus elementos a 'Sin Categor√≠a'"""
        if category_name == "Sin Categor√≠a":
            return  # No se puede eliminar la categor√≠a por defecto

        if category_name not in self.categories:
            return

        # Obtener elementos a mover (manejar ambos formatos)
        items_to_move = []
        if isinstance(self.categories[category_name], list):
            # Formato simple: {"Sin Categor√≠a": []}
            items_to_move = self.categories[category_name].copy()
        elif (
            isinstance(self.categories[category_name], dict)
            and "paths" in self.categories[category_name]
        ):
            # Formato con metadatos: {"Sin Categor√≠a": {"paths": [], "color": "#4a90e2", "icon": "üìÅ"}}
            items_to_move = self.categories[category_name]["paths"].copy()

        # Mover elementos a "Sin Categor√≠a"
        if items_to_move:
            if isinstance(self.categories["Sin Categor√≠a"], list):
                # Formato simple
                self.categories["Sin Categor√≠a"].extend(items_to_move)
            elif (
                isinstance(self.categories["Sin Categor√≠a"], dict)
                and "paths" in self.categories["Sin Categor√≠a"]
            ):
                # Formato con metadatos
                self.categories["Sin Categor√≠a"]["paths"].extend(items_to_move)

        # Eliminar la categor√≠a
        del self.categories[category_name]

        # Refrescar la interfaz
        self.refresh_blocks()
        self.directory_changed.emit()

        # Mostrar mensaje de confirmaci√≥n
        if hasattr(self.parent(), "statusBar"):
            self.parent().statusBar().showMessage(
                f"‚úÖ Categor√≠a '{category_name}' eliminada. {len(items_to_move)} elementos movidos a 'Sin Categor√≠a'",
                5000,
            )

    def refresh_tree(self):
        """Actualizar el √°rbol visual"""
        self.directory_tree.clear()

        # Actualizar contador de elementos
        total_items = sum(len(paths) for paths in self.categories.values())
        if total_items == 0:
            self.items_count_label.setText("0 elementos")
        elif total_items == 1:
            self.items_count_label.setText("1 elemento")
        else:
            self.items_count_label.setText(f"{total_items} elementos")

        # Ordenar categor√≠as (Sin Categor√≠a primero, luego alfab√©ticamente)
        sorted_categories = sorted(
            self.categories.keys(), key=lambda x: (x != "Sin Categor√≠a", x)
        )

        for category_name in sorted_categories:
            paths = self.categories[category_name]

            # Crear nodo de categor√≠a
            count = len(paths)
            category_item = QTreeWidgetItem([f"üìÅ {category_name} ({count})"])
            category_item.setForeground(0, QColor("#4a90e2"))

            # Configurar fuente en negrita para categor√≠as
            font = category_item.font(0)
            font.setBold(True)
            font.setPointSize(11)
            category_item.setFont(0, font)

            self.directory_tree.addTopLevelItem(category_item)

            # Agregar elementos de la categor√≠a
            for path in paths:
                exists = os.path.exists(path)
                is_dir = os.path.isdir(path) if exists else False
                item_name = os.path.basename(path) or path

                # Obtener icono apropiado
                if not exists:
                    icon = "‚ùå"
                    item_type = "(No existe)"
                elif is_dir:
                    icon = "üìÅ"
                    item_type = "Carpeta"
                else:
                    icon = get_file_icon_by_extension(path, False)
                    item_type = "Archivo"

                # Crear item
                display_text = f"{icon} {item_name} [{item_type}]"
                child_item = QTreeWidgetItem([display_text])
                child_item.setData(0, Qt.ItemDataRole.UserRole, path)
                child_item.setToolTip(0, path)

                if not exists:
                    child_item.setForeground(0, QColor("#e74c3c"))

                category_item.addChild(child_item)

            # Expandir la categor√≠a
            category_item.setExpanded(True)

    def change_view_mode(self):
        """Cambiar el modo de visualizaci√≥n del √°rbol"""
        self.view_mode = self.view_combo.currentData()

        if self.view_mode == "normal":
            # Vista normal - est√°ndar
            self.directory_tree.setIndentation(20)
            self.directory_tree.setStyleSheet("""
                QTreeWidget {
                    background-color: #ffffff;
                    border: 2px solid #555555;
                    border-radius: 8px;
                    padding: 10px;
                    font-size: 13px;
                    color: #ffffff;
                }
                QTreeWidget::item {
                    padding: 8px;
                    border-radius: 3px;
                    min-height: 30px;
                }
                QTreeWidget::item:selected {
                    background-color: #217346;
                    color: white;
                }
                QTreeWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """)
        elif self.view_mode == "compact":
            # Vista compacta - menos espacio
            self.directory_tree.setIndentation(15)
            self.directory_tree.setStyleSheet("""
                QTreeWidget {
                    background-color: #ffffff;
                    border: 2px solid #555555;
                    border-radius: 8px;
                    padding: 5px;
                    font-size: 11px;
                    color: #ffffff;
                }
                QTreeWidget::item {
                    padding: 4px;
                    border-radius: 2px;
                    min-height: 20px;
                }
                QTreeWidget::item:selected {
                    background-color: #217346;
                    color: white;
                }
                QTreeWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """)
        elif self.view_mode == "detailed":
            # Vista detallada - m√°s espacio e informaci√≥n
            self.directory_tree.setIndentation(25)
            self.directory_tree.setStyleSheet("""
                QTreeWidget {
                    background-color: #ffffff;
                    border: 2px solid #555555;
                    border-radius: 8px;
                    padding: 15px;
                    font-size: 14px;
                    color: #ffffff;
                }
                QTreeWidget::item {
                    padding: 12px;
                    border-radius: 4px;
                    min-height: 40px;
                    border-bottom: 1px solid #3a3a3a;
                }
                QTreeWidget::item:selected {
                    background-color: #217346;
                    color: white;
                }
                QTreeWidget::item:hover {
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                }
            """)
        elif self.view_mode == "icons":
            # Vista iconos - similar a normal pero con √©nfasis visual
            self.directory_tree.setIndentation(20)
            self.directory_tree.setStyleSheet("""
                QTreeWidget {
                    background-color: #ffffff;
                    border: 2px solid #555555;
                    border-radius: 8px;
                    padding: 10px;
                    font-size: 14px;
                    color: #ffffff;
                    font-weight: bold;
                }
                QTreeWidget::item {
                    padding: 10px;
                    border-radius: 5px;
                    min-height: 35px;
                    margin: 2px;
                }
                QTreeWidget::item:selected {
                    background-color: #217346;
                    color: white;
                    border: 2px solid #6aa2e6;
                }
                QTreeWidget::item:hover {
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                }
            """)

        # Notificar cambio si hay parent con statusBar
        if hasattr(self.parent(), "statusBar"):
            self.parent().statusBar().showMessage(
                f"‚úì Vista cambiada: {self.view_combo.currentText()}", 2000
            )

    def get_directories(self):
        """Obtener estructura de categor√≠as con colores e iconos"""
        # Convertir al nuevo formato con metadatos
        result = {}
        for category_name, data in self.categories.items():
            if isinstance(data, list):
                # Formato antiguo: solo rutas
                result[category_name] = {
                    "paths": data,
                    "color": "#4a90e2",  # Color por defecto
                    "icon": "üìÅ",  # Icono por defecto
                }
            elif isinstance(data, dict):
                # Formato nuevo con metadatos
                result[category_name] = data
            else:
                result[category_name] = {"paths": [], "color": "#4a90e2", "icon": "üìÅ"}
        return result

    def set_directories(self, data):
        """Establecer estructura de categor√≠as y directorios con colores e iconos"""
        self.categories = {}

        # Soporte para m√∫ltiples formatos
        if isinstance(data, list):
            # Formato muy antiguo: lista simple
            self.categories = {
                "Sin Categor√≠a": {
                    "paths": data.copy(),
                    "color": "#4a90e2",
                    "icon": "üìÅ",
                }
            }
        elif isinstance(data, dict):
            for category_name, category_data in data.items():
                if isinstance(category_data, list):
                    # Formato antiguo: solo rutas
                    self.categories[category_name] = {
                        "paths": category_data,
                        "color": "#4a90e2",
                        "icon": "üìÅ",
                    }
                elif isinstance(category_data, dict):
                    # Formato nuevo con metadatos
                    if "paths" in category_data:
                        # Ya tiene el formato correcto
                        self.categories[category_name] = category_data
                    else:
                        # Es un dict pero sin la estructura correcta, asumir que son metadatos antiguos
                        self.categories[category_name] = {
                            "paths": category_data.get("paths", []),
                            "color": category_data.get("color", "#4a90e2"),
                            "icon": category_data.get("icon", "üìÅ"),
                        }

        # Asegurar que existe "Sin Categor√≠a"
        if "Sin Categor√≠a" not in self.categories:
            self.categories["Sin Categor√≠a"] = {
                "paths": [],
                "color": "#4a90e2",
                "icon": "üìÅ",
            }

        self.refresh_blocks()


class DashboardTab(QWidget):
    """Widget de dashboard con sidebar, √°rea principal y panel flotante de notas"""

    data_changed = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.notes = []
        self.tasks = []
        self.pinned_notes = []
        self.current_note = None
        self.setup_ui()

    def setup_ui(self):
        """Configurar interfaz del dashboard"""
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        # ==== SIDEBAR IZQUIERDO ====
        self.sidebar = self.create_sidebar()
        main_layout.addWidget(self.sidebar, 0)  # Ancho fijo

        # ==== √ÅREA PRINCIPAL DEL DASHBOARD ====
        self.dashboard_area = self.create_dashboard_area()
        main_layout.addWidget(self.dashboard_area, 1)  # Ancho flexible

        # ==== PANEL FLOTANTE DE NOTAS ====
        self.floating_notes_panel = self.create_floating_notes_panel()
        main_layout.addWidget(self.floating_notes_panel, 0)  # Ancho fijo

    def create_sidebar(self):
        """Crear sidebar izquierdo con navegaci√≥n y calendario"""
        sidebar = QWidget()
        sidebar.setFixedWidth(250)
        sidebar.setStyleSheet("""
            QWidget {
                background-color: rgba(30, 30, 30, 0.95);
                border-right: 1px solid rgba(255, 255, 255, 0.1);
            }
        """)

        layout = QVBoxLayout(sidebar)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(20)

        # T√≠tulo Dashboard con icono
        dashboard_header = QHBoxLayout()
        dashboard_icon = QLabel("‚äû")
        dashboard_icon.setStyleSheet(
            "color: #ffffff; font-size: 16pt; font-weight: bold;"
        )
        dashboard_title = QLabel("Dashboard")
        dashboard_title.setStyleSheet(
            "color: #ffffff; font-size: 14pt; font-weight: bold; margin-left: 8px;"
        )
        dashboard_header.addWidget(dashboard_icon)
        dashboard_header.addWidget(dashboard_title)
        dashboard_header.addStretch()
        layout.addLayout(dashboard_header)

        # Lista de navegaci√≥n
        self.nav_list = QListWidget()
        self.nav_list.setStyleSheet("""
            QListWidget {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 12pt;
            }
            QListWidget::item {
                padding: 12px 16px;
                border-radius: 8px;
                margin: 2px 0px;
            }
            QListWidget::item:selected {
                background-color: #217346;
                border-left: 3px solid #4a90e2;
            }
            QListWidget::item:hover {
                background-color: rgba(74, 144, 226, 0.3);
            }
        """)

        # Agregar elementos de navegaci√≥n
        nav_items = [
            ("üè†", "Dashboard"),
            ("üìù", "All Notes", "‚ñº"),
            ("üìã", "Tasks"),
            ("üè∑Ô∏è", "Tags", "‚ñ∂"),
            ("üìÖ", "Calendar", "‚ñ∂"),
            ("üè∑Ô∏è", "Tags"),
            ("‚öôÔ∏è", "Settings"),
        ]

        for item_data in nav_items:
            if len(item_data) == 2:
                icon, text = item_data
                item = QListWidgetItem(f"{icon} {text}")
            else:
                icon, text, arrow = item_data
                item = QListWidgetItem(f"{icon} {text} {arrow}")
            self.nav_list.addItem(item)

        # Marcar Dashboard como seleccionado
        self.nav_list.setCurrentRow(0)
        self.nav_list.itemClicked.connect(self.on_nav_item_clicked)
        layout.addWidget(self.nav_list)

        # Espaciador
        layout.addStretch()

        # Widget de calendario
        calendar_widget = self.create_calendar_widget()
        layout.addWidget(calendar_widget)

        return sidebar

    def create_calendar_widget(self):
        """Crear widget de calendario funcional para el sidebar"""
        calendar_widget = QWidget()
        calendar_widget.setStyleSheet("""
            QWidget {
                background-color: rgba(40, 40, 40, 0.8);
                border-radius: 8px;
                padding: 10px;
            }
        """)

        layout = QVBoxLayout(calendar_widget)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)

        # Header con navegaci√≥n
        header_layout = QHBoxLayout()

        # Bot√≥n mes anterior
        prev_btn = QPushButton("‚óÄ")
        prev_btn.setFixedSize(20, 20)
        prev_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #888888;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                color: #ffffff;
                background-color: rgba(74, 144, 226, 0.3);
                border-radius: 10px;
            }
        """)
        prev_btn.clicked.connect(self.previous_month)
        header_layout.addWidget(prev_btn)

        # T√≠tulo del mes
        self.month_label = QLabel("October 2024")
        self.month_label.setStyleSheet(
            "color: #ffffff; font-size: 12pt; font-weight: bold;"
        )
        self.month_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(self.month_label)

        # Bot√≥n mes siguiente
        next_btn = QPushButton("‚ñ∂")
        next_btn.setFixedSize(20, 20)
        next_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #888888;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                color: #ffffff;
                background-color: rgba(74, 144, 226, 0.3);
                border-radius: 10px;
            }
        """)
        next_btn.clicked.connect(self.next_month)
        header_layout.addWidget(next_btn)

        layout.addLayout(header_layout)

        # D√≠as de la semana
        days_header = QHBoxLayout()
        days = ["M", "T", "W", "T", "F", "S", "S"]
        for day in days:
            day_label = QLabel(day)
            day_label.setStyleSheet(
                "color: #888888; font-size: 11pt; font-weight: bold;"
            )
            day_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            day_label.setFixedWidth(30)
            day_label.setMinimumWidth(30)
            days_header.addWidget(day_label)
        layout.addLayout(days_header)

        # Grid de d√≠as del mes
        self.days_layout = QGridLayout()
        self.days_layout.setSpacing(2)

        # Inicializar calendario
        self.current_date = datetime.now()
        self.selected_date = None
        self.calendar_events = {}  # Diccionario para almacenar eventos por fecha

        # Agregar algunos eventos de ejemplo
        self.add_sample_events()

        # Crear d√≠as del mes
        self.update_calendar_display()

        layout.addLayout(self.days_layout)

        return calendar_widget

    def create_dashboard_area(self):
        """Crear √°rea principal del dashboard"""
        dashboard = QWidget()
        dashboard.setStyleSheet("""
            QWidget {
                background-color: rgba(25, 25, 25, 0.95);
            }
        """)

        layout = QVBoxLayout(dashboard)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(25)

        # Header del dashboard
        header_layout = QHBoxLayout()
        dashboard_title = QLabel("Dashboard")
        dashboard_title.setStyleSheet(
            "color: #ffffff; font-size: 18pt; font-weight: bold;"
        )
        header_layout.addWidget(dashboard_title)

        refresh_btn = QPushButton("üîÑ")
        refresh_btn.setFixedSize(30, 30)
        refresh_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(42, 42, 42, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.8);
            }
        """)
        header_layout.addWidget(refresh_btn)
        header_layout.addStretch()

        layout.addLayout(header_layout)

        # Secci√≥n de notas fijadas
        pinned_section = self.create_pinned_notes_section()
        layout.addWidget(pinned_section)

        # Secci√≥n de tareas pr√≥ximas
        tasks_section = self.create_upcoming_tasks_section()
        layout.addWidget(tasks_section)

        # Secci√≥n de actividad reciente
        activity_section = self.create_recent_activity_section()
        layout.addWidget(activity_section)

        layout.addStretch()

        return dashboard

    def create_pinned_notes_section(self):
        """Crear secci√≥n de notas fijadas"""
        section = QWidget()
        section.setStyleSheet("""
            QWidget {
                background-color: rgba(40, 40, 40, 0.8);
                border-radius: 12px;
                padding: 20px;
            }
        """)

        layout = QVBoxLayout(section)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # T√≠tulo de la secci√≥n
        title = QLabel("Pinned Notes")
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold;")
        layout.addWidget(title)

        # Nota 1: Project Mars Kick-Off
        note1 = QPushButton()  # Cambiar a QPushButton para hacer clickeable
        note1.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                text-align: left;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.3);
            }
        """)
        note1_layout = QVBoxLayout(note1)
        note1_layout.setContentsMargins(0, 0, 0, 0)
        note1_layout.setSpacing(8)

        note1_title = QLabel("Project Mars Kick-Off")
        note1_title.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        note1_layout.addWidget(note1_title)

        # Barra de progreso
        progress_widget = QWidget()
        progress_layout = QHBoxLayout(progress_widget)
        progress_layout.setContentsMargins(0, 0, 0, 0)

        progress_bar = QProgressBar()
        progress_bar.setValue(75)
        progress_bar.setStyleSheet("""
            QProgressBar {
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                background-color: rgba(42, 42, 42, 0.6);
                text-align: center;
                color: #ffffff;
            }
            QProgressBar::chunk {
                background-color: #217346;
                border-radius: 8px;
            }
        """)
        progress_layout.addWidget(progress_bar)

        progress_label = QLabel("75%")
        progress_label.setStyleSheet(
            "color: #4a90e2; font-size: 10pt; font-weight: bold; margin-left: 8px;"
        )
        progress_layout.addWidget(progress_label)
        progress_layout.addStretch()

        note1_layout.addWidget(progress_widget)

        # Conectar click
        note1.clicked.connect(lambda: self.open_pinned_note("Project Mars Kick-Off"))

        # Nota 2: Q3 Marketing Strategy
        note2 = QPushButton()  # Cambiar a QPushButton para hacer clickeable
        note2.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                text-align: left;
                padding: 10px;
                border-radius: 8px;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.3);
            }
        """)
        note2_layout = QHBoxLayout(note2)
        note2_layout.setContentsMargins(0, 0, 0, 0)

        note2_title = QLabel("Q3 Marketing Strategy")
        note2_title.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        note2_layout.addWidget(note2_title)

        alert_icon = QLabel("‚ö†Ô∏è")
        alert_icon.setStyleSheet("color: #ff9f43; font-size: 14pt;")
        note2_layout.addWidget(alert_icon)
        note2_layout.addStretch()

        # Conectar click
        note2.clicked.connect(lambda: self.open_pinned_note("Q3 Marketing Strategy"))

        note1_layout.addWidget(note2)
        layout.addWidget(note1)

        return section

    def create_upcoming_tasks_section(self):
        """Crear secci√≥n de tareas pr√≥ximas"""
        section = QWidget()
        section.setStyleSheet("""
            QWidget {
                background-color: rgba(40, 40, 40, 0.8);
                border-radius: 12px;
                padding: 20px;
            }
        """)

        layout = QVBoxLayout(section)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # T√≠tulo de la secci√≥n
        title = QLabel("Upcoming Tasks")
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold;")
        layout.addWidget(title)

        # Tarea 1: Prepare Q3 Report
        task1 = QWidget()
        task1_layout = QHBoxLayout(task1)
        task1_layout.setContentsMargins(0, 0, 0, 0)

        task1_checkbox = QCheckBox()
        task1_checkbox.setChecked(True)
        task1_checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #4a90e2;
                border-radius: 3px;
                background-color: #217346;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
            }
        """)
        task1_checkbox.stateChanged.connect(
            lambda state: self.toggle_task("Prepare Q3 Report", state)
        )
        task1_layout.addWidget(task1_checkbox)

        task1_label = QLabel("Prepare Q3 Report (Due Fri)")
        task1_label.setStyleSheet(
            "color: #ffffff; font-size: 11pt; text-decoration: line-through;"
        )
        task1_layout.addWidget(task1_label)
        task1_layout.addStretch()

        layout.addWidget(task1)

        # Tarea 2: Review Ad Copy
        task2 = QWidget()
        task2_layout = QHBoxLayout(task2)
        task2_layout.setContentsMargins(0, 0, 0, 0)

        task2_checkbox = QCheckBox()
        task2_checkbox.setChecked(False)
        task2_checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #888888;
                border-radius: 3px;
                background-color: transparent;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
                border-color: #4a90e2;
            }
        """)
        task2_checkbox.stateChanged.connect(
            lambda state: self.toggle_task("Review Ad Copy", state)
        )
        task2_layout.addWidget(task2_checkbox)

        task2_label = QLabel("Review Ad Copy (Due Mon)")
        task2_label.setStyleSheet("color: #ffffff; font-size: 11pt;")
        task2_layout.addWidget(task2_label)
        task2_layout.addStretch()

        layout.addWidget(task2)

        return section

    def create_recent_activity_section(self):
        """Crear secci√≥n de actividad reciente"""
        section = QWidget()
        section.setStyleSheet("""
            QWidget {
                background-color: rgba(40, 40, 40, 0.8);
                border-radius: 12px;
                padding: 20px;
            }
        """)

        layout = QVBoxLayout(section)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # T√≠tulo de la secci√≥n
        title = QLabel("Recent Activity")
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold;")
        layout.addWidget(title)

        # Actividad 1
        activity1 = QWidget()
        activity1_layout = QHBoxLayout(activity1)
        activity1_layout.setContentsMargins(0, 0, 0, 0)

        activity1_label = QLabel("React elidity")
        activity1_label.setStyleSheet("color: #ffffff; font-size: 11pt;")
        activity1_layout.addWidget(activity1_label)
        activity1_layout.addStretch()

        layout.addWidget(activity1)

        # Actividad 2
        activity2 = QWidget()
        activity2_layout = QHBoxLayout(activity2)
        activity2_layout.setContentsMargins(0, 0, 0, 0)

        activity2_label = QLabel(
            "Tinie yarƒ± rey pee siducitse ped ped fiids to sepdiall cboses hee 128"
        )
        activity2_label.setStyleSheet("color: #ffffff; font-size: 11pt;")
        activity2_label.setWordWrap(True)
        activity2_layout.addWidget(activity2_label)

        timestamp = QLabel("20.92")
        timestamp.setStyleSheet("color: #888888; font-size: 10pt;")
        activity2_layout.addWidget(timestamp)

        layout.addWidget(activity2)

        return section

    def create_floating_notes_panel(self):
        """Crear panel flotante de notas"""
        panel = QWidget()
        panel.setFixedWidth(350)
        panel.setStyleSheet("""
            QWidget {
                background-color: rgba(35, 35, 35, 0.95);
                border-radius: 12px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
        """)

        layout = QVBoxLayout(panel)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Barra de t√≠tulo
        title_bar = QWidget()
        title_bar.setFixedHeight(40)
        title_bar.setStyleSheet("""
            QWidget {
                background-color: rgba(50, 50, 50, 0.8);
                border-top-left-radius: 12px;
                border-top-right-radius: 12px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
        """)

        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(15, 0, 15, 0)

        title_label = QLabel("Meeting Notes - Q3 Planning")
        title_label.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        title_layout.addWidget(title_label)
        title_layout.addStretch()

        # Botones de ventana
        window_buttons = QHBoxLayout()
        window_buttons.setSpacing(5)

        minimize_btn = QPushButton("‚àí")
        minimize_btn.setFixedSize(20, 20)
        minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff9f43;
                border: none;
                border-radius: 10px;
                color: #ffffff;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #ff8c33;
            }
        """)
        window_buttons.addWidget(minimize_btn)

        maximize_btn = QPushButton("‚ñ°")
        maximize_btn.setFixedSize(20, 20)
        maximize_btn.setStyleSheet("""
            QPushButton {
                background-color: #26de81;
                border: none;
                border-radius: 10px;
                color: #ffffff;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #16ce71;
            }
        """)
        window_buttons.addWidget(maximize_btn)

        close_btn = QPushButton("√ó")
        close_btn.setFixedSize(20, 20)
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff5555;
                border: none;
                border-radius: 10px;
                color: #ffffff;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #ff4444;
            }
        """)
        window_buttons.addWidget(close_btn)

        title_layout.addLayout(window_buttons)
        layout.addWidget(title_bar)

        # Contenido de la nota
        content_area = QWidget()
        content_layout = QVBoxLayout(content_area)
        content_layout.setContentsMargins(20, 20, 20, 20)
        content_layout.setSpacing(15)

        # Texto de la nota
        note_text = QTextEdit()
        note_text.setPlainText(
            "‚Ä¢ Project kickoff meeting scheduled\n‚Ä¢ Budget allocation for Q3\n‚Ä¢ Team assignments and responsibilities\n‚Ä¢ Timeline and milestones"
        )
        note_text.setStyleSheet("""
            QTextEdit {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 11pt;
                line-height: 1.6;
            }
        """)
        content_layout.addWidget(note_text)

        # Barra de herramientas
        toolbar = QHBoxLayout()
        toolbar.setSpacing(8)

        toolbar_icons = ["‚≠ê", "‚äû", "#", "üë§", "üìé", "üïê", "üìç"]
        for icon in toolbar_icons:
            btn = QPushButton(icon)
            btn.setFixedSize(25, 25)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: none;
                    color: #888888;
                    font-size: 12pt;
                }
                QPushButton:hover {
                    color: #ffffff;
                    background-color: rgba(74, 144, 226, 0.3);
                    border-radius: 4px;
                }
            """)
            toolbar.addWidget(btn)

        toolbar.addStretch()
        content_layout.addLayout(toolbar)

        # M√°s texto
        more_text = QTextEdit()
        more_text.setPlainText(
            "Additional meeting notes and action items will be documented here for future reference."
        )
        more_text.setStyleSheet("""
            QTextEdit {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 11pt;
                line-height: 1.6;
            }
        """)
        content_layout.addWidget(more_text)

        # Bot√≥n de guardar
        save_btn = QPushButton("‚úì")
        save_btn.setFixedSize(40, 40)
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #26de81;
                border: none;
                border-radius: 20px;
                color: #ffffff;
                font-size: 16pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #16ce71;
            }
        """)
        save_btn.setToolTip("Save Note")

        # Posicionar bot√≥n en la esquina inferior derecha
        save_layout = QHBoxLayout()
        save_layout.addStretch()
        save_layout.addWidget(save_btn)
        content_layout.addLayout(save_layout)

        layout.addWidget(content_area)

        return panel

    def on_nav_item_clicked(self, item):
        """Manejar click en elemento de navegaci√≥n"""
        text = item.text()
        print(f"Clicked: {text}")

        # Cambiar la vista seg√∫n la selecci√≥n
        if "Dashboard" in text:
            self.show_dashboard_view()
        elif "All Notes" in text:
            self.show_notes_view()
        elif "Tasks" in text:
            self.show_tasks_view()
        elif "Tags" in text:
            self.show_tags_view()
        elif "Calendar" in text:
            self.show_calendar_view()
        elif "Settings" in text:
            self.show_settings_view()

    def show_dashboard_view(self):
        """Mostrar vista del dashboard"""
        # Ocultar panel flotante de notas
        self.floating_notes_panel.hide()
        # Mostrar √°rea principal del dashboard
        self.dashboard_area.show()
        self.refresh_dashboard_content()

    def show_notes_view(self):
        """Mostrar vista de notas"""
        # Mostrar panel flotante de notas
        self.floating_notes_panel.show()
        # Cambiar contenido del √°rea principal a lista de notas
        self.switch_to_notes_list_view()

    def show_tasks_view(self):
        """Mostrar vista de tareas"""
        self.switch_to_tasks_view()

    def show_tags_view(self):
        """Mostrar vista de etiquetas"""
        self.switch_to_tags_view()

    def show_calendar_view(self):
        """Mostrar vista de calendario"""
        self.switch_to_calendar_view()

    def show_settings_view(self):
        """Mostrar vista de configuraci√≥n"""
        self.switch_to_settings_view()

    def get_data(self):
        """Obtener datos del dashboard"""
        return {
            "notes": self.notes,
            "tasks": self.tasks,
            "pinned_notes": self.pinned_notes,
            "calendar_events": self.calendar_events,
        }

    def set_data(self, data):
        """Establecer datos del dashboard"""
        self.notes = data.get("notes", [])
        self.tasks = data.get("tasks", [])
        self.pinned_notes = data.get("pinned_notes", [])
        self.calendar_events = data.get("calendar_events", {})
        self.refresh_dashboard_content()

    def refresh_dashboard_content(self):
        """Refrescar contenido del dashboard"""
        # Actualizar secci√≥n de notas fijadas
        self.update_pinned_notes()
        # Actualizar secci√≥n de tareas
        self.update_upcoming_tasks()
        # Actualizar actividad reciente
        self.update_recent_activity()

    def update_pinned_notes(self):
        """Actualizar secci√≥n de notas fijadas"""
        # Esta funci√≥n se implementar√° para actualizar din√°micamente las notas fijadas
        pass

    def update_upcoming_tasks(self):
        """Actualizar secci√≥n de tareas pr√≥ximas"""
        # Esta funci√≥n se implementar√° para actualizar din√°micamente las tareas
        pass

    def update_recent_activity(self):
        """Actualizar secci√≥n de actividad reciente"""
        # Esta funci√≥n se implementar√° para actualizar din√°micamente la actividad
        pass

    def switch_to_notes_list_view(self):
        """Cambiar a vista de lista de notas"""
        # Limpiar √°rea principal
        self.clear_dashboard_area()

        # Crear vista de lista de notas
        notes_view = self.create_notes_list_view()
        self.dashboard_area_layout.addWidget(notes_view)

    def switch_to_tasks_view(self):
        """Cambiar a vista de tareas"""
        self.clear_dashboard_area()
        tasks_view = self.create_tasks_view()
        self.dashboard_area_layout.addWidget(tasks_view)

    def switch_to_tags_view(self):
        """Cambiar a vista de etiquetas"""
        self.clear_dashboard_area()
        tags_view = self.create_tags_view()
        self.dashboard_area_layout.addWidget(tags_view)

    def switch_to_calendar_view(self):
        """Cambiar a vista de calendario"""
        self.clear_dashboard_area()
        calendar_view = self.create_calendar_view()
        self.dashboard_area_layout.addWidget(calendar_view)

    def switch_to_settings_view(self):
        """Cambiar a vista de configuraci√≥n"""
        self.clear_dashboard_area()
        settings_view = self.create_settings_view()
        self.dashboard_area_layout.addWidget(settings_view)

    def clear_dashboard_area(self):
        """Limpiar √°rea principal del dashboard"""
        # Obtener el layout del dashboard area
        if not hasattr(self, "dashboard_area_layout"):
            self.dashboard_area_layout = self.dashboard_area.layout()

        # Limpiar widgets existentes
        while self.dashboard_area_layout.count():
            item = self.dashboard_area_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

    def create_notes_list_view(self):
        """Crear vista de lista de notas completamente funcional"""
        view = QWidget()
        layout = QVBoxLayout(view)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Header con b√∫squeda y filtros
        header_layout = QVBoxLayout()

        # Primera fila: T√≠tulo y bot√≥n nueva nota
        title_row = QHBoxLayout()
        title = QLabel("All Notes")
        title.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        title_row.addWidget(title)

        # Bot√≥n nueva nota
        new_note_btn = QPushButton("‚ûï New Note")
        new_note_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4a90e2, stop:1 #26de81);
                color: #ffffff;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 11pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #5ba0f2, stop:1 #36ee91);
            }
        """)
        new_note_btn.clicked.connect(self.create_new_note)
        title_row.addWidget(new_note_btn)
        title_row.addStretch()

        header_layout.addLayout(title_row)

        # Segunda fila: B√∫squeda y filtros
        search_row = QHBoxLayout()

        # Barra de b√∫squeda
        search_input = QLineEdit()
        search_input.setPlaceholderText("üîç Search notes...")
        search_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                padding: 8px 15px;
                color: #ffffff;
                font-size: 11pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
                background-color: rgba(42, 42, 42, 0.9);
            }
        """)
        search_input.textChanged.connect(self.filter_notes)
        search_row.addWidget(search_input)

        # Filtro por estado
        filter_combo = QComboBox()
        filter_combo.addItems(["All Notes", "Pinned", "Recent", "This Week"])
        filter_combo.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                color: #ffffff;
                padding: 8px 15px;
                font-size: 11pt;
            }
            QComboBox:focus {
                border: 2px solid #4a90e2;
            }
        """)
        filter_combo.currentTextChanged.connect(self.filter_notes_by_type)
        search_row.addWidget(filter_combo)

        # Bot√≥n de ordenamiento
        sort_btn = QPushButton("üìä Sort")
        sort_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                color: #ffffff;
                padding: 8px 15px;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.8);
                border: 1px solid #4a90e2;
            }
        """)
        sort_btn.clicked.connect(self.show_sort_menu)
        search_row.addWidget(sort_btn)

        header_layout.addLayout(search_row)
        layout.addLayout(header_layout)

        # Lista de notas con scroll
        notes_scroll = QScrollArea()
        notes_scroll.setWidgetResizable(True)
        notes_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        notes_scroll.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QScrollBar:vertical {
                background-color: rgba(42, 42, 42, 0.8);
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5ba0f2;
            }
        """)

        # Widget contenedor de notas
        self.notes_container = QWidget()
        self.notes_layout = QVBoxLayout(self.notes_container)
        self.notes_layout.setContentsMargins(0, 0, 0, 0)
        self.notes_layout.setSpacing(10)
        self.notes_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        notes_scroll.setWidget(self.notes_container)
        layout.addWidget(notes_scroll)

        # Variables para filtros
        self.search_text = ""
        self.current_filter = "All Notes"
        self.sort_order = "newest"

        # Cargar notas existentes
        self.load_notes_to_list()

        return view

    def create_tasks_view(self):
        """Crear vista de tareas completamente funcional"""
        view = QWidget()
        layout = QVBoxLayout(view)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Header con filtros
        header_layout = QVBoxLayout()

        # Primera fila: T√≠tulo y bot√≥n nueva tarea
        title_row = QHBoxLayout()
        title = QLabel("Tasks")
        title.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        title_row.addWidget(title)

        # Bot√≥n nueva tarea
        new_task_btn = QPushButton("‚ûï New Task")
        new_task_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4a90e2, stop:1 #26de81);
                color: #ffffff;
                border: none;
                border-radius: 20px;
                padding: 10px 20px;
                font-size: 11pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #5ba0f2, stop:1 #36ee91);
            }
        """)
        new_task_btn.clicked.connect(self.create_new_task_dialog)
        title_row.addWidget(new_task_btn)
        title_row.addStretch()

        header_layout.addLayout(title_row)

        # Segunda fila: Filtros y b√∫squeda
        filter_row = QHBoxLayout()

        # B√∫squeda de tareas
        search_input = QLineEdit()
        search_input.setPlaceholderText("üîç Search tasks...")
        search_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 20px;
                padding: 8px 15px;
                color: #ffffff;
                font-size: 11pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
                background-color: rgba(42, 42, 42, 0.9);
            }
        """)
        search_input.textChanged.connect(self.filter_tasks)
        filter_row.addWidget(search_input)

        # Filtro por estado
        status_filter = QComboBox()
        status_filter.addItems(
            ["All Tasks", "Pending", "Completed", "High Priority", "Due Today"]
        )
        status_filter.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                color: #ffffff;
                padding: 8px 15px;
                font-size: 11pt;
            }
            QComboBox:focus {
                border: 2px solid #4a90e2;
            }
        """)
        status_filter.currentTextChanged.connect(self.filter_tasks_by_status)
        filter_row.addWidget(status_filter)

        # Bot√≥n de ordenamiento
        sort_btn = QPushButton("üìä Sort")
        sort_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                color: #ffffff;
                padding: 8px 15px;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.8);
                border: 1px solid #4a90e2;
            }
        """)
        sort_btn.clicked.connect(self.show_task_sort_menu)
        filter_row.addWidget(sort_btn)

        header_layout.addLayout(filter_row)
        layout.addLayout(header_layout)

        # Lista de tareas con scroll
        tasks_scroll = QScrollArea()
        tasks_scroll.setWidgetResizable(True)
        tasks_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        tasks_scroll.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QScrollBar:vertical {
                background-color: rgba(42, 42, 42, 0.8);
                width: 12px;
                border-radius: 6px;
            }
            QScrollBar::handle:vertical {
                background-color: #217346;
                border-radius: 6px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5ba0f2;
            }
        """)

        # Widget contenedor de tareas
        self.tasks_container = QWidget()
        self.tasks_layout = QVBoxLayout(self.tasks_container)
        self.tasks_layout.setContentsMargins(0, 0, 0, 0)
        self.tasks_layout.setSpacing(10)
        self.tasks_layout.setAlignment(Qt.AlignmentFlag.AlignTop)

        tasks_scroll.setWidget(self.tasks_container)
        layout.addWidget(tasks_scroll)

        # Variables para filtros de tareas
        self.task_search_text = ""
        self.current_task_filter = "All Tasks"
        self.task_sort_order = "newest"

        # Cargar tareas existentes
        self.load_tasks_to_list()

        return view

    def create_tags_view(self):
        """Crear vista de etiquetas"""
        view = QWidget()
        layout = QVBoxLayout(view)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title = QLabel("Tags")
        title.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        layout.addWidget(title)

        # Lista de etiquetas
        self.tags_list = QListWidget()
        self.tags_list.setStyleSheet("""
            QListWidget {
                background-color: transparent;
                border: none;
                color: #ffffff;
            }
            QListWidget::item {
                background-color: rgba(42, 42, 42, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                padding: 15px;
                margin: 5px 0px;
            }
            QListWidget::item:selected {
                background-color: rgba(74, 144, 226, 0.8);
                border: 2px solid #4a90e2;
            }
            QListWidget::item:hover {
                background-color: rgba(58, 58, 58, 0.8);
            }
        """)
        layout.addWidget(self.tags_list)

        return view

    def create_calendar_view(self):
        """Crear vista de calendario"""
        view = QWidget()
        layout = QVBoxLayout(view)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title = QLabel("Calendar")
        title.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        layout.addWidget(title)

        # Widget de calendario completo
        self.calendar_widget = QCalendarWidget()
        self.calendar_widget.setStyleSheet("""
            QCalendarWidget {
                background-color: rgba(42, 42, 42, 0.8);
                color: #ffffff;
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
            }
            QCalendarWidget QWidget {
                background-color: transparent;
            }
            QCalendarWidget QAbstractItemView:enabled {
                background-color: rgba(42, 42, 42, 0.8);
                color: #ffffff;
                selection-background-color: #217346;
            }
            QCalendarWidget QAbstractItemView:disabled {
                color: #888888;
            }
        """)
        layout.addWidget(self.calendar_widget)

        return view

    def create_settings_view(self):
        """Crear vista de configuraci√≥n"""
        view = QWidget()
        layout = QVBoxLayout(view)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        title = QLabel("Settings")
        title.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        layout.addWidget(title)

        # Configuraciones
        settings_group = QWidget()
        settings_layout = QVBoxLayout(settings_group)
        settings_layout.setSpacing(10)

        # Tema
        theme_label = QLabel("Theme:")
        theme_label.setStyleSheet("color: #ffffff; font-size: 12pt;")
        settings_layout.addWidget(theme_label)

        theme_combo = QComboBox()
        theme_combo.addItems(["Dark", "Light", "Auto"])
        theme_combo.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                color: #ffffff;
                padding: 8px;
            }
        """)
        settings_layout.addWidget(theme_combo)

        # Idioma
        language_label = QLabel("Language:")
        language_label.setStyleSheet("color: #ffffff; font-size: 12pt;")
        settings_layout.addWidget(language_label)

        language_combo = QComboBox()
        language_combo.addItems(["English", "Espa√±ol", "Fran√ßais"])
        language_combo.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                color: #ffffff;
                padding: 8px;
            }
        """)
        settings_layout.addWidget(language_combo)

        layout.addWidget(settings_group)
        layout.addStretch()

        return view

    def create_new_note(self):
        """Crear nueva nota"""
        import uuid
        from datetime import datetime, timedelta

        new_note = {
            "id": str(uuid.uuid4()),
            "title": "New Note",
            "content": "",
            "created": datetime.now().isoformat(),
            "modified": datetime.now().isoformat(),
            "pinned": False,
        }

        self.notes.append(new_note)
        self.data_changed.emit()

        # Si estamos en vista de notas, actualizar la lista
        if hasattr(self, "notes_list"):
            self.load_notes_to_list()

        # Abrir en el panel flotante
        self.open_note_in_floating_panel(new_note)

    def create_new_task_dialog(self):
        """Mostrar di√°logo para crear nueva tarea"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Create New Task")
        dialog.setFixedSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #ffffff;
                color: #333333;
            }
        """)

        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(20)

        # T√≠tulo
        title_label = QLabel("Create New Task")
        title_label.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        layout.addWidget(title_label)

        # Nombre de la tarea
        name_label = QLabel("Task Name:")
        name_label.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        layout.addWidget(name_label)

        name_input = QLineEdit()
        name_input.setPlaceholderText("Enter task name...")
        name_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(name_input)

        # Prioridad
        priority_label = QLabel("Priority:")
        priority_label.setStyleSheet(
            "color: #ffffff; font-size: 12pt; font-weight: bold;"
        )
        layout.addWidget(priority_label)

        priority_combo = QComboBox()
        priority_combo.addItems(["Low", "Medium", "High", "Critical"])
        priority_combo.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #ffffff;
                padding: 12px;
                font-size: 12pt;
            }
            QComboBox:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(priority_combo)

        # Fecha de vencimiento
        due_date_label = QLabel("Due Date (Optional):")
        due_date_label.setStyleSheet(
            "color: #ffffff; font-size: 12pt; font-weight: bold;"
        )
        layout.addWidget(due_date_label)

        due_date_input = QLineEdit()
        due_date_input.setPlaceholderText("YYYY-MM-DD (e.g., 2024-12-25)")
        due_date_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(due_date_input)

        # Descripci√≥n
        desc_label = QLabel("Description:")
        desc_label.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        layout.addWidget(desc_label)

        desc_input = QTextEdit()
        desc_input.setPlaceholderText("Enter task description...")
        desc_input.setMaximumHeight(100)
        desc_input.setStyleSheet("""
            QTextEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QTextEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(desc_input)

        # Botones
        button_layout = QHBoxLayout()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 8px;
                color: #ffffff;
                padding: 12px 24px;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_btn)

        create_btn = QPushButton("Create Task")
        create_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4a90e2, stop:1 #26de81);
                border: none;
                border-radius: 8px;
                color: #ffffff;
                padding: 12px 24px;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #5ba0f2, stop:1 #36ee91);
            }
        """)
        create_btn.clicked.connect(
            lambda: self.create_task_from_dialog(
                name_input.text(),
                priority_combo.currentText(),
                due_date_input.text(),
                desc_input.toPlainText(),
                dialog,
            )
        )
        button_layout.addWidget(create_btn)

        layout.addLayout(button_layout)

        # Mostrar di√°logo
        dialog.exec()

    def create_task_from_dialog(self, name, priority, due_date, description, dialog):
        """Crear tarea desde el di√°logo"""
        if not name.strip():
            return

        # Validar fecha si se proporciona
        due_date_iso = None
        if due_date.strip():
            try:
                due_date_iso = datetime.strptime(
                    due_date.strip(), "%Y-%m-%d"
                ).isoformat()
            except ValueError:
                # Si la fecha no es v√°lida, usar None
                due_date_iso = None

        task_id = str(uuid.uuid4())
        task = {
            "id": task_id,
            "title": name.strip(),
            "priority": priority,
            "due_date": due_date_iso,
            "description": description.strip(),
            "completed": False,
            "created": datetime.now().isoformat(),
            "modified": datetime.now().isoformat(),
        }

        self.tasks.append(task)
        self.load_tasks_to_list()
        self.data_changed.emit()
        dialog.accept()

    def create_new_task(self):
        """Crear nueva tarea (m√©todo legacy para compatibilidad)"""
        self.create_new_task_dialog()

    def load_notes_to_list(self):
        """Cargar notas en la lista con funcionalidad completa"""
        if not hasattr(self, "notes_layout"):
            return

        # Limpiar layout existente
        while self.notes_layout.count():
            item = self.notes_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Filtrar notas seg√∫n criterios
        filtered_notes = self.get_filtered_notes()

        # Ordenar notas
        sorted_notes = self.sort_notes(filtered_notes)

        # Mostrar mensaje si no hay notas
        if not sorted_notes:
            empty_label = QLabel(
                "üìù No hay notas\n\n‚ûï Haz clic en 'New Note' para crear tu primera nota"
            )
            empty_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            empty_label.setStyleSheet("""
                QLabel {
                    color: #888888;
                    font-size: 14pt;
                    padding: 50px;
                }
            """)
            self.notes_layout.addWidget(empty_label)
            return

        # Crear tarjetas de notas
        for note in sorted_notes:
            note_card = self.create_note_card(note)
            self.notes_layout.addWidget(note_card)

    def get_filtered_notes(self):
        """Obtener notas filtradas seg√∫n criterios"""
        filtered = []

        for note in self.notes:
            # Filtro por texto de b√∫squeda
            if self.search_text:
                search_lower = self.search_text.lower()
                title_match = self.search_text.lower() in note.get("title", "").lower()
                content_match = (
                    self.search_text.lower() in note.get("content", "").lower()
                )
                if not (title_match or content_match):
                    continue

            # Filtro por tipo
            if self.current_filter == "Pinned" and not note.get("pinned", False):
                continue
            elif self.current_filter == "Recent":
                # Notas de los √∫ltimos 7 d√≠as
                note_date = (
                    datetime.fromisoformat(note.get("modified", ""))
                    if note.get("modified")
                    else datetime.min
                )
                if (datetime.now() - note_date).days > 7:
                    continue
            elif self.current_filter == "This Week":
                # Notas de esta semana
                note_date = (
                    datetime.fromisoformat(note.get("modified", ""))
                    if note.get("modified")
                    else datetime.min
                )
                week_start = datetime.now() - timedelta(days=datetime.now().weekday())
                if note_date < week_start:
                    continue

            filtered.append(note)

        return filtered

    def sort_notes(self, notes):
        """Ordenar notas seg√∫n criterio seleccionado"""
        if self.sort_order == "newest":
            return sorted(notes, key=lambda x: x.get("modified", ""), reverse=True)
        elif self.sort_order == "oldest":
            return sorted(notes, key=lambda x: x.get("modified", ""))
        elif self.sort_order == "title":
            return sorted(notes, key=lambda x: x.get("title", "").lower())
        elif self.sort_order == "pinned":
            return sorted(
                notes,
                key=lambda x: (not x.get("pinned", False), x.get("modified", "")),
                reverse=True,
            )
        else:
            return notes

    def create_note_card(self, note):
        """Crear tarjeta de nota interactiva"""
        card = QWidget()
        card.setStyleSheet("""
            QWidget {
                background-color: rgba(42, 42, 42, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                margin: 5px 0px;
            }
            QWidget:hover {
                background-color: rgba(58, 58, 58, 0.8);
                border: 2px solid rgba(74, 144, 226, 0.5);
            }
        """)
        card.setCursor(Qt.CursorShape.PointingHandCursor)

        layout = QVBoxLayout(card)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(8)

        # Header con t√≠tulo y acciones
        header_layout = QHBoxLayout()

        # T√≠tulo
        title_label = QLabel(note.get("title", "Untitled"))
        title_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 14pt;
                font-weight: bold;
            }
        """)
        title_label.setWordWrap(True)
        header_layout.addWidget(title_label)

        # Botones de acci√≥n
        actions_layout = QHBoxLayout()
        actions_layout.setSpacing(5)

        # Bot√≥n pin/unpin
        pin_btn = QPushButton("üìå" if note.get("pinned", False) else "üìç")
        pin_btn.setFixedSize(25, 25)
        pin_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #4a90e2;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.3);
                border-radius: 12px;
            }
        """)
        pin_btn.clicked.connect(lambda: self.toggle_note_pin(note))
        actions_layout.addWidget(pin_btn)

        # Bot√≥n eliminar
        delete_btn = QPushButton("üóëÔ∏è")
        delete_btn.setFixedSize(25, 25)
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #ff5555;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(255, 85, 85, 0.3);
                border-radius: 12px;
            }
        """)
        delete_btn.clicked.connect(lambda: self.delete_note(note))
        actions_layout.addWidget(delete_btn)

        header_layout.addLayout(actions_layout)
        layout.addLayout(header_layout)

        # Contenido preview
        content = note.get("content", "")
        if content:
            content_preview = content[:150] + "..." if len(content) > 150 else content
            content_label = QLabel(content_preview)
            content_label.setStyleSheet("""
                QLabel {
                    color: #cccccc;
                    font-size: 11pt;
                    line-height: 1.4;
                }
            """)
            content_label.setWordWrap(True)
            layout.addWidget(content_label)

        # Footer con fecha y etiquetas
        footer_layout = QHBoxLayout()

        # Fecha
        date_str = note.get("modified", "")
        if date_str:
            try:
                note_date = datetime.fromisoformat(date_str)
                formatted_date = note_date.strftime("%d %b %Y")
            except:
                formatted_date = date_str[:10]
        else:
            formatted_date = "Unknown"

        date_label = QLabel(f"üìÖ {formatted_date}")
        date_label.setStyleSheet("""
            QLabel {
                color: #888888;
                font-size: 10pt;
            }
        """)
        footer_layout.addWidget(date_label)

        footer_layout.addStretch()

        # Indicador de estado
        if note.get("pinned", False):
            status_label = QLabel("üìå Pinned")
            status_label.setStyleSheet("""
                QLabel {
                    color: #4a90e2;
                    font-size: 10pt;
                    font-weight: bold;
                }
            """)
            footer_layout.addWidget(status_label)

        layout.addLayout(footer_layout)

        # Conectar click para abrir nota
        def open_note():
            self.open_note_in_floating_panel(note)

        card.mousePressEvent = lambda event: open_note()

        return card

    def load_tasks_to_list(self):
        """Cargar tareas en la lista con funcionalidad completa"""
        if not hasattr(self, "tasks_layout"):
            return

        # Limpiar layout existente
        while self.tasks_layout.count():
            child = self.tasks_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        # Filtrar y ordenar tareas
        filtered_tasks = self.get_filtered_tasks()
        sorted_tasks = self.sort_tasks(filtered_tasks)

        for task in sorted_tasks:
            task_widget = self.create_task_widget(task)
            self.tasks_layout.addWidget(task_widget)

    def create_task_widget(self, task):
        """Crear widget personalizado para una tarea"""
        task_widget = QWidget()
        task_widget.setStyleSheet("""
            QWidget {
                background-color: rgba(42, 42, 42, 0.6);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                margin: 5px 0px;
            }
            QWidget:hover {
                background-color: rgba(58, 58, 58, 0.8);
                border: 1px solid rgba(74, 144, 226, 0.5);
            }
        """)

        layout = QVBoxLayout(task_widget)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        # Fila superior: Checkbox, t√≠tulo y prioridad
        top_row = QHBoxLayout()

        # Checkbox
        checkbox = QCheckBox()
        checkbox.setChecked(task.get("completed", False))
        checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 20px;
                height: 20px;
                border: 2px solid #4a90e2;
                border-radius: 4px;
                background-color: transparent;
            }
            QCheckBox::indicator:checked {
                background-color: #217346;
                image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAxMiAxMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEwIDNMNC41IDguNUwyIDYiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjwvc3ZnPgo=);
            }
        """)
        checkbox.stateChanged.connect(lambda state: self.toggle_task(task["id"], state))
        top_row.addWidget(checkbox)

        # T√≠tulo
        title_label = QLabel(task.get("title", "Untitled Task"))
        if task.get("completed", False):
            title_label.setStyleSheet(
                "color: #888888; font-size: 14pt; font-weight: bold; text-decoration: line-through;"
            )
        else:
            title_label.setStyleSheet(
                "color: #ffffff; font-size: 14pt; font-weight: bold;"
            )
        top_row.addWidget(title_label)

        top_row.addStretch()

        # Prioridad
        priority = task.get("priority", "Medium")
        priority_colors = {
            "Low": "#26de81",
            "Medium": "#4a90e2",
            "High": "#ff9f43",
            "Critical": "#ff4444",
        }
        priority_color = priority_colors.get(priority, "#4a90e2")

        priority_label = QLabel(priority)
        priority_label.setStyleSheet(f"""
            QLabel {{
                background-color: {priority_color};
                color: #ffffff;
                border-radius: 12px;
                padding: 4px 12px;
                font-size: 10pt;
                font-weight: bold;
            }}
        """)
        top_row.addWidget(priority_label)

        layout.addLayout(top_row)

        # Descripci√≥n (si existe)
        description = task.get("description", "").strip()
        if description:
            desc_label = QLabel(description)
            desc_label.setStyleSheet(
                "color: #cccccc; font-size: 11pt; line-height: 1.4;"
            )
            desc_label.setWordWrap(True)
            desc_label.setMaximumHeight(60)
            layout.addWidget(desc_label)

        # Fila inferior: Fechas y acciones
        bottom_row = QHBoxLayout()

        # Fecha de creaci√≥n
        created_date = task.get("created", "")
        if created_date:
            try:
                date_obj = datetime.fromisoformat(created_date)
                date_str = date_obj.strftime("%Y-%m-%d")
                created_label = QLabel(f"Created: {date_str}")
                created_label.setStyleSheet("color: #888888; font-size: 10pt;")
                bottom_row.addWidget(created_label)
            except:
                pass

        # Fecha de vencimiento
        due_date = task.get("due_date")
        if due_date:
            try:
                due_date_obj = datetime.fromisoformat(due_date)
                due_str = due_date_obj.strftime("%Y-%m-%d")
                today = datetime.now().date()
                due_date_only = due_date_obj.date()

                if due_date_only < today:
                    due_label = QLabel(f"‚ö†Ô∏è Overdue: {due_str}")
                    due_label.setStyleSheet(
                        "color: #ff4444; font-size: 10pt; font-weight: bold;"
                    )
                elif due_date_only == today:
                    due_label = QLabel(f"üî• Due today: {due_str}")
                    due_label.setStyleSheet(
                        "color: #ff9f43; font-size: 10pt; font-weight: bold;"
                    )
                else:
                    due_label = QLabel(f"üìÖ Due: {due_str}")
                    due_label.setStyleSheet("color: #4a90e2; font-size: 10pt;")

                bottom_row.addWidget(due_label)
            except:
                pass

        bottom_row.addStretch()

        # Botones de acci√≥n
        action_layout = QHBoxLayout()

        # Bot√≥n editar
        edit_btn = QPushButton("‚úèÔ∏è")
        edit_btn.setFixedSize(30, 30)
        edit_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(74, 144, 226, 0.3);
                border: 1px solid #4a90e2;
                border-radius: 15px;
                color: #4a90e2;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(74, 144, 226, 0.8);
                color: #ffffff;
            }
        """)
        edit_btn.clicked.connect(lambda: self.edit_task(task))
        action_layout.addWidget(edit_btn)

        # Bot√≥n eliminar
        delete_btn = QPushButton("üóëÔ∏è")
        delete_btn.setFixedSize(30, 30)
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 68, 68, 0.3);
                border: 1px solid #ff4444;
                border-radius: 15px;
                color: #ff4444;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(255, 68, 68, 0.8);
                color: #ffffff;
            }
        """)
        delete_btn.clicked.connect(lambda: self.delete_task(task["id"]))
        action_layout.addWidget(delete_btn)

        bottom_row.addLayout(action_layout)
        layout.addLayout(bottom_row)

        return task_widget

    def get_filtered_tasks(self):
        """Obtener tareas filtradas seg√∫n criterios actuales"""
        filtered = self.tasks.copy()

        # Filtro por texto de b√∫squeda
        if hasattr(self, "task_search_text") and self.task_search_text:
            search_text = self.task_search_text.lower()
            filtered = [
                task
                for task in filtered
                if search_text in task.get("title", "").lower()
                or search_text in task.get("description", "").lower()
            ]

        # Filtro por estado
        if hasattr(self, "current_task_filter"):
            if self.current_task_filter == "Pending":
                filtered = [
                    task for task in filtered if not task.get("completed", False)
                ]
            elif self.current_task_filter == "Completed":
                filtered = [task for task in filtered if task.get("completed", False)]
            elif self.current_task_filter == "High Priority":
                filtered = [
                    task
                    for task in filtered
                    if task.get("priority", "Medium") in ["High", "Critical"]
                ]
            elif self.current_task_filter == "Due Today":
                today = datetime.now().date()
                filtered = [
                    task
                    for task in filtered
                    if task.get("due_date")
                    and datetime.fromisoformat(task["due_date"]).date() == today
                ]

        return filtered

    def sort_tasks(self, tasks):
        """Ordenar tareas seg√∫n criterio actual"""
        if not hasattr(self, "task_sort_order"):
            return tasks

        if self.task_sort_order == "newest":
            return sorted(tasks, key=lambda x: x.get("created", ""), reverse=True)
        elif self.task_sort_order == "oldest":
            return sorted(tasks, key=lambda x: x.get("created", ""))
        elif self.task_sort_order == "priority":
            priority_order = {"Critical": 0, "High": 1, "Medium": 2, "Low": 3}
            return sorted(
                tasks, key=lambda x: priority_order.get(x.get("priority", "Medium"), 2)
            )
        elif self.task_sort_order == "due_date":
            return sorted(tasks, key=lambda x: x.get("due_date", "9999-12-31"))
        else:
            return tasks

    def filter_tasks(self, search_text):
        """Filtrar tareas por texto de b√∫squeda"""
        self.task_search_text = search_text
        self.load_tasks_to_list()

    def filter_tasks_by_status(self, status):
        """Filtrar tareas por estado"""
        self.current_task_filter = status
        self.load_tasks_to_list()

    def show_task_sort_menu(self):
        """Mostrar men√∫ de ordenamiento de tareas"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #ffffff;
            }
            QMenu::item {
                padding: 8px 16px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: rgba(74, 144, 226, 0.8);
            }
        """)

        sort_options = [
            ("üìÖ Newest First", "newest"),
            ("üìÖ Oldest First", "oldest"),
            ("‚≠ê By Priority", "priority"),
            ("üìÜ By Due Date", "due_date"),
        ]

        for text, value in sort_options:
            action = menu.addAction(text)
            action.triggered.connect(
                lambda checked, v=value: self.set_task_sort_order(v)
            )

        # Mostrar men√∫ en la posici√≥n del bot√≥n
        button = self.sender()
        menu.exec(button.mapToGlobal(button.rect().bottomLeft()))

    def set_task_sort_order(self, order):
        """Establecer orden de tareas"""
        self.task_sort_order = order
        self.load_tasks_to_list()

    def edit_task(self, task):
        """Editar tarea existente"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Task")
        dialog.setFixedSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #ffffff;
                color: #333333;
            }
        """)

        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(30, 30, 30, 30)
        layout.setSpacing(20)

        # T√≠tulo
        title_label = QLabel("Edit Task")
        title_label.setStyleSheet("color: #ffffff; font-size: 18pt; font-weight: bold;")
        layout.addWidget(title_label)

        # Nombre de la tarea
        name_label = QLabel("Task Name:")
        name_label.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        layout.addWidget(name_label)

        name_input = QLineEdit(task.get("title", ""))
        name_input.setPlaceholderText("Enter task name...")
        name_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(name_input)

        # Prioridad
        priority_label = QLabel("Priority:")
        priority_label.setStyleSheet(
            "color: #ffffff; font-size: 12pt; font-weight: bold;"
        )
        layout.addWidget(priority_label)

        priority_combo = QComboBox()
        priority_combo.addItems(["Low", "Medium", "High", "Critical"])
        priority_combo.setCurrentText(task.get("priority", "Medium"))
        priority_combo.setStyleSheet("""
            QComboBox {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #ffffff;
                padding: 12px;
                font-size: 12pt;
            }
            QComboBox:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(priority_combo)

        # Fecha de vencimiento
        due_date_label = QLabel("Due Date (Optional):")
        due_date_label.setStyleSheet(
            "color: #ffffff; font-size: 12pt; font-weight: bold;"
        )
        layout.addWidget(due_date_label)

        due_date_input = QLineEdit()
        if task.get("due_date"):
            try:
                due_date_obj = datetime.fromisoformat(task["due_date"])
                due_date_input.setText(due_date_obj.strftime("%Y-%m-%d"))
            except:
                pass
        due_date_input.setPlaceholderText("YYYY-MM-DD (e.g., 2024-12-25)")
        due_date_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(due_date_input)

        # Descripci√≥n
        desc_label = QLabel("Description:")
        desc_label.setStyleSheet("color: #ffffff; font-size: 12pt; font-weight: bold;")
        layout.addWidget(desc_label)

        desc_input = QTextEdit()
        desc_input.setPlainText(task.get("description", ""))
        desc_input.setPlaceholderText("Enter task description...")
        desc_input.setMaximumHeight(100)
        desc_input.setStyleSheet("""
            QTextEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                padding: 12px;
                color: #ffffff;
                font-size: 12pt;
            }
            QTextEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        layout.addWidget(desc_input)

        # Botones
        button_layout = QHBoxLayout()

        cancel_btn = QPushButton("Cancel")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 8px;
                color: #ffffff;
                padding: 12px 24px;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.2);
            }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_btn)

        save_btn = QPushButton("Save Changes")
        save_btn.setStyleSheet("""
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #4a90e2, stop:1 #26de81);
                border: none;
                border-radius: 8px;
                color: #ffffff;
                padding: 12px 24px;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0,
                    stop:0 #5ba0f2, stop:1 #36ee91);
            }
        """)
        save_btn.clicked.connect(
            lambda: self.save_task_changes(
                task["id"],
                name_input.text(),
                priority_combo.currentText(),
                due_date_input.text(),
                desc_input.toPlainText(),
                dialog,
            )
        )
        button_layout.addWidget(save_btn)

        layout.addLayout(button_layout)

        # Mostrar di√°logo
        dialog.exec()

    def save_task_changes(self, task_id, name, priority, due_date, description, dialog):
        """Guardar cambios en la tarea"""
        if not name.strip():
            return

        # Buscar y actualizar la tarea
        for task in self.tasks:
            if task["id"] == task_id:
                task["title"] = name.strip()
                task["priority"] = priority
                task["description"] = description.strip()
                task["modified"] = datetime.now().isoformat()

                # Validar fecha si se proporciona
                if due_date.strip():
                    try:
                        task["due_date"] = datetime.strptime(
                            due_date.strip(), "%Y-%m-%d"
                        ).isoformat()
                    except ValueError:
                        task["due_date"] = None
                else:
                    task["due_date"] = None

                break

        self.load_tasks_to_list()
        self.data_changed.emit()
        dialog.accept()

    def delete_task(self, task_id):
        """Eliminar tarea"""
        # Confirmar eliminaci√≥n
        reply = QMessageBox.question(
            self,
            "Delete Task",
            "Are you sure you want to delete this task?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.tasks = [task for task in self.tasks if task["id"] != task_id]
            self.load_tasks_to_list()
            self.data_changed.emit()

    def on_note_clicked(self, item):
        """Manejar click en nota"""
        note_data = getattr(item, "note_data", None)
        if note_data:
            self.open_note_in_floating_panel(note_data)

    def open_note_in_floating_panel(self, note_data):
        """Abrir nota en el panel flotante"""
        # Mostrar el panel flotante
        self.floating_notes_panel.show()

        # Actualizar contenido del panel flotante
        self.update_floating_panel_content(note_data)

    def update_floating_panel_content(self, note_data):
        """Actualizar contenido del panel flotante"""
        # Buscar los widgets en el panel flotante
        content_area = self.floating_notes_panel.findChild(QWidget)
        if content_area:
            # Buscar el QTextEdit en el contenido
            text_edit = content_area.findChild(QTextEdit)
            if text_edit:
                text_edit.setPlainText(note_data.get("content", ""))
                # Conectar cambios para guardar autom√°ticamente
                text_edit.textChanged.connect(
                    lambda: self.save_note_content(note_data, text_edit.toPlainText())
                )

    def save_note_content(self, note_data, content):
        """Guardar contenido de la nota"""
        note_data["content"] = content
        note_data["modified"] = datetime.now().isoformat()
        self.data_changed.emit()

    def make_pinned_notes_interactive(self):
        """Hacer interactivas las notas fijadas"""
        # Esta funci√≥n se llamar√° para conectar eventos a las notas fijadas
        pass

    def make_tasks_interactive(self):
        """Hacer interactivas las tareas"""
        # Esta funci√≥n se llamar√° para conectar eventos a las tareas
        pass

    def setup_floating_panel_functionality(self):
        """Configurar funcionalidad del panel flotante"""
        # Conectar botones del panel flotante
        save_btn = self.floating_notes_panel.findChild(QPushButton)
        if save_btn and save_btn.text() == "‚úì":
            save_btn.clicked.connect(self.save_current_note)

    def save_current_note(self):
        """Guardar nota actual"""
        # Implementar l√≥gica de guardado
        self.data_changed.emit()
        print("Nota guardada")

    def setup_calendar_functionality(self):
        """Configurar funcionalidad del calendario"""
        if hasattr(self, "calendar_widget"):
            self.calendar_widget.selectionChanged.connect(
                self.on_calendar_date_selected
            )

    def on_calendar_date_selected(self):
        """Manejar selecci√≥n de fecha en calendario"""
        selected_date = self.calendar_widget.selectedDate()
        print(f"Fecha seleccionada: {selected_date.toString()}")

    def setup_search_functionality(self):
        """Configurar funcionalidad de b√∫squeda"""
        # Implementar b√∫squeda global
        pass

    def filter_notes_by_tag(self, tag):
        """Filtrar notas por etiqueta"""
        # Implementar filtrado por etiquetas
        pass

    def export_data(self):
        """Exportar datos del dashboard"""
        # Implementar exportaci√≥n de datos
        pass

    def import_data(self, data):
        """Importar datos al dashboard"""
        # Implementar importaci√≥n de datos
        pass

    def open_pinned_note(self, note_title):
        """Abrir nota fijada"""
        print(f"Abriendo nota fijada: {note_title}")
        # Crear o buscar la nota fijada
        note_data = {
            "id": f"pinned_{note_title.lower().replace(' ', '_')}",
            "title": note_title,
            "content": f"Contenido de {note_title}...",
            "pinned": True,
            "created": datetime.now().isoformat(),
            "modified": datetime.now().isoformat(),
        }
        self.open_note_in_floating_panel(note_data)

    def toggle_task(self, task_id, state):
        """Alternar estado de tarea"""
        # Buscar la tarea por ID
        for task in self.tasks:
            if task.get("id") == task_id:
                task["completed"] = state == Qt.CheckState.Checked.value
                task["modified"] = datetime.now().isoformat()
                break

        self.data_changed.emit()

    def previous_month(self):
        """Navegar al mes anterior"""
        if self.current_date.month == 1:
            self.current_date = self.current_date.replace(
                year=self.current_date.year - 1, month=12
            )
        else:
            self.current_date = self.current_date.replace(
                month=self.current_date.month - 1
            )
        self.update_calendar_display()

    def next_month(self):
        """Navegar al mes siguiente"""
        if self.current_date.month == 12:
            self.current_date = self.current_date.replace(
                year=self.current_date.year + 1, month=1
            )
        else:
            self.current_date = self.current_date.replace(
                month=self.current_date.month + 1
            )
        self.update_calendar_display()

    def update_calendar_display(self):
        """Actualizar la visualizaci√≥n del calendario"""
        # Limpiar d√≠as existentes
        while self.days_layout.count():
            item = self.days_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()

        # Actualizar t√≠tulo del mes
        month_names = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ]
        self.month_label.setText(
            f"{month_names[self.current_date.month - 1]} {self.current_date.year}"
        )

        # Obtener primer d√≠a del mes y cu√°ntos d√≠as tiene
        first_day = self.current_date.replace(day=1)
        last_day = (
            first_day.replace(month=first_day.month + 1) - timedelta(days=1)
        ).day

        # Obtener d√≠a de la semana del primer d√≠a (0=Lunes, 6=Domingo)
        start_weekday = (first_day.weekday()) % 7  # Convertir a formato Lunes=0

        # Crear d√≠as del mes
        day_num = 1
        today = datetime.now()

        for week in range(6):  # M√°ximo 6 semanas
            for day in range(7):  # 7 d√≠as de la semana
                if week == 0 and day < start_weekday:
                    # D√≠as vac√≠os antes del primer d√≠a del mes
                    empty_label = QLabel("")
                    empty_label.setFixedSize(30, 30)
                    empty_label.setMinimumSize(30, 30)
                    self.days_layout.addWidget(empty_label, week, day)
                elif day_num <= last_day:
                    # Crear bot√≥n para el d√≠a
                    day_btn = QPushButton(str(day_num))
                    day_btn.setFixedSize(30, 30)
                    day_btn.setCursor(Qt.CursorShape.PointingHandCursor)
                    day_btn.setMinimumSize(30, 30)

                    # Verificar si es hoy
                    is_today = (
                        self.current_date.year == today.year
                        and self.current_date.month == today.month
                        and day_num == today.day
                    )

                    # Verificar si tiene eventos
                    date_key = f"{self.current_date.year}-{self.current_date.month:02d}-{day_num:02d}"
                    has_events = date_key in self.calendar_events

                    # Aplicar estilos seg√∫n el estado
                    if is_today:
                        day_btn.setStyleSheet("""
                            QPushButton {
                                color: #ffffff;
                                font-size: 12pt;
                                font-weight: bold;
                                background-color: #ff4444;
                                border: 2px solid #ff4444;
                                border-radius: 15px;
                                min-width: 30px;
                                min-height: 30px;
                            }
                            QPushButton:hover {
                                background-color: #ff6666;
                                border: 2px solid #ff6666;
                            }
                        """)
                    elif has_events:
                        day_btn.setStyleSheet("""
                            QPushButton {
                                color: #ffffff;
                                font-size: 12pt;
                                font-weight: bold;
                                background-color: #217346;
                                border: 2px solid #4a90e2;
                                border-radius: 15px;
                                min-width: 30px;
                                min-height: 30px;
                            }
                            QPushButton:hover {
                                background-color: #5ba0f2;
                                border: 2px solid #5ba0f2;
                            }
                        """)
                    else:
                        day_btn.setStyleSheet("""
                            QPushButton {
                                color: #ffffff;
                                font-size: 12pt;
                                font-weight: bold;
                                background-color: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 15px;
                                min-width: 30px;
                                min-height: 30px;
                            }
                            QPushButton:hover {
                                background-color: rgba(74, 144, 226, 0.8);
                                border: 2px solid #4a90e2;
                                color: #ffffff;
                            }
                        """)

                    # Conectar click del d√≠a
                    day_btn.clicked.connect(
                        lambda checked, d=day_num: self.on_date_clicked(d)
                    )

                    self.days_layout.addWidget(day_btn, week, day)
                    day_num += 1
                else:
                    # D√≠as vac√≠os despu√©s del √∫ltimo d√≠a del mes
                    empty_label = QLabel("")
                    empty_label.setFixedSize(30, 30)
                    empty_label.setMinimumSize(30, 30)
                    self.days_layout.addWidget(empty_label, week, day)

    def on_date_clicked(self, day):
        """Manejar click en un d√≠a del calendario"""
        selected_date = self.current_date.replace(day=day)
        date_str = selected_date.strftime("%Y-%m-%d")

        print(f"Fecha seleccionada: {selected_date.strftime('%d de %B de %Y')}")

        # Verificar si hay eventos para esta fecha
        if date_str in self.calendar_events:
            events = self.calendar_events[date_str]
            print(f"Eventos para esta fecha: {events}")
            self.show_date_events(selected_date, events)
        else:
            print("No hay eventos para esta fecha")
            self.show_date_events(selected_date, [])

    def show_date_events(self, date, events):
        """Mostrar eventos de una fecha espec√≠fica"""
        # Crear una nota autom√°tica para la fecha seleccionada
        date_note = {
            "id": f"date_{date.strftime('%Y%m%d')}",
            "title": f"Eventos del {date.strftime('%d de %B de %Y')}",
            "content": self.format_date_events(date, events),
            "created": datetime.now().isoformat(),
            "modified": datetime.now().isoformat(),
            "pinned": False,
        }

        # Abrir en el panel flotante
        self.open_note_in_floating_panel(date_note)

    def format_date_events(self, date, events):
        """Formatear eventos de una fecha"""
        if not events:
            return f"üìÖ {date.strftime('%d de %B de %Y')}\n\nNo hay eventos programados para esta fecha.\n\nüí° Puedes agregar notas o tareas para este d√≠a."

        content = f"üìÖ {date.strftime('%d de %B de %Y')}\n\n"
        for i, event in enumerate(events, 1):
            content += f"{i}. {event}\n"

        return content

    def add_calendar_event(self, date_str, event):
        """Agregar evento al calendario"""
        if date_str not in self.calendar_events:
            self.calendar_events[date_str] = []
        self.calendar_events[date_str].append(event)
        self.update_calendar_display()
        self.data_changed.emit()

    def remove_calendar_event(self, date_str, event):
        """Eliminar evento del calendario"""
        if date_str in self.calendar_events and event in self.calendar_events[date_str]:
            self.calendar_events[date_str].remove(event)
            if not self.calendar_events[date_str]:
                del self.calendar_events[date_str]
            self.update_calendar_display()
            self.data_changed.emit()

    def filter_notes(self, text):
        """Filtrar notas por texto de b√∫squeda"""
        self.search_text = text
        self.load_notes_to_list()

    def filter_notes_by_type(self, filter_type):
        """Filtrar notas por tipo"""
        self.current_filter = filter_type
        self.load_notes_to_list()

    def show_sort_menu(self):
        """Mostrar men√∫ de ordenamiento"""
        from PyQt6.QtWidgets import QMenu

        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: rgba(42, 42, 42, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                color: #ffffff;
                padding: 5px;
            }
            QMenu::item {
                padding: 8px 15px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: rgba(74, 144, 226, 0.8);
            }
        """)

        sort_options = [
            ("üìÖ Newest First", "newest"),
            ("üìÖ Oldest First", "oldest"),
            ("üî§ By Title", "title"),
            ("üìå Pinned First", "pinned"),
        ]

        for text, value in sort_options:
            action = menu.addAction(text)
            action.triggered.connect(lambda checked, v=value: self.set_sort_order(v))

        # Mostrar men√∫ en la posici√≥n del bot√≥n
        button = self.sender()
        menu.exec(button.mapToGlobal(button.rect().bottomLeft()))

    def set_sort_order(self, order):
        """Establecer orden de clasificaci√≥n"""
        self.sort_order = order
        self.load_notes_to_list()

    def toggle_note_pin(self, note):
        """Alternar estado de pin de una nota"""
        note["pinned"] = not note.get("pinned", False)
        note["modified"] = datetime.now().isoformat()
        self.data_changed.emit()
        self.load_notes_to_list()
        print(
            f"Nota {'fijada' if note['pinned'] else 'desfijada'}: {note.get('title', 'Untitled')}"
        )

    def delete_note(self, note):
        """Eliminar una nota"""
        from PyQt6.QtWidgets import QMessageBox

        reply = QMessageBox.question(
            self,
            "Confirmar eliminaci√≥n",
            f"¬øEst√°s seguro de que quieres eliminar la nota '{note.get('title', 'Untitled')}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            if note in self.notes:
                self.notes.remove(note)
                self.data_changed.emit()
                self.load_notes_to_list()
                print(f"Nota eliminada: {note.get('title', 'Untitled')}")

    def create_advanced_note_editor(self):
        """Crear editor avanzado de notas"""
        editor = QWidget()
        editor.setStyleSheet("""
            QWidget {
                background-color: rgba(35, 35, 35, 0.95);
                border-radius: 12px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
        """)

        layout = QVBoxLayout(editor)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Barra de herramientas
        toolbar = QHBoxLayout()

        # Botones de formato
        format_buttons = [
            ("B", "Bold"),
            ("I", "Italic"),
            ("U", "Underline"),
            ("üìù", "List"),
            ("üîó", "Link"),
            ("üìé", "Attachment"),
        ]

        for text, tooltip in format_buttons:
            btn = QPushButton(text)
            btn.setToolTip(tooltip)
            btn.setFixedSize(30, 30)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: rgba(42, 42, 42, 0.6);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 6px;
                    color: #ffffff;
                    font-size: 11pt;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: rgba(74, 144, 226, 0.8);
                    border: 1px solid #4a90e2;
                }
            """)
            toolbar.addWidget(btn)

        toolbar.addStretch()

        # Bot√≥n guardar
        save_btn = QPushButton("üíæ Save")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 6px;
                color: #ffffff;
                padding: 8px 16px;
                font-size: 11pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5ba0f2;
            }
        """)
        toolbar.addWidget(save_btn)

        layout.addLayout(toolbar)

        # Editor de texto
        text_editor = QTextEdit()
        text_editor.setStyleSheet("""
            QTextEdit {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 12pt;
                line-height: 1.6;
            }
        """)
        text_editor.setPlaceholderText("Escribe tu nota aqu√≠...")
        layout.addWidget(text_editor)

        return editor

    def add_sample_events(self):
        """Agregar eventos de ejemplo al calendario"""
        today = datetime.now()

        # Eventos para hoy
        today_str = today.strftime("%Y-%m-%d")
        self.calendar_events[today_str] = [
            "Reuni√≥n de equipo",
            "Revisar documentos",
            "Llamada con cliente",
        ]

        # Eventos para ma√±ana
        tomorrow = today + timedelta(days=1)
        tomorrow_str = tomorrow.strftime("%Y-%m-%d")
        self.calendar_events[tomorrow_str] = [
            "Presentaci√≥n del proyecto",
            "Entrega de reporte",
        ]

        # Eventos para la pr√≥xima semana
        next_week = today + timedelta(days=7)
        next_week_str = next_week.strftime("%Y-%m-%d")
        self.calendar_events[next_week_str] = [
            "Reuni√≥n de seguimiento",
            "Evaluaci√≥n de progreso",
        ]

        # Eventos para el d√≠a 23 (como en la imagen original)
        if today.month == 10:  # Si estamos en octubre
            day_23 = today.replace(day=23)
            day_23_str = day_23.strftime("%Y-%m-%d")
            self.calendar_events[day_23_str] = [
                "Evento importante",
                "Deadline del proyecto",
            ]


class NotesAndTasksTab(QWidget):
    """Pesta√±a profesional para gesti√≥n de notas y tareas"""
    
    data_changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.notes = []
        self.tasks = []
        self.current_note_index = None
        self.categories = ["Personal", "Trabajo", "Ideas", "Proyectos"]
        self.tags = []  # Etiquetas personalizadas
        self.priorities = ["üî¥ Alta", "üü° Media", "üü¢ Baja"]
        self.note_templates = {}  # Plantillas de notas
        self.archived_notes = []  # Notas archivadas
        self.note_history = {}  # Historial de versiones
        self.setup_ui()
        
    def setup_ui(self):
        """Configurar interfaz principal"""
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Panel lateral izquierdo (lista de notas)
        self.sidebar = self.create_sidebar()
        main_layout.addWidget(self.sidebar, 0)
        
        # √Årea central (editor de notas)
        self.editor_area = self.create_editor_area()
        main_layout.addWidget(self.editor_area, 1)
        
        # Panel derecho (tareas)
        self.tasks_panel = self.create_tasks_panel()
        main_layout.addWidget(self.tasks_panel, 0)
        
        # Configurar atajos de teclado
        self.setup_shortcuts()
        
    def setup_shortcuts(self):
        """Configurar atajos de teclado para formato"""
        from PyQt6.QtGui import QShortcut, QKeySequence
        
        # Ctrl+B para negrita
        bold_shortcut = QShortcut(QKeySequence("Ctrl+B"), self)
        bold_shortcut.activated.connect(self.toggle_bold)
        
        # Ctrl+I para cursiva
        italic_shortcut = QShortcut(QKeySequence("Ctrl+I"), self)
        italic_shortcut.activated.connect(self.toggle_italic)
        
        # Ctrl+U para subrayado
        underline_shortcut = QShortcut(QKeySequence("Ctrl+U"), self)
        underline_shortcut.activated.connect(self.toggle_underline)
        
        # Ctrl+Z para deshacer (ya est√° nativo pero lo reforzamos)
        # Ctrl+Y para rehacer (ya est√° nativo pero lo reforzamos)
        
    def create_sidebar(self):
        """Crear panel lateral con lista de notas"""
        sidebar = QWidget()
        sidebar.setFixedWidth(280)
        sidebar.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                border-right: 1px solid #333333;
            }
        """)
        
        layout = QVBoxLayout(sidebar)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Header del sidebar
        header = QWidget()
        header.setStyleSheet("background-color: #252525; padding: 15px;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(15, 15, 15, 15)
        
        title = QLabel("üìù Mis Notas")
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold;")
        header_layout.addWidget(title)
        
        # Barra de b√∫squeda
        search_container = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("üîç Buscar notas...")
        self.search_input.setStyleSheet("""
            QLineEdit {
                background-color: #2a2a2a;
                border: 1px solid #3a3a3a;
                border-radius: 6px;
                padding: 8px 12px;
                color: #ffffff;
                font-size: 10pt;
            }
            QLineEdit:focus {
                border: 1px solid #4a90e2;
            }
        """)
        self.search_input.textChanged.connect(self.filter_notes)
        search_container.addWidget(self.search_input)
        header_layout.addLayout(search_container)
        
        # Bot√≥n nueva nota
        new_note_btn = QPushButton("‚ûï Nueva Nota")
        new_note_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 6px;
                padding: 10px;
                color: #ffffff;
                font-weight: bold;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
            QPushButton:pressed {
                background-color: #3a80d2;
            }
        """)
        new_note_btn.clicked.connect(self.create_new_note)
        header_layout.addWidget(new_note_btn)
        
        # Botones de acci√≥n r√°pida
        actions_layout = QHBoxLayout()
        actions_layout.setSpacing(5)
        
        template_btn = QPushButton("üìã")
        template_btn.setToolTip("Plantillas")
        template_btn.setFixedSize(35, 35)
        template_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        template_btn.clicked.connect(self.show_note_templates)
        actions_layout.addWidget(template_btn)
        
        export_btn = QPushButton("üíæ")
        export_btn.setToolTip("Exportar notas")
        export_btn.setFixedSize(35, 35)
        export_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        export_btn.clicked.connect(self.export_notes)
        actions_layout.addWidget(export_btn)
        
        import_btn = QPushButton("üìÇ")
        import_btn.setToolTip("Importar notas")
        import_btn.setFixedSize(35, 35)
        import_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        import_btn.clicked.connect(self.import_notes)
        actions_layout.addWidget(import_btn)
        
        archive_btn = QPushButton("üì¶")
        archive_btn.setToolTip("Notas archivadas")
        archive_btn.setFixedSize(35, 35)
        archive_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        archive_btn.clicked.connect(self.show_archived_notes)
        actions_layout.addWidget(archive_btn)
        
        header_layout.addLayout(actions_layout)
        
        layout.addWidget(header)
        
        # Filtro por categor√≠a
        filter_container = QWidget()
        filter_container.setStyleSheet("background-color: #1e1e1e; padding: 10px;")
        filter_layout = QHBoxLayout(filter_container)
        filter_layout.setContentsMargins(10, 10, 10, 10)
        
        filter_label = QLabel("Categor√≠a:")
        filter_label.setStyleSheet("color: #aaaaaa; font-size: 9pt;")
        filter_layout.addWidget(filter_label)
        
        self.category_filter = QComboBox()
        self.category_filter.addItem("Todas")
        for cat in self.categories:
            self.category_filter.addItem(cat)
        self.category_filter.setStyleSheet("""
            QComboBox {
                background-color: #2a2a2a;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 5px 10px;
                color: #ffffff;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: #2a2a2a;
                color: #ffffff;
                selection-background-color: #4a90e2;
            }
        """)
        self.category_filter.currentTextChanged.connect(self.filter_notes)
        filter_layout.addWidget(self.category_filter, 1)
        
        layout.addWidget(filter_container)
        
        # Lista de notas
        self.notes_list = QListWidget()
        self.notes_list.setStyleSheet("""
            QListWidget {
                background-color: #1e1e1e;
                border: none;
                outline: none;
                padding: 5px;
            }
            QListWidget::item {
                background-color: #252525;
                border: 1px solid #2a2a2a;
                border-radius: 6px;
                padding: 12px;
                margin: 5px;
                color: #ffffff;
            }
            QListWidget::item:hover {
                background-color: #ffffff;
                border: 1px solid #4a90e2;
            }
            QListWidget::item:selected {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        self.notes_list.itemClicked.connect(self.load_note)
        layout.addWidget(self.notes_list)
        
        return sidebar
        
    def create_editor_area(self):
        """Crear √°rea de edici√≥n de notas"""
        editor = QWidget()
        editor.setStyleSheet("""
            QWidget {
                background-color: #1a1a1a;
            }
        """)
        
        layout = QVBoxLayout(editor)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Barra de herramientas del editor
        toolbar = QWidget()
        toolbar.setStyleSheet("background-color: #252525; border-bottom: 1px solid #333333;")
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(15, 10, 15, 10)
        
        # T√≠tulo de la nota
        self.note_title = QLineEdit()
        self.note_title.setPlaceholderText("T√≠tulo de la nota...")
        self.note_title.setStyleSheet("""
            QLineEdit {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 16pt;
                font-weight: bold;
                padding: 5px;
            }
        """)
        self.note_title.textChanged.connect(self.on_note_modified)
        toolbar_layout.addWidget(self.note_title, 1)
        
        # Selector de categor√≠a
        self.note_category = QComboBox()
        for cat in self.categories:
            self.note_category.addItem(cat)
        self.note_category.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 6px 12px;
                color: #ffffff;
                font-size: 9pt;
                min-width: 120px;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
            }
        """)
        self.note_category.currentTextChanged.connect(self.on_note_modified)
        toolbar_layout.addWidget(self.note_category)
        
        # Selector de prioridad
        self.note_priority = QComboBox()
        for priority in self.priorities:
            self.note_priority.addItem(priority)
        self.note_priority.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 6px 12px;
                color: #ffffff;
                font-size: 9pt;
                min-width: 100px;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
            }
        """)
        self.note_priority.currentTextChanged.connect(self.on_note_modified)
        toolbar_layout.addWidget(self.note_priority)
        
        # Bot√≥n fijar nota
        self.pin_btn = QPushButton("üìå")
        self.pin_btn.setToolTip("Fijar/Desfijar nota")
        self.pin_btn.setCheckable(True)
        self.pin_btn.setFixedSize(35, 35)
        self.pin_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 6px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
            QPushButton:checked {
                background-color: #ffd700;
                border: 1px solid #ffd700;
            }
        """)
        self.pin_btn.clicked.connect(self.toggle_pin_note)
        toolbar_layout.addWidget(self.pin_btn)
        
        # Bot√≥n archivar
        self.archive_btn = QPushButton("üì¶")
        self.archive_btn.setToolTip("Archivar nota")
        self.archive_btn.setFixedSize(35, 35)
        self.archive_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 6px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        self.archive_btn.clicked.connect(self.archive_current_note)
        toolbar_layout.addWidget(self.archive_btn)
        
        # Bot√≥n etiquetas
        self.tags_btn = QPushButton("üè∑Ô∏è")
        self.tags_btn.setToolTip("Gestionar etiquetas")
        self.tags_btn.setFixedSize(35, 35)
        self.tags_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 6px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        self.tags_btn.clicked.connect(self.manage_tags)
        toolbar_layout.addWidget(self.tags_btn)
        
        # Bot√≥n eliminar
        delete_btn = QPushButton("üóëÔ∏è")
        delete_btn.setToolTip("Eliminar nota")
        delete_btn.setFixedSize(35, 35)
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                border: none;
                border-radius: 6px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #ff5555;
            }
        """)
        delete_btn.clicked.connect(self.delete_current_note)
        toolbar_layout.addWidget(delete_btn)
        
        layout.addWidget(toolbar)
        
        # √Årea de texto de la nota con formato enriquecido (crear primero)
        self.note_content = QTextEdit()
        self.note_content.setAcceptRichText(True)  # Habilitar formato enriquecido
        self.note_content.setPlaceholderText("Escribe tu nota aqu√≠...\n\nPuedes usar formato enriquecido y el texto se guardar√° autom√°ticamente.")
        self.note_content.setStyleSheet("""
            QTextEdit {
                background-color: #1a1a1a;
                border: none;
                color: #e0e0e0;
                font-size: 11pt;
                padding: 25px;
                line-height: 1.6;
            }
        """)
        self.note_content.textChanged.connect(self.on_note_modified)
        
        # Barra de herramientas de formato (estilo Word) - crear despu√©s de note_content
        format_toolbar = self.create_format_toolbar()
        # Insertar la barra de formato antes del √°rea de texto
        layout.insertWidget(layout.count() - 1, format_toolbar)
        
        # Agregar el √°rea de texto
        layout.addWidget(self.note_content)
        
        # Barra de estado
        status_bar = QWidget()
        status_bar.setStyleSheet("background-color: #252525; border-top: 1px solid #333333;")
        status_layout = QHBoxLayout(status_bar)
        status_layout.setContentsMargins(15, 8, 15, 8)
        
        self.status_label = QLabel("Selecciona o crea una nota")
        self.status_label.setStyleSheet("color: #888888; font-size: 9pt;")
        status_layout.addWidget(self.status_label)
        
        status_layout.addStretch()
        
        self.char_count_label = QLabel("0 caracteres")
        self.char_count_label.setStyleSheet("color: #888888; font-size: 9pt;")
        status_layout.addWidget(self.char_count_label)
        
        layout.addWidget(status_bar)
        
        return editor
        
    def create_format_toolbar(self):
        """Crear barra de herramientas de formato tipo Word"""
        toolbar = QWidget()
        toolbar.setStyleSheet("""
            QWidget {
                background-color: #252525;
                border-bottom: 1px solid #333333;
            }
        """)
        
        main_layout = QVBoxLayout(toolbar)
        main_layout.setContentsMargins(10, 5, 10, 5)
        main_layout.setSpacing(5)
        
        # Primera fila: Fuente, tama√±o, y formato b√°sico
        row1 = QHBoxLayout()
        row1.setSpacing(5)
        
        # Selector de fuente
        self.font_family_combo = QComboBox()
        self.font_family_combo.addItems([
            "Arial", "Times New Roman", "Courier New", "Verdana", 
            "Georgia", "Comic Sans MS", "Trebuchet MS", "Segoe UI",
            "Calibri", "Consolas", "Tahoma"
        ])
        self.font_family_combo.setCurrentText("Segoe UI")
        self.font_family_combo.setStyleSheet(self.get_toolbar_combo_style())
        self.font_family_combo.setFixedWidth(140)
        self.font_family_combo.currentTextChanged.connect(self.change_font_family)
        row1.addWidget(self.font_family_combo)
        
        # Selector de tama√±o de fuente
        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems([
            "8", "9", "10", "11", "12", "14", "16", "18", "20", 
            "22", "24", "26", "28", "36", "48", "72"
        ])
        self.font_size_combo.setCurrentText("11")
        self.font_size_combo.setStyleSheet(self.get_toolbar_combo_style())
        self.font_size_combo.setFixedWidth(60)
        self.font_size_combo.currentTextChanged.connect(self.change_font_size)
        row1.addWidget(self.font_size_combo)
        
        # Separador
        row1.addWidget(self.create_separator())
        
        # Botones de formato b√°sico
        self.bold_btn = self.create_format_button("B", "Negrita (Ctrl+B)", bold=True)
        self.bold_btn.clicked.connect(self.toggle_bold)
        row1.addWidget(self.bold_btn)
        
        self.italic_btn = self.create_format_button("I", "Cursiva (Ctrl+I)", italic=True)
        self.italic_btn.clicked.connect(self.toggle_italic)
        row1.addWidget(self.italic_btn)
        
        self.underline_btn = self.create_format_button("U", "Subrayado (Ctrl+U)", underline=True)
        self.underline_btn.clicked.connect(self.toggle_underline)
        row1.addWidget(self.underline_btn)
        
        self.strikethrough_btn = self.create_format_button("S", "Tachado", strikethrough=True)
        self.strikethrough_btn.clicked.connect(self.toggle_strikethrough)
        row1.addWidget(self.strikethrough_btn)
        
        # Separador
        row1.addWidget(self.create_separator())
        
        # Bot√≥n de color de texto
        self.text_color_btn = self.create_format_button("A", "Color de texto")
        self.text_color_btn.setStyleSheet(self.get_color_button_style("#4a90e2"))
        self.text_color_btn.clicked.connect(self.choose_text_color)
        row1.addWidget(self.text_color_btn)
        
        # Bot√≥n de color de fondo
        self.bg_color_btn = self.create_format_button("üé®", "Color de fondo")
        self.bg_color_btn.clicked.connect(self.choose_bg_color)
        row1.addWidget(self.bg_color_btn)
        
        row1.addStretch()
        main_layout.addLayout(row1)
        
        # Segunda fila: Alineaci√≥n, listas y otros
        row2 = QHBoxLayout()
        row2.setSpacing(5)
        
        # Botones de alineaci√≥n
        self.align_left_btn = self.create_format_button("‚â°", "Alinear a la izquierda")
        self.align_left_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignLeft))
        row2.addWidget(self.align_left_btn)
        
        self.align_center_btn = self.create_format_button("‚â£", "Centrar")
        self.align_center_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignCenter))
        row2.addWidget(self.align_center_btn)
        
        self.align_right_btn = self.create_format_button("‚â°", "Alinear a la derecha")
        self.align_right_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignRight))
        row2.addWidget(self.align_right_btn)
        
        self.align_justify_btn = self.create_format_button("‚äû", "Justificar")
        self.align_justify_btn.clicked.connect(lambda: self.set_alignment(Qt.AlignmentFlag.AlignJustify))
        row2.addWidget(self.align_justify_btn)
        
        # Separador
        row2.addWidget(self.create_separator())
        
        # Botones de lista
        self.bullet_list_btn = self.create_format_button("‚Ä¢", "Lista con vi√±etas")
        self.bullet_list_btn.clicked.connect(self.toggle_bullet_list)
        row2.addWidget(self.bullet_list_btn)
        
        self.number_list_btn = self.create_format_button("1.", "Lista numerada")
        self.number_list_btn.clicked.connect(self.toggle_number_list)
        row2.addWidget(self.number_list_btn)
        
        # Separador
        row2.addWidget(self.create_separator())
        
        # Botones de deshacer/rehacer
        self.undo_btn = self.create_format_button("‚Ü∂", "Deshacer (Ctrl+Z)")
        self.undo_btn.clicked.connect(self.note_content.undo)
        row2.addWidget(self.undo_btn)
        
        self.redo_btn = self.create_format_button("‚Ü∑", "Rehacer (Ctrl+Y)")
        self.redo_btn.clicked.connect(self.note_content.redo)
        row2.addWidget(self.redo_btn)
        
        # Separador
        row2.addWidget(self.create_separator())
        
        # Bot√≥n limpiar formato
        self.clear_format_btn = self.create_format_button("‚úï", "Limpiar formato")
        self.clear_format_btn.clicked.connect(self.clear_formatting)
        row2.addWidget(self.clear_format_btn)
        
        # Separador
        row2.addWidget(self.create_separator())
        
        # Bot√≥n de ayuda
        self.help_btn = self.create_format_button("?", "Ayuda de formato")
        self.help_btn.clicked.connect(self.show_format_help)
        row2.addWidget(self.help_btn)
        
        row2.addStretch()
        main_layout.addLayout(row2)
        
        return toolbar
        
    def create_format_button(self, text, tooltip, bold=False, italic=False, underline=False, strikethrough=False):
        """Crear bot√≥n de formato"""
        btn = QPushButton(text)
        btn.setToolTip(tooltip)
        btn.setFixedSize(32, 32)
        
        font_style = ""
        if bold:
            font_style += "font-weight: bold;"
        if italic:
            font_style += "font-style: italic;"
        if underline:
            font_style += "text-decoration: underline;"
        
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 11pt;
                {font_style}
            }}
            QPushButton:hover {{
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }}
            QPushButton:pressed {{
                background-color: #217346;
            }}
        """)
        
        return btn
        
    def create_separator(self):
        """Crear separador vertical"""
        separator = QLabel("|")
        separator.setStyleSheet("color: #3a3a3a; padding: 0 5px;")
        return separator
        
    def get_toolbar_combo_style(self):
        """Estilo para combos de la barra de herramientas"""
        return """
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 5px 8px;
                color: #ffffff;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 6px solid #ffffff;
                margin-right: 5px;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
                border: 1px solid #c0c0c0;
            }
        """
        
    def get_color_button_style(self, color):
        """Estilo para botones de color"""
        return f"""
            QPushButton {{
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: {color};
                font-size: 11pt;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }}
        """
        
    # Funciones de formato
    def change_font_family(self, font_family):
        """Cambiar familia de fuente"""
        if self.note_content.hasFocus():
            self.note_content.setFontFamily(font_family)
            self.note_content.setFocus()
            
    def change_font_size(self, size):
        """Cambiar tama√±o de fuente"""
        if size:
            self.note_content.setFontPointSize(int(size))
            self.note_content.setFocus()
            
    def toggle_bold(self):
        """Alternar negrita"""
        fmt = self.note_content.currentCharFormat()
        if fmt.fontWeight() == 700:  # QFont.Weight.Bold
            self.note_content.setFontWeight(400)  # QFont.Weight.Normal
        else:
            self.note_content.setFontWeight(700)
        self.note_content.setFocus()
        
    def toggle_italic(self):
        """Alternar cursiva"""
        state = self.note_content.fontItalic()
        self.note_content.setFontItalic(not state)
        self.note_content.setFocus()
        
    def toggle_underline(self):
        """Alternar subrayado"""
        state = self.note_content.fontUnderline()
        self.note_content.setFontUnderline(not state)
        self.note_content.setFocus()
        
    def toggle_strikethrough(self):
        """Alternar tachado"""
        fmt = self.note_content.currentCharFormat()
        fmt.setFontStrikeOut(not fmt.fontStrikeOut())
        self.note_content.setCurrentCharFormat(fmt)
        self.note_content.setFocus()
        
    def choose_text_color(self):
        """Elegir color de texto"""
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor
        
        color = QColorDialog.getColor(QColor("#ffffff"), self, "Elegir color de texto")
        if color.isValid():
            self.note_content.setTextColor(color)
            self.text_color_btn.setStyleSheet(self.get_color_button_style(color.name()))
            self.note_content.setFocus()
            
    def choose_bg_color(self):
        """Elegir color de fondo"""
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor
        
        color = QColorDialog.getColor(QColor("#ffff00"), self, "Elegir color de fondo")
        if color.isValid():
            self.note_content.setTextBackgroundColor(color)
            self.note_content.setFocus()
            
    def set_alignment(self, alignment):
        """Establecer alineaci√≥n de texto"""
        self.note_content.setAlignment(alignment)
        self.note_content.setFocus()
        
    def toggle_bullet_list(self):
        """Alternar lista con vi√±etas"""
        from PyQt6.QtGui import QTextListFormat, QTextCursor
        
        cursor = self.note_content.textCursor()
        current_list = cursor.currentList()
        
        if current_list:
            # Si ya hay una lista, quitarla
            for i in range(current_list.count()):
                current_list.removeItem(0)
        else:
            # Crear lista con vi√±etas
            list_format = QTextListFormat()
            list_format.setStyle(QTextListFormat.Style.ListDisc)
            cursor.createList(list_format)
            
        self.note_content.setFocus()
        
    def toggle_number_list(self):
        """Alternar lista numerada"""
        from PyQt6.QtGui import QTextListFormat, QTextCursor
        
        cursor = self.note_content.textCursor()
        current_list = cursor.currentList()
        
        if current_list:
            # Si ya hay una lista, quitarla
            for i in range(current_list.count()):
                current_list.removeItem(0)
        else:
            # Crear lista numerada
            list_format = QTextListFormat()
            list_format.setStyle(QTextListFormat.Style.ListDecimal)
            cursor.createList(list_format)
            
        self.note_content.setFocus()
        
    def clear_formatting(self):
        """Limpiar todo el formato"""
        from PyQt6.QtGui import QTextCharFormat
        
        # Obtener el texto sin formato
        cursor = self.note_content.textCursor()
        if cursor.hasSelection():
            # Limpiar solo la selecci√≥n
            fmt = QTextCharFormat()
            cursor.setCharFormat(fmt)
        else:
            # Limpiar todo el documento
            self.note_content.selectAll()
            cursor = self.note_content.textCursor()
            fmt = QTextCharFormat()
            cursor.setCharFormat(fmt)
            # Deseleccionar
            cursor.clearSelection()
            self.note_content.setTextCursor(cursor)
            
        self.note_content.setFocus()
        
    def show_format_help(self):
        """Mostrar di√°logo de ayuda de formato"""
        from PyQt6.QtWidgets import QMessageBox
        
        help_text = """
<h2 style='color: #4a90e2;'>üìù Editor de Formato Enriquecido</h2>

<h3>‚å®Ô∏è Atajos de Teclado:</h3>
<ul>
    <li><b>Ctrl+B</b> - Negrita</li>
    <li><b>Ctrl+I</b> - Cursiva</li>
    <li><b>Ctrl+U</b> - Subrayado</li>
    <li><b>Ctrl+Z</b> - Deshacer</li>
    <li><b>Ctrl+Y</b> - Rehacer</li>
</ul>

<h3>üé® Formato de Texto:</h3>
<ul>
    <li><b>Fuente</b> - Cambia la familia tipogr√°fica</li>
    <li><b>Tama√±o</b> - Ajusta el tama√±o del texto (8-72pt)</li>
    <li><b>Negrita, Cursiva, Subrayado, Tachado</b> - Estilos de texto</li>
    <li><b>Color de texto</b> - Selector de color para el texto</li>
    <li><b>Color de fondo</b> - Resaltador de texto</li>
</ul>

<h3>üìê Alineaci√≥n:</h3>
<ul>
    <li>Izquierda, Centro, Derecha, Justificado</li>
</ul>

<h3>üìã Listas:</h3>
<ul>
    <li>Listas con vi√±etas</li>
    <li>Listas numeradas</li>
</ul>

<h3>üíæ Guardado:</h3>
<p>Todas las notas se guardan autom√°ticamente con su formato.</p>

<p style='color: #888888; font-size: 9pt; margin-top: 20px;'>
Tip: Puedes usar Ctrl+A para seleccionar todo el texto y aplicar formato a todo el documento.
</p>
        """
        
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Ayuda - Editor de Formato")
        msg_box.setTextFormat(Qt.TextFormat.RichText)
        msg_box.setText(help_text)
        msg_box.setStyleSheet("""
            QMessageBox {
                background-color: #1e1e1e;
            }
            QMessageBox QLabel {
                color: #e0e0e0;
                min-width: 500px;
            }
            QMessageBox QPushButton {
                background-color: #4a90e2;
                color: white;
                border: none;
                padding: 8px 20px;
                border-radius: 4px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #5a9ef2;
            }
        """)
        msg_box.exec()
        
    def create_tasks_panel(self):
        """Crear panel de tareas"""
        panel = QWidget()
        panel.setFixedWidth(320)
        panel.setStyleSheet("""
            QWidget {
                background-color: #1e1e1e;
                border-left: 1px solid #333333;
            }
        """)
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Header del panel de tareas
        header = QWidget()
        header.setStyleSheet("background-color: #252525; padding: 15px;")
        header_layout = QVBoxLayout(header)
        header_layout.setContentsMargins(15, 15, 15, 15)
        
        title = QLabel("‚úÖ Tareas")
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold;")
        header_layout.addWidget(title)
        
        # Input para nueva tarea
        task_input_container = QHBoxLayout()
        self.task_input = QLineEdit()
        self.task_input.setPlaceholderText("‚ûï Nueva tarea...")
        self.task_input.setStyleSheet("""
            QLineEdit {
                background-color: #2a2a2a;
                border: 1px solid #3a3a3a;
                border-radius: 6px;
                padding: 10px 12px;
                color: #ffffff;
                font-size: 10pt;
            }
            QLineEdit:focus {
                border: 1px solid #4a90e2;
            }
        """)
        self.task_input.returnPressed.connect(self.add_task)
        task_input_container.addWidget(self.task_input)
        
        add_task_btn = QPushButton("‚ûï")
        add_task_btn.setFixedSize(40, 40)
        add_task_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 6px;
                color: #ffffff;
                font-size: 14pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        add_task_btn.clicked.connect(self.add_task)
        task_input_container.addWidget(add_task_btn)
        
        header_layout.addLayout(task_input_container)
        
        # Botones de gesti√≥n de tareas
        task_actions = QHBoxLayout()
        task_actions.setSpacing(5)
        
        sort_tasks_btn = QPushButton("‚áÖ")
        sort_tasks_btn.setToolTip("Ordenar tareas")
        sort_tasks_btn.setFixedSize(32, 32)
        sort_tasks_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 12pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        sort_tasks_btn.clicked.connect(self.show_sort_tasks_menu)
        task_actions.addWidget(sort_tasks_btn)
        
        clear_completed_btn = QPushButton("‚úì‚úï")
        clear_completed_btn.setToolTip("Limpiar tareas completadas")
        clear_completed_btn.setFixedSize(32, 32)
        clear_completed_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        clear_completed_btn.clicked.connect(self.clear_completed_tasks)
        task_actions.addWidget(clear_completed_btn)
        
        export_tasks_btn = QPushButton("üíæ")
        export_tasks_btn.setToolTip("Exportar tareas")
        export_tasks_btn.setFixedSize(32, 32)
        export_tasks_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                color: #ffffff;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        export_tasks_btn.clicked.connect(self.export_tasks)
        task_actions.addWidget(export_tasks_btn)
        
        task_actions.addStretch()
        header_layout.addLayout(task_actions)
        
        layout.addWidget(header)
        
        # Filtros de tareas
        filter_container = QWidget()
        filter_container.setStyleSheet("background-color: #1e1e1e; padding: 10px;")
        filter_layout = QHBoxLayout(filter_container)
        filter_layout.setContentsMargins(10, 5, 10, 5)
        
        self.show_all_tasks_btn = QPushButton("Todas")
        self.show_pending_tasks_btn = QPushButton("Pendientes")
        self.show_completed_tasks_btn = QPushButton("Completadas")
        
        for btn in [self.show_all_tasks_btn, self.show_pending_tasks_btn, self.show_completed_tasks_btn]:
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: #2a2a2a;
                    border: 1px solid #3a3a3a;
                    border-radius: 4px;
                    padding: 6px 10px;
                    color: #aaaaaa;
                    font-size: 8pt;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                    color: #ffffff;
                }
                QPushButton:checked {
                    background-color: #4a90e2;
                    border: 1px solid #4a90e2;
                    color: #ffffff;
                }
            """)
        
        self.show_all_tasks_btn.setChecked(True)
        self.show_all_tasks_btn.clicked.connect(lambda: self.set_task_filter("all"))
        self.show_pending_tasks_btn.clicked.connect(lambda: self.set_task_filter("pending"))
        self.show_completed_tasks_btn.clicked.connect(lambda: self.set_task_filter("completed"))
        
        filter_layout.addWidget(self.show_all_tasks_btn)
        filter_layout.addWidget(self.show_pending_tasks_btn)
        filter_layout.addWidget(self.show_completed_tasks_btn)
        
        layout.addWidget(filter_container)
        
        # Lista de tareas
        self.tasks_list = QListWidget()
        self.tasks_list.setStyleSheet("""
            QListWidget {
                background-color: #1e1e1e;
                border: none;
                outline: none;
                padding: 5px;
            }
            QListWidget::item {
                background-color: #252525;
                border: 1px solid #2a2a2a;
                border-radius: 6px;
                padding: 0px;
                margin: 5px;
            }
            QListWidget::item:hover {
                background-color: #ffffff;
                border: 1px solid #4a90e2;
            }
        """)
        layout.addWidget(self.tasks_list)
        
        # Estad√≠sticas de tareas
        stats_container = QWidget()
        stats_container.setStyleSheet("background-color: #252525; border-top: 1px solid #333333; padding: 10px;")
        stats_layout = QVBoxLayout(stats_container)
        stats_layout.setContentsMargins(15, 10, 15, 10)
        
        self.tasks_stats_label = QLabel("üìä 0 tareas")
        self.tasks_stats_label.setStyleSheet("color: #888888; font-size: 9pt;")
        stats_layout.addWidget(self.tasks_stats_label)
        
        layout.addWidget(stats_container)
        
        self.task_filter = "all"
        
        return panel
        
    def create_new_note(self):
        """Crear una nueva nota mejorada"""
        import datetime
        
        note = {
            "id": datetime.datetime.now().strftime("%Y%m%d%H%M%S%f"),
            "title": "Nueva Nota",
            "content": "",
            "category": self.categories[0],
            "created": datetime.datetime.now().isoformat(),
            "modified": datetime.datetime.now().isoformat(),
            "priority": "üü° Media",  # Nueva: prioridad
            "tags": [],  # Nueva: etiquetas
            "pinned": False,  # Nueva: fijada
            "archived": False,  # Nueva: archivada
            "color": "#4a90e2",  # Nueva: color personalizado
            "reminder": None,  # Nueva: recordatorio
            "attachments": [],  # Nueva: archivos adjuntos
            "checklist": []  # Nueva: checklist interna
        }
        
        self.notes.append(note)
        self.refresh_notes_list()
        
        # Seleccionar la nueva nota
        self.current_note_index = len(self.notes) - 1
        self.notes_list.setCurrentRow(self.current_note_index)
        self.load_note_at_index(self.current_note_index)
        self.note_title.setFocus()
        self.note_title.selectAll()
        
        self.data_changed.emit()
        
    def load_note(self, item):
        """Cargar nota seleccionada"""
        index = self.notes_list.row(item)
        self.load_note_at_index(index)
        
    def load_note_at_index(self, index):
        """Cargar nota por √≠ndice"""
        if 0 <= index < len(self.notes):
            self.current_note_index = index
            note = self.notes[index]
            
            # Bloquear se√±ales temporalmente
            self.note_title.blockSignals(True)
            self.note_content.blockSignals(True)
            self.note_category.blockSignals(True)
            self.note_priority.blockSignals(True)
            
            self.note_title.setText(note.get("title", ""))
            
            # Cargar contenido con formato HTML
            content = note.get("content", "")
            if content.strip().startswith("<"):
                # Es HTML
                self.note_content.setHtml(content)
            else:
                # Es texto plano (compatibilidad con notas antiguas)
                self.note_content.setPlainText(content)
            
            category = note.get("category", self.categories[0])
            if category in self.categories:
                self.note_category.setCurrentText(category)
            
            # Cargar prioridad
            priority = note.get("priority", "üü° Media")
            if priority in self.priorities:
                self.note_priority.setCurrentText(priority)
            
            # Actualizar estado del bot√≥n de fijar
            self.pin_btn.setChecked(note.get("pinned", False))
            
            # Restaurar se√±ales
            self.note_title.blockSignals(False)
            self.note_content.blockSignals(False)
            self.note_category.blockSignals(False)
            self.note_priority.blockSignals(False)
            
            self.update_status()
            
    def on_note_modified(self):
        """Manejar modificaci√≥n de nota"""
        if self.current_note_index is not None and 0 <= self.current_note_index < len(self.notes):
            import datetime
            
            note = self.notes[self.current_note_index]
            note["title"] = self.note_title.text() or "Sin t√≠tulo"
            # Guardar contenido con formato HTML
            note["content"] = self.note_content.toHtml()
            note["category"] = self.note_category.currentText()
            note["priority"] = self.note_priority.currentText()
            note["modified"] = datetime.datetime.now().isoformat()
            
            self.refresh_notes_list()
            self.update_status()
            self.data_changed.emit()
            
    def delete_current_note(self):
        """Eliminar nota actual"""
        if self.current_note_index is not None and 0 <= self.current_note_index < len(self.notes):
            from PyQt6.QtWidgets import QMessageBox
            
            reply = QMessageBox.question(
                self,
                "Confirmar eliminaci√≥n",
                "¬øEst√°s seguro de que quieres eliminar esta nota?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                del self.notes[self.current_note_index]
                self.current_note_index = None
                
                self.note_title.clear()
                self.note_content.clear()
                
                self.refresh_notes_list()
                self.update_status()
                self.data_changed.emit()
                
    def filter_notes(self):
        """Filtrar notas por b√∫squeda y categor√≠a"""
        search_text = self.search_input.text().lower()
        category = self.category_filter.currentText()
        
        for i in range(self.notes_list.count()):
            item = self.notes_list.item(i)
            note = self.notes[i]
            
            # Filtrar por texto
            title_match = search_text in note.get("title", "").lower()
            content_match = search_text in note.get("content", "").lower()
            text_match = title_match or content_match
            
            # Filtrar por categor√≠a
            category_match = (category == "Todas" or note.get("category") == category)
            
            item.setHidden(not (text_match and category_match))
            
    def refresh_notes_list(self):
        """Refrescar lista de notas con mejoras visuales"""
        current_row = self.notes_list.currentRow()
        
        self.notes_list.clear()
        
        # Ordenar: notas fijadas primero
        sorted_notes = sorted(self.notes, key=lambda n: (not n.get("pinned", False), n.get("modified", "")), reverse=True)
        
        for note in sorted_notes:
            title = note.get("title", "Sin t√≠tulo")
            category = note.get("category", "")
            priority = note.get("priority", "üü° Media")
            pinned = note.get("pinned", False)
            tags = note.get("tags", [])
            
            # Truncar t√≠tulo si es muy largo
            if len(title) > 30:
                title = title[:27] + "..."
            
            # Agregar indicadores visuales
            prefix = ""
            if pinned:
                prefix = "üìå "
            
            # Emoji de prioridad
            priority_emoji = priority.split()[0] if priority else ""
            
            # Construir texto del item
            item_text = f"{prefix}{priority_emoji} {title}\nüìÅ {category}"
            
            # Agregar tags si existen
            if tags:
                tags_text = " ".join([f"üè∑Ô∏è{t}" for t in tags[:2]])  # M√°ximo 2 tags
                item_text += f"\n{tags_text}"
            
            item = QListWidgetItem(item_text)
            
            # Color de fondo seg√∫n prioridad
            from PyQt6.QtGui import QColor, QBrush
            if pinned:
                item.setBackground(QBrush(QColor("#3a3a2a")))  # Amarillo oscuro para fijadas
            elif "üî¥" in priority:
                item.setBackground(QBrush(QColor("#3a2a2a")))  # Rojo oscuro
            
            self.notes_list.addItem(item)
        
        # Restaurar selecci√≥n
        if current_row >= 0 and current_row < self.notes_list.count():
            self.notes_list.setCurrentRow(current_row)
            
        self.filter_notes()
        
    def update_status(self):
        """Actualizar barra de estado"""
        if self.current_note_index is not None:
            import datetime
            
            note = self.notes[self.current_note_index]
            modified = note.get("modified", "")
            
            try:
                mod_dt = datetime.datetime.fromisoformat(modified)
                mod_str = mod_dt.strftime("%d/%m/%Y %H:%M")
                self.status_label.setText(f"√öltima modificaci√≥n: {mod_str}")
            except:
                self.status_label.setText("Editando nota")
                
            # Contar caracteres
            char_count = len(self.note_content.toPlainText())
            word_count = len(self.note_content.toPlainText().split())
            self.char_count_label.setText(f"{char_count} caracteres ‚Ä¢ {word_count} palabras")
        else:
            self.status_label.setText("Selecciona o crea una nota")
            self.char_count_label.setText("0 caracteres")
            
    def add_task(self):
        """Agregar nueva tarea mejorada"""
        import datetime
        
        task_text = self.task_input.text().strip()
        if task_text:
            task = {
                "id": datetime.datetime.now().strftime("%Y%m%d%H%M%S%f"),
                "text": task_text,
                "completed": False,
                "created": datetime.datetime.now().isoformat(),
                "priority": "üü° Media",  # Nueva: prioridad
                "due_date": None,  # Nueva: fecha de vencimiento
                "category": "General",  # Nueva: categor√≠a
                "subtasks": [],  # Nueva: subtareas
                "notes": "",  # Nueva: notas adicionales
                "progress": 0  # Nueva: progreso (0-100%)
            }
            
            self.tasks.append(task)
            self.task_input.clear()
            self.refresh_tasks_list()
            self.data_changed.emit()
            
    def toggle_task(self, task_id):
        """Alternar estado de completado de tarea"""
        for task in self.tasks:
            if task["id"] == task_id:
                task["completed"] = not task["completed"]
                break
        
        self.refresh_tasks_list()
        self.data_changed.emit()
        
    def delete_task(self, task_id):
        """Eliminar tarea"""
        self.tasks = [t for t in self.tasks if t["id"] != task_id]
        self.refresh_tasks_list()
        self.data_changed.emit()
        
    def set_task_filter(self, filter_type):
        """Establecer filtro de tareas"""
        self.task_filter = filter_type
        
        # Actualizar estado de botones
        self.show_all_tasks_btn.setChecked(filter_type == "all")
        self.show_pending_tasks_btn.setChecked(filter_type == "pending")
        self.show_completed_tasks_btn.setChecked(filter_type == "completed")
        
        self.refresh_tasks_list()
        
    def refresh_tasks_list(self):
        """Refrescar lista de tareas"""
        self.tasks_list.clear()
        
        # Filtrar tareas seg√∫n filtro activo
        filtered_tasks = []
        for task in self.tasks:
            if self.task_filter == "all":
                filtered_tasks.append(task)
            elif self.task_filter == "pending" and not task["completed"]:
                filtered_tasks.append(task)
            elif self.task_filter == "completed" and task["completed"]:
                filtered_tasks.append(task)
        
        for task in filtered_tasks:
            # Crear widget personalizado para cada tarea
            item = QListWidgetItem()
            item.setSizeHint(QSize(0, 50))
            
            task_widget = QWidget()
            task_widget.setStyleSheet("background-color: transparent;")
            task_layout = QHBoxLayout(task_widget)
            task_layout.setContentsMargins(10, 5, 10, 5)
            
            # Checkbox
            checkbox = QCheckBox()
            checkbox.setChecked(task["completed"])
            checkbox.setStyleSheet("""
                QCheckBox {
                    spacing: 8px;
                }
                QCheckBox::indicator {
                    width: 20px;
                    height: 20px;
                    border-radius: 4px;
                    border: 2px solid #4a90e2;
                }
                QCheckBox::indicator:unchecked {
                    background-color: #ffffff;
                }
                QCheckBox::indicator:checked {
                    background-color: #217346;
                    image: url(none);
                }
            """)
            checkbox.stateChanged.connect(lambda state, tid=task["id"]: self.toggle_task(tid))
            task_layout.addWidget(checkbox)
            
            # Indicador de prioridad
            priority = task.get("priority", "üü° Media")
            priority_label = QLabel(priority.split()[0])  # Solo el emoji
            priority_label.setFixedSize(20, 20)
            priority_label.setStyleSheet("font-size: 14pt;")
            task_layout.addWidget(priority_label)
            
            # Texto de la tarea con m√°s informaci√≥n
            task_text = task["text"]
            task_label = QLabel(task_text)
            task_label.setWordWrap(True)
            if task["completed"]:
                task_label.setStyleSheet("""
                    color: #888888;
                    text-decoration: line-through;
                    font-size: 10pt;
                """)
            else:
                # Color seg√∫n prioridad
                if "üî¥" in priority:
                    color = "#ff6b6b"
                elif "üü°" in priority:
                    color = "#ffd93d"
                elif "üü¢" in priority:
                    color = "#6bcf7f"
                else:
                    color = "#ffffff"
                
                task_label.setStyleSheet(f"color: {color}; font-size: 10pt;")
            task_layout.addWidget(task_label, 1)
            
            # Bot√≥n editar tarea (nuevo)
            edit_btn = QPushButton("‚úèÔ∏è")
            edit_btn.setFixedSize(30, 30)
            edit_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: none;
                    color: #4a90e2;
                    font-size: 10pt;
                }
                QPushButton:hover {
                    background-color: rgba(74, 144, 226, 0.2);
                    border-radius: 4px;
                }
            """)
            edit_btn.clicked.connect(lambda checked, tid=task["id"]: self.edit_task(tid))
            task_layout.addWidget(edit_btn)
            
            # Bot√≥n eliminar
            delete_btn = QPushButton("üóëÔ∏è")
            delete_btn.setFixedSize(30, 30)
            delete_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: none;
                    color: #ff4444;
                    font-size: 10pt;
                }
                QPushButton:hover {
                    background-color: rgba(255, 68, 68, 0.2);
                    border-radius: 4px;
                }
            """)
            delete_btn.clicked.connect(lambda checked, tid=task["id"]: self.delete_task(tid))
            task_layout.addWidget(delete_btn)
            
            self.tasks_list.addItem(item)
            self.tasks_list.setItemWidget(item, task_widget)
        
        # Actualizar estad√≠sticas
        total_tasks = len(self.tasks)
        completed_tasks = sum(1 for t in self.tasks if t["completed"])
        pending_tasks = total_tasks - completed_tasks
        
        self.tasks_stats_label.setText(
            f"üìä {total_tasks} tareas ‚Ä¢ ‚úÖ {completed_tasks} completadas ‚Ä¢ ‚è≥ {pending_tasks} pendientes"
        )
        
    def get_data(self):
        """Obtener datos para guardar"""
        return {
            "notes": self.notes,
            "tasks": self.tasks,
            "archived_notes": self.archived_notes,
            "tags": self.tags
        }
        
    def set_data(self, data):
        """Cargar datos guardados"""
        self.notes = data.get("notes", [])
        self.tasks = data.get("tasks", [])
        self.archived_notes = data.get("archived_notes", [])
        self.tags = data.get("tags", [])
        self.refresh_notes_list()
        self.refresh_tasks_list()
    
    # ===== NUEVAS FUNCIONES AVANZADAS =====
    
    def toggle_pin_note(self):
        """Fijar/Desfijar nota actual"""
        if self.current_note_index is not None and 0 <= self.current_note_index < len(self.notes):
            note = self.notes[self.current_note_index]
            note["pinned"] = not note.get("pinned", False)
            self.pin_btn.setChecked(note["pinned"])
            self.refresh_notes_list()
            self.data_changed.emit()
            
            status = "fijada" if note["pinned"] else "desfijada"
            QMessageBox.information(self, "Nota " + status, f"La nota ha sido {status}")
    
    def archive_current_note(self):
        """Archivar nota actual"""
        if self.current_note_index is not None and 0 <= self.current_note_index < len(self.notes):
            from PyQt6.QtWidgets import QMessageBox
            
            reply = QMessageBox.question(
                self,
                "Archivar nota",
                "¬øArchivar esta nota?\n\nPodr√°s verla en 'Notas archivadas'",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                note = self.notes.pop(self.current_note_index)
                note["archived"] = True
                self.archived_notes.append(note)
                
                self.current_note_index = None
                self.note_title.clear()
                self.note_content.clear()
                
                self.refresh_notes_list()
                self.data_changed.emit()
                
                QMessageBox.information(self, "Nota archivada", "La nota ha sido archivada exitosamente")
    
    def show_archived_notes(self):
        """Mostrar notas archivadas"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QListWidget, QPushButton, QHBoxLayout, QMessageBox
        
        if not self.archived_notes:
            QMessageBox.information(self, "Sin notas archivadas", "No hay notas archivadas")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Notas Archivadas")
        dialog.setMinimumSize(600, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1e1e1e;
            }
            QLabel {
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                padding: 10px;
            }
            QListWidget {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 10px;
                border-radius: 4px;
                margin: 2px;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:selected {
                background-color: #217346;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        title = QLabel(f"üì¶ Notas Archivadas ({len(self.archived_notes)})")
        layout.addWidget(title)
        
        archived_list = QListWidget()
        for note in self.archived_notes:
            archived_list.addItem(f"{note.get('title', 'Sin t√≠tulo')} - {note.get('category', '')}")
        
        layout.addWidget(archived_list)
        
        # Botones
        buttons_layout = QHBoxLayout()
        
        restore_btn = QPushButton("‚Ü©Ô∏è Restaurar")
        restore_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        restore_btn.clicked.connect(lambda: self.restore_note(archived_list, dialog))
        buttons_layout.addWidget(restore_btn)
        
        delete_permanent_btn = QPushButton("üóëÔ∏è Eliminar permanentemente")
        delete_permanent_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #ff5555;
            }
        """)
        delete_permanent_btn.clicked.connect(lambda: self.delete_archived_note(archived_list, dialog))
        buttons_layout.addWidget(delete_permanent_btn)
        
        close_btn = QPushButton("Cerrar")
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                color: white;
                border: 1px solid #c0c0c0;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        close_btn.clicked.connect(dialog.close)
        buttons_layout.addWidget(close_btn)
        
        layout.addLayout(buttons_layout)
        
        dialog.exec()
    
    def restore_note(self, list_widget, dialog):
        """Restaurar nota archivada"""
        current_item = list_widget.currentItem()
        if current_item:
            index = list_widget.currentRow()
            if 0 <= index < len(self.archived_notes):
                note = self.archived_notes.pop(index)
                note["archived"] = False
                self.notes.append(note)
                
                self.refresh_notes_list()
                self.data_changed.emit()
                
                dialog.close()
                QMessageBox.information(self, "Nota restaurada", "La nota ha sido restaurada exitosamente")
    
    def delete_archived_note(self, list_widget, dialog):
        """Eliminar permanentemente nota archivada"""
        current_item = list_widget.currentItem()
        if current_item:
            from PyQt6.QtWidgets import QMessageBox
            
            reply = QMessageBox.warning(
                self,
                "Eliminar permanentemente",
                "¬øEst√°s seguro? Esta acci√≥n NO se puede deshacer.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                index = list_widget.currentRow()
                if 0 <= index < len(self.archived_notes):
                    del self.archived_notes[index]
                    list_widget.takeItem(index)
                    self.data_changed.emit()
    
    def manage_tags(self):
        """Gestionar etiquetas de la nota"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout, QListWidget, QMessageBox
        
        if self.current_note_index is None:
            QMessageBox.information(self, "Sin nota", "Selecciona una nota primero")
            return
        
        note = self.notes[self.current_note_index]
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Gestionar Etiquetas")
        dialog.setMinimumWidth(400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1e1e1e;
            }
            QLabel {
                color: #ffffff;
                font-size: 10pt;
                padding: 5px;
            }
            QLineEdit {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 8px;
            }
            QListWidget {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 5px;
            }
            QListWidget::item {
                padding: 8px;
                border-radius: 4px;
                margin: 2px;
                background-color: #3a3a3a;
            }
            QListWidget::item:selected {
                background-color: #4a90e2;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Etiquetas actuales:"))
        
        current_tags_list = QListWidget()
        current_tags = note.get("tags", [])
        for tag in current_tags:
            current_tags_list.addItem(f"üè∑Ô∏è {tag}")
        layout.addWidget(current_tags_list)
        
        # Input para nueva etiqueta
        input_layout = QHBoxLayout()
        tag_input = QLineEdit()
        tag_input.setPlaceholderText("Nueva etiqueta...")
        input_layout.addWidget(tag_input)
        
        add_tag_btn = QPushButton("‚ûï Agregar")
        add_tag_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        add_tag_btn.clicked.connect(lambda: self.add_tag_to_note(note, tag_input, current_tags_list))
        input_layout.addWidget(add_tag_btn)
        
        layout.addLayout(input_layout)
        
        # Bot√≥n eliminar etiqueta
        remove_tag_btn = QPushButton("üóëÔ∏è Eliminar etiqueta seleccionada")
        remove_tag_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #ff5555;
            }
        """)
        remove_tag_btn.clicked.connect(lambda: self.remove_tag_from_note(note, current_tags_list))
        layout.addWidget(remove_tag_btn)
        
        close_btn = QPushButton("Cerrar")
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                color: white;
                border: 1px solid #c0c0c0;
                padding: 8px 16px;
                border-radius: 4px;
            }
        """)
        close_btn.clicked.connect(dialog.close)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def add_tag_to_note(self, note, input_field, list_widget):
        """Agregar etiqueta a nota"""
        tag = input_field.text().strip()
        if tag:
            if "tags" not in note:
                note["tags"] = []
            if tag not in note["tags"]:
                note["tags"].append(tag)
                list_widget.addItem(f"üè∑Ô∏è {tag}")
                input_field.clear()
                
                # Agregar a lista global de etiquetas
                if tag not in self.tags:
                    self.tags.append(tag)
                
                self.data_changed.emit()
    
    def remove_tag_from_note(self, note, list_widget):
        """Eliminar etiqueta de nota"""
        current_item = list_widget.currentItem()
        if current_item:
            tag = current_item.text().replace("üè∑Ô∏è ", "")
            if tag in note.get("tags", []):
                note["tags"].remove(tag)
                list_widget.takeItem(list_widget.currentRow())
                self.data_changed.emit()
    
    def show_note_templates(self):
        """Mostrar plantillas de notas"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QListWidget, QPushButton, QMessageBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Plantillas de Notas")
        dialog.setMinimumSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1e1e1e;
            }
            QLabel {
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                padding: 10px;
            }
            QListWidget {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 5px;
                font-size: 10pt;
            }
            QListWidget::item {
                padding: 10px;
                border-radius: 4px;
                margin: 2px;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:selected {
                background-color: #4a90e2;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        title = QLabel("Selecciona una plantilla:")
        layout.addWidget(title)
        
        templates_list = QListWidget()
        
        templates = {
            "üìù Nota Simple": {"title": "Nueva Nota", "content": ""},
            "üìã Lista de Verificaci√≥n": {
                "title": "Lista de Verificaci√≥n",
                "content": "‚òê Item 1\n‚òê Item 2\n‚òê Item 3\n‚òê Item 4\n‚òê Item 5"
            },
            "üí° Idea de Proyecto": {
                "title": "Idea de Proyecto",
                "content": "<b>Descripci√≥n:</b><br><br><b>Objetivos:</b><br>1. <br>2. <br>3. <br><br><b>Recursos necesarios:</b><br><br><b>Timeline:</b><br>"
            },
            "üìÖ Reuni√≥n": {
                "title": "Notas de Reuni√≥n",
                "content": "<b>Fecha:</b><br><b>Asistentes:</b><br><br><b>Temas discutidos:</b><br>1. <br>2. <br><br><b>Decisiones:</b><br><br><b>Acciones a seguir:</b><br>"
            },
            "üéØ Plan de Acci√≥n": {
                "title": "Plan de Acci√≥n",
                "content": "<b>Objetivo:</b><br><br><b>Pasos:</b><br>1. <br>2. <br>3. <br><br><b>Responsable:</b><br><b>Fecha l√≠mite:</b><br>"
            },
            "üìñ Aprendizaje": {
                "title": "Notas de Aprendizaje",
                "content": "<b>Tema:</b><br><br><b>Conceptos clave:</b><br>‚Ä¢ <br>‚Ä¢ <br><br><b>Ejemplos:</b><br><br><b>Recursos:</b><br>"
            },
            "üí≠ Diario Personal": {
                "title": "Entrada de Diario",
                "content": "<b>Fecha:</b><br><br><b>C√≥mo me siento hoy:</b><br><br><b>Lo que pas√≥ hoy:</b><br><br><b>Agradecimientos:</b><br>"
            },
            "üöÄ Proyecto": {
                "title": "Proyecto",
                "content": "<b>Nombre del proyecto:</b><br><br><b>Descripci√≥n:</b><br><br><b>Fases:</b><br>1. <br>2. <br>3. <br><br><b>Estado:</b><br>"
            }
        }
        
        for template_name in templates.keys():
            templates_list.addItem(template_name)
        
        layout.addWidget(templates_list)
        
        # Botones
        buttons_layout = QHBoxLayout()
        
        load_btn = QPushButton("‚úì Usar plantilla")
        load_btn.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        load_btn.clicked.connect(lambda: self.load_note_template(templates, templates_list, dialog))
        buttons_layout.addWidget(load_btn)
        
        close_btn = QPushButton("Cerrar")
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                color: white;
                border: 1px solid #c0c0c0;
                padding: 8px 16px;
                border-radius: 4px;
            }
        """)
        close_btn.clicked.connect(dialog.close)
        buttons_layout.addWidget(close_btn)
        
        layout.addLayout(buttons_layout)
        
        dialog.exec()
    
    def load_note_template(self, templates, list_widget, dialog):
        """Cargar plantilla seleccionada"""
        selected_items = list_widget.selectedItems()
        if selected_items:
            template_name = selected_items[0].text()
            if template_name in templates:
                template_data = templates[template_name]
                
                # Crear nueva nota con la plantilla
                import datetime
                note = {
                    "id": datetime.datetime.now().strftime("%Y%m%d%H%M%S%f"),
                    "title": template_data["title"],
                    "content": template_data["content"],
                    "category": self.categories[0],
                    "created": datetime.datetime.now().isoformat(),
                    "modified": datetime.datetime.now().isoformat(),
                    "priority": "üü° Media",
                    "tags": [],
                    "pinned": False,
                    "archived": False,
                    "color": "#4a90e2",
                    "reminder": None,
                    "attachments": [],
                    "checklist": []
                }
                
                self.notes.append(note)
                self.refresh_notes_list()
                
                # Seleccionar la nueva nota
                self.current_note_index = len(self.notes) - 1
                self.notes_list.setCurrentRow(self.current_note_index)
                self.load_note_at_index(self.current_note_index)
                
                self.data_changed.emit()
                
                dialog.close()
                QMessageBox.information(self, "Plantilla cargada", f"Plantilla '{template_name}' cargada exitosamente")
    
    def export_notes(self):
        """Exportar notas a archivo"""
        from PyQt6.QtWidgets import QFileDialog, QMessageBox
        
        if not self.notes:
            QMessageBox.information(self, "Sin notas", "No hay notas para exportar")
            return
        
        file_name, filter_type = QFileDialog.getSaveFileName(
            self,
            "Exportar Notas",
            "",
            "Archivo HTML (*.html);;Archivo de Texto (*.txt);;Archivo Markdown (*.md);;JSON (*.json)"
        )
        
        if not file_name:
            return
        
        try:
            if file_name.endswith('.html') or "HTML" in filter_type:
                self.export_notes_html(file_name)
            elif file_name.endswith('.txt') or "Texto" in filter_type:
                self.export_notes_txt(file_name)
            elif file_name.endswith('.md') or "Markdown" in filter_type:
                self.export_notes_markdown(file_name)
            elif file_name.endswith('.json') or "JSON" in filter_type:
                self.export_notes_json(file_name)
            else:
                file_name += '.html'
                self.export_notes_html(file_name)
            
            QMessageBox.information(
                self,
                "Exportaci√≥n exitosa",
                f"Notas exportadas a:\n{file_name}"
            )
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de exportaci√≥n",
                f"No se pudo exportar:\n{str(e)}"
            )
    
    def export_notes_html(self, file_name):
        """Exportar notas a HTML"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write('<!DOCTYPE html>\n<html>\n<head>\n')
            f.write('<meta charset="UTF-8">\n<title>Mis Notas</title>\n')
            f.write('<style>\n')
            f.write('body { font-family: Arial, sans-serif; background-color: #f5f5f5; padding: 20px; }\n')
            f.write('.note { background-color: white; margin: 20px; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n')
            f.write('.note-title { font-size: 24pt; font-weight: bold; color: #333; margin-bottom: 10px; }\n')
            f.write('.note-meta { color: #888; font-size: 10pt; margin-bottom: 15px; }\n')
            f.write('.note-content { color: #444; line-height: 1.6; }\n')
            f.write('</style>\n</head>\n<body>\n')
            f.write('<h1>üìù Mis Notas</h1>\n')
            
            for note in self.notes:
                if not note.get("archived", False):
                    f.write('<div class="note">\n')
                    f.write(f'<div class="note-title">{note.get("title", "Sin t√≠tulo")}</div>\n')
                    f.write(f'<div class="note-meta">Categor√≠a: {note.get("category", "Sin categor√≠a")} | ')
                    f.write(f'Prioridad: {note.get("priority", "Media")} | ')
                    f.write(f'Creada: {note.get("created", "")[:10]}</div>\n')
                    f.write(f'<div class="note-content">{note.get("content", "")}</div>\n')
                    
                    tags = note.get("tags", [])
                    if tags:
                        f.write(f'<div style="margin-top: 10px;">üè∑Ô∏è {", ".join(tags)}</div>\n')
                    
                    f.write('</div>\n')
            
            f.write('</body>\n</html>')
    
    def export_notes_txt(self, file_name):
        """Exportar notas a texto plano"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("MIS NOTAS\n")
            f.write("=" * 80 + "\n\n")
            
            for note in self.notes:
                if not note.get("archived", False):
                    f.write(f"T√çTULO: {note.get('title', 'Sin t√≠tulo')}\n")
                    f.write(f"CATEGOR√çA: {note.get('category', 'Sin categor√≠a')}\n")
                    f.write(f"PRIORIDAD: {note.get('priority', 'Media')}\n")
                    f.write(f"CREADA: {note.get('created', '')[:10]}\n")
                    
                    tags = note.get("tags", [])
                    if tags:
                        f.write(f"ETIQUETAS: {', '.join(tags)}\n")
                    
                    f.write("-" * 80 + "\n")
                    
                    # Convertir HTML a texto plano (simplificado)
                    import re
                    content = note.get("content", "")
                    content = re.sub('<[^<]+?>', '', content)  # Eliminar tags HTML
                    f.write(content + "\n")
                    f.write("\n" + "=" * 80 + "\n\n")
    
    def export_notes_markdown(self, file_name):
        """Exportar notas a Markdown"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write("# üìù Mis Notas\n\n")
            
            for note in self.notes:
                if not note.get("archived", False):
                    f.write(f"## {note.get('title', 'Sin t√≠tulo')}\n\n")
                    f.write(f"**Categor√≠a:** {note.get('category', 'Sin categor√≠a')}  \n")
                    f.write(f"**Prioridad:** {note.get('priority', 'Media')}  \n")
                    f.write(f"**Fecha:** {note.get('created', '')[:10]}  \n")
                    
                    tags = note.get("tags", [])
                    if tags:
                        f.write(f"**Etiquetas:** {', '.join(tags)}  \n")
                    
                    f.write("\n")
                    
                    # Convertir HTML a Markdown (simplificado)
                    import re
                    content = note.get("content", "")
                    content = re.sub('<b>(.*?)</b>', r'**\1**', content)
                    content = re.sub('<i>(.*?)</i>', r'*\1*', content)
                    content = re.sub('<[^<]+?>', '', content)
                    f.write(content + "\n")
                    f.write("\n---\n\n")
    
    def export_notes_json(self, file_name):
        """Exportar notas a JSON"""
        import json
        
        with open(file_name, 'w', encoding='utf-8') as f:
            export_data = {
                "notes": [n for n in self.notes if not n.get("archived", False)],
                "exported_date": datetime.now().isoformat()
            }
            json.dump(export_data, f, ensure_ascii=False, indent=2)
    
    def import_notes(self):
        """Importar notas desde archivo"""
        from PyQt6.QtWidgets import QFileDialog, QMessageBox
        import json
        
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Importar Notas",
            "",
            "Archivos JSON (*.json);;Todos los archivos (*.*)"
        )
        
        if not file_name:
            return
        
        try:
            with open(file_name, 'r', encoding='utf-8') as f:
                data = json.load(f)
                imported_notes = data.get("notes", [])
                
                if imported_notes:
                    self.notes.extend(imported_notes)
                    self.refresh_notes_list()
                    self.data_changed.emit()
                    
                    QMessageBox.information(
                        self,
                        "Importaci√≥n exitosa",
                        f"Se importaron {len(imported_notes)} notas"
                    )
                else:
                    QMessageBox.warning(self, "Sin datos", "No se encontraron notas en el archivo")
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de importaci√≥n",
                f"No se pudo importar:\n{str(e)}"
            )
    
    def show_sort_tasks_menu(self):
        """Mostrar men√∫ de ordenamiento de tareas"""
        from PyQt6.QtWidgets import QMenu
        
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
        """)
        
        menu.addAction("üî¥ Por prioridad (Alta‚ÜíBaja)").triggered.connect(lambda: self.sort_tasks("priority"))
        menu.addAction("üìÖ Por fecha (M√°s reciente)").triggered.connect(lambda: self.sort_tasks("date"))
        menu.addAction("üî§ Por nombre (A-Z)").triggered.connect(lambda: self.sort_tasks("name"))
        menu.addAction("‚úÖ Completadas al final").triggered.connect(lambda: self.sort_tasks("completed"))
        
        menu.exec(self.sender().mapToGlobal(self.sender().rect().bottomLeft()))
    
    def sort_tasks(self, sort_type):
        """Ordenar tareas seg√∫n criterio"""
        if sort_type == "priority":
            priority_order = {"üî¥ Alta": 0, "üü° Media": 1, "üü¢ Baja": 2}
            self.tasks.sort(key=lambda t: priority_order.get(t.get("priority", "üü° Media"), 1))
        elif sort_type == "date":
            self.tasks.sort(key=lambda t: t.get("created", ""), reverse=True)
        elif sort_type == "name":
            self.tasks.sort(key=lambda t: t.get("text", "").lower())
        elif sort_type == "completed":
            self.tasks.sort(key=lambda t: t.get("completed", False))
        
        self.refresh_tasks_list()
        self.data_changed.emit()
    
    def clear_completed_tasks(self):
        """Limpiar tareas completadas"""
        from PyQt6.QtWidgets import QMessageBox
        
        completed = [t for t in self.tasks if t.get("completed", False)]
        
        if not completed:
            QMessageBox.information(self, "Sin tareas completadas", "No hay tareas completadas para limpiar")
            return
        
        reply = QMessageBox.question(
            self,
            "Limpiar tareas completadas",
            f"¬øEliminar {len(completed)} tareas completadas?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.tasks = [t for t in self.tasks if not t.get("completed", False)]
            self.refresh_tasks_list()
            self.data_changed.emit()
            
            QMessageBox.information(self, "Tareas eliminadas", f"Se eliminaron {len(completed)} tareas completadas")
    
    def export_tasks(self):
        """Exportar tareas a archivo"""
        from PyQt6.QtWidgets import QFileDialog, QMessageBox
        
        if not self.tasks:
            QMessageBox.information(self, "Sin tareas", "No hay tareas para exportar")
            return
        
        file_name, _ = QFileDialog.getSaveFileName(
            self,
            "Exportar Tareas",
            "",
            "Archivo de Texto (*.txt);;Archivo Markdown (*.md);;JSON (*.json)"
        )
        
        if not file_name:
            return
        
        try:
            if file_name.endswith('.txt'):
                self.export_tasks_txt(file_name)
            elif file_name.endswith('.md'):
                self.export_tasks_markdown(file_name)
            elif file_name.endswith('.json'):
                self.export_tasks_json(file_name)
            else:
                file_name += '.txt'
                self.export_tasks_txt(file_name)
            
            QMessageBox.information(
                self,
                "Exportaci√≥n exitosa",
                f"Tareas exportadas a:\n{file_name}"
            )
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de exportaci√≥n",
                f"No se pudo exportar:\n{str(e)}"
            )
    
    def export_tasks_txt(self, file_name):
        """Exportar tareas a texto"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write("=" * 60 + "\n")
            f.write("MIS TAREAS\n")
            f.write("=" * 60 + "\n\n")
            
            pending = [t for t in self.tasks if not t.get("completed", False)]
            completed = [t for t in self.tasks if t.get("completed", False)]
            
            f.write(f"PENDIENTES ({len(pending)}):\n")
            f.write("-" * 60 + "\n")
            for i, task in enumerate(pending, 1):
                f.write(f"{i}. [ ] {task.get('text', '')}\n")
                if task.get('priority'):
                    f.write(f"    Prioridad: {task['priority']}\n")
            
            f.write("\n")
            f.write(f"COMPLETADAS ({len(completed)}):\n")
            f.write("-" * 60 + "\n")
            for i, task in enumerate(completed, 1):
                f.write(f"{i}. [‚úì] {task.get('text', '')}\n")
    
    def export_tasks_markdown(self, file_name):
        """Exportar tareas a Markdown"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write("# ‚úÖ Mis Tareas\n\n")
            
            pending = [t for t in self.tasks if not t.get("completed", False)]
            completed = [t for t in self.tasks if t.get("completed", False)]
            
            f.write(f"## üìã Pendientes ({len(pending)})\n\n")
            for task in pending:
                priority = task.get('priority', 'üü° Media')
                f.write(f"- [ ] {priority} {task.get('text', '')}\n")
            
            f.write(f"\n## ‚úì Completadas ({len(completed)})\n\n")
            for task in completed:
                f.write(f"- [x] {task.get('text', '')}\n")
    
    def export_tasks_json(self, file_name):
        """Exportar tareas a JSON"""
        import json
        
        with open(file_name, 'w', encoding='utf-8') as f:
            export_data = {
                "tasks": self.tasks,
                "exported_date": datetime.now().isoformat()
            }
            json.dump(export_data, f, ensure_ascii=False, indent=2)
    
    def edit_task(self, task_id):
        """Editar tarea avanzada"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QComboBox, QDateEdit, QTextEdit, QDialogButtonBox, QSpinBox
        from PyQt6.QtCore import QDate
        
        task = None
        for t in self.tasks:
            if t["id"] == task_id:
                task = t
                break
        
        if not task:
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Editar Tarea")
        dialog.setMinimumWidth(500)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #1e1e1e;
            }
            QLabel {
                color: #ffffff;
                font-size: 10pt;
                padding: 5px;
            }
            QLineEdit, QTextEdit, QComboBox, QDateEdit, QSpinBox {
                background-color: #2a2a2a;
                color: #ffffff;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        # Texto de la tarea
        layout.addWidget(QLabel("Descripci√≥n de la tarea:"))
        text_input = QLineEdit()
        text_input.setText(task.get("text", ""))
        layout.addWidget(text_input)
        
        # Prioridad
        layout.addWidget(QLabel("Prioridad:"))
        priority_combo = QComboBox()
        for p in self.priorities:
            priority_combo.addItem(p)
        priority_combo.setCurrentText(task.get("priority", "üü° Media"))
        layout.addWidget(priority_combo)
        
        # Categor√≠a
        layout.addWidget(QLabel("Categor√≠a:"))
        category_input = QLineEdit()
        category_input.setText(task.get("category", "General"))
        layout.addWidget(category_input)
        
        # Fecha de vencimiento
        layout.addWidget(QLabel("Fecha de vencimiento:"))
        date_edit = QDateEdit()
        date_edit.setCalendarPopup(True)
        date_edit.setDate(QDate.currentDate())
        layout.addWidget(date_edit)
        
        # Progreso
        layout.addWidget(QLabel("Progreso (%):"))
        progress_spin = QSpinBox()
        progress_spin.setRange(0, 100)
        progress_spin.setValue(task.get("progress", 0))
        progress_spin.setSuffix("%")
        layout.addWidget(progress_spin)
        
        # Notas adicionales
        layout.addWidget(QLabel("Notas adicionales:"))
        notes_text = QTextEdit()
        notes_text.setMaximumHeight(100)
        notes_text.setPlainText(task.get("notes", ""))
        layout.addWidget(notes_text)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Actualizar tarea
            task["text"] = text_input.text()
            task["priority"] = priority_combo.currentText()
            task["category"] = category_input.text()
            task["due_date"] = date_edit.date().toString("yyyy-MM-dd")
            task["progress"] = progress_spin.value()
            task["notes"] = notes_text.toPlainText()
            
            self.refresh_tasks_list()
            self.data_changed.emit()
            
            QMessageBox.information(self, "Tarea actualizada", "La tarea ha sido actualizada exitosamente")


class SimpleChartWidget(QWidget):
    """Widget simple para mostrar gr√°ficos"""
    
    def __init__(self, data, labels, chart_type, parent=None):
        super().__init__(parent)
        self.data = data
        self.labels = labels
        self.chart_type = chart_type
        self.setMinimumSize(500, 300)
        
    def paintEvent(self, event):
        """Dibujar el gr√°fico"""
        from PyQt6.QtGui import QPainter, QColor, QPen, QBrush
        from PyQt6.QtCore import Qt, QRect
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Configurar √°rea de dibujo
        width = self.width()
        height = self.height()
        margin = 50
        chart_width = width - 2 * margin
        chart_height = height - 2 * margin
        
        if not self.data:
            return
        
        # Fondo del gr√°fico
        painter.fillRect(self.rect(), QColor("#1a1a1a"))
        
        # Dibujar seg√∫n el tipo
        if "barras" in self.chart_type.lower():
            self.draw_bar_chart(painter, margin, chart_width, chart_height)
        elif "l√≠neas" in self.chart_type.lower():
            self.draw_line_chart(painter, margin, chart_width, chart_height)
        elif "circular" in self.chart_type.lower():
            self.draw_pie_chart(painter, margin, chart_width, chart_height)
        else:
            self.draw_bar_chart(painter, margin, chart_width, chart_height)
    
    def draw_bar_chart(self, painter, margin, chart_width, chart_height):
        """Dibujar gr√°fico de barras"""
        from PyQt6.QtGui import QColor, QBrush
        from PyQt6.QtCore import QRect
        
        if not self.data:
            return
        
        max_value = max(self.data) if self.data else 1
        num_bars = len(self.data)
        bar_width = chart_width / num_bars * 0.8
        spacing = chart_width / num_bars * 0.2
        
        colors = [
            "#4a90e2", "#e74c3c", "#2ecc71", "#f39c12",
            "#9b59b6", "#1abc9c", "#e67e22", "#3498db"
        ]
        
        for i, value in enumerate(self.data):
            bar_height = (value / max_value) * chart_height
            x = margin + i * (bar_width + spacing)
            y = self.height() - margin - bar_height
            
            # Dibujar barra
            color = QColor(colors[i % len(colors)])
            painter.fillRect(int(x), int(y), int(bar_width), int(bar_height), color)
            
            # Dibujar valor
            painter.setPen(QColor("#ffffff"))
            painter.drawText(int(x), int(y - 5), int(bar_width), 20, 
                           Qt.AlignmentFlag.AlignCenter, f"{value:.1f}")
            
            # Dibujar etiqueta
            if i < len(self.labels):
                painter.drawText(int(x), self.height() - margin + 15, int(bar_width), 20,
                               Qt.AlignmentFlag.AlignCenter, str(self.labels[i]))
    
    def draw_line_chart(self, painter, margin, chart_width, chart_height):
        """Dibujar gr√°fico de l√≠neas"""
        from PyQt6.QtGui import QColor, QPen
        from PyQt6.QtCore import QPoint
        
        if not self.data or len(self.data) < 2:
            return
        
        max_value = max(self.data)
        min_value = min(self.data)
        value_range = max_value - min_value if max_value != min_value else 1
        
        # Configurar l√≠nea
        pen = QPen(QColor("#4a90e2"), 3)
        painter.setPen(pen)
        
        # Calcular puntos
        points = []
        for i, value in enumerate(self.data):
            x = margin + (i / (len(self.data) - 1)) * chart_width
            y = self.height() - margin - ((value - min_value) / value_range) * chart_height
            points.append(QPoint(int(x), int(y)))
        
        # Dibujar l√≠neas
        for i in range(len(points) - 1):
            painter.drawLine(points[i], points[i + 1])
        
        # Dibujar puntos
        painter.setBrush(QColor("#e74c3c"))
        for point in points:
            painter.drawEllipse(point, 5, 5)
    
    def draw_pie_chart(self, painter, margin, chart_width, chart_height):
        """Dibujar gr√°fico circular"""
        from PyQt6.QtGui import QColor
        from PyQt6.QtCore import QRect
        
        if not self.data:
            return
        
        total = sum(self.data)
        if total == 0:
            return
        
        # Centro y radio del c√≠rculo
        center_x = self.width() // 2
        center_y = self.height() // 2
        radius = min(chart_width, chart_height) // 2
        
        colors = [
            "#4a90e2", "#e74c3c", "#2ecc71", "#f39c12",
            "#9b59b6", "#1abc9c", "#e67e22", "#3498db"
        ]
        
        start_angle = 0
        for i, value in enumerate(self.data):
            span_angle = int((value / total) * 360 * 16)  # Qt usa 1/16 de grado
            
            painter.setBrush(QColor(colors[i % len(colors)]))
            painter.setPen(QColor("#1a1a1a"))
            
            rect = QRect(center_x - radius, center_y - radius, radius * 2, radius * 2)
            painter.drawPie(rect, start_angle, span_angle)
            
            start_angle += span_angle


class SpreadsheetTab(QWidget):
    """Pesta√±a de hoja de c√°lculo tipo Microsoft Excel con todas las funciones profesionales"""
    
    data_changed = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.spreadsheet_data = {}
        self.formulas = {}
        self.dependencies = {}
        self.current_sheet = "Hoja1"
        self.sheets = {"Hoja1": {"data": {}, "formulas": {}, "dependencies": {}}}
        self.updating_cells = set()
        self.clipboard_data = None
        self.clipboard_format = None
        self.frozen_rows = 0
        self.frozen_cols = 0
        self.cell_formats = {}  # Almacenar formatos de celdas
        self.number_formats = {}  # Almacenar formatos num√©ricos
        self.current_font_family = "Calibri"
        self.current_font_size = 11
        self.undo_stack = []
        self.redo_stack = []
        self.setup_ui()
        self.setup_shortcuts()
        
    def setup_ui(self):
        """Configurar interfaz completa estilo Microsoft Excel"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # ===== RIBBON/CINTA DE OPCIONES ESTILO EXCEL =====
        self.ribbon = self.create_ribbon()
        main_layout.addWidget(self.ribbon)
        
        # ===== BARRA DE F√ìRMULAS MEJORADA =====
        formula_bar = self.create_formula_bar()
        main_layout.addWidget(formula_bar)
        
        # ===== √ÅREA DE LA TABLA MEJORADA =====
        self.table = QTableWidget(1000, 52)  # 1000 filas, 52 columnas (A-AZ)
        self.table.setStyleSheet("""
            QTableWidget {
                background-color: #ffffff;
                gridline-color: #d4d4d4;
                color: #000000;
                border: none;
                font-family: 'Calibri', 'Segoe UI', sans-serif;
                font-size: 11pt;
                selection-background-color: #c7dff7;
                selection-color: #000000;
            }
            QTableWidget::item {
                padding: 2px 4px;
                border-right: 1px solid #d4d4d4;
                border-bottom: 1px solid #d4d4d4;
            }
            QTableWidget::item:selected {
                background-color: #c7dff7;
                color: #000000;
                border: 2px solid #217346;
            }
            QTableWidget::item:focus {
                background-color: #ffffff;
                border: 2px solid #217346;
            }
            QHeaderView::section {
                background-color: #e9ecef;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 4px 8px;
                font-weight: 500;
                font-size: 10pt;
            }
            QHeaderView::section:checked {
                background-color: #217346;
                color: #ffffff;
            }
            QHeaderView::section:hover {
                background-color: #d5d8dc;
            }
            QTableCornerButton::section {
                background-color: #e9ecef;
                border: 1px solid #c0c0c0;
            }
            QScrollBar:vertical {
                background: #f0f0f0;
                width: 14px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background: #c1c1c1;
                min-height: 30px;
                border-radius: 3px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a1a1a1;
            }
            QScrollBar:horizontal {
                background: #f0f0f0;
                height: 14px;
                border: none;
            }
            QScrollBar::handle:horizontal {
                background: #c1c1c1;
                min-width: 30px;
                border-radius: 3px;
                margin: 2px;
            }
            QScrollBar::add-line, QScrollBar::sub-line {
                border: none;
                background: none;
            }
        """)
        
        # Configurar encabezados de columnas (A-AZ)
        column_headers = []
        for i in range(52):
            if i < 26:
                column_headers.append(chr(65 + i))
            else:
                column_headers.append('A' + chr(65 + i - 26))
        self.table.setHorizontalHeaderLabels(column_headers)
        
        # Configurar encabezados de filas
        row_headers = [str(i + 1) for i in range(1000)]
        self.table.setVerticalHeaderLabels(row_headers)
        
        # Configurar tama√±os de columnas y filas
        for col in range(52):
            self.table.setColumnWidth(col, 85)
        for row in range(1000):
            self.table.setRowHeight(row, 22)
        
        # Configurar selecci√≥n
        self.table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectItems)
        
        # Conectar eventos
        self.table.cellChanged.connect(self.on_cell_changed)
        self.table.currentCellChanged.connect(self.on_cell_selected)
        self.table.itemSelectionChanged.connect(self.on_selection_changed)
        
        # Men√∫ contextual
        self.table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        
        # Habilitar drag and drop para autorellenado
        self.table.setDragEnabled(True)
        self.table.setAcceptDrops(True)
        self.table.setDragDropMode(QTableWidget.DragDropMode.InternalMove)
        
        main_layout.addWidget(self.table, 1)
        
        # ===== PANEL INFERIOR CON PESTA√ëAS DE HOJAS =====
        bottom_panel = self.create_bottom_panel()
        main_layout.addWidget(bottom_panel)
        
    def setup_shortcuts(self):
        """Configurar atajos de teclado estilo Excel"""
        from PyQt6.QtGui import QShortcut, QKeySequence
        
        # Atajos b√°sicos
        QShortcut(QKeySequence("Ctrl+C"), self, self.copy_cells)
        QShortcut(QKeySequence("Ctrl+V"), self, self.paste_cells)
        QShortcut(QKeySequence("Ctrl+X"), self, self.cut_cells)
        QShortcut(QKeySequence("Ctrl+Z"), self, self.undo_action)
        QShortcut(QKeySequence("Ctrl+Y"), self, self.redo_action)
        QShortcut(QKeySequence("Ctrl+B"), self, self.quick_toggle_bold)
        QShortcut(QKeySequence("Ctrl+I"), self, self.quick_toggle_italic)
        QShortcut(QKeySequence("Ctrl+U"), self, self.quick_toggle_underline)
        QShortcut(QKeySequence("Ctrl+S"), self, lambda: self.data_changed.emit())
        QShortcut(QKeySequence("Ctrl+F"), self, self.show_search_dialog)
        QShortcut(QKeySequence("Ctrl+H"), self, self.show_search_dialog)
        QShortcut(QKeySequence("Delete"), self, self.clear_selected_cells)
        QShortcut(QKeySequence("Ctrl+D"), self, self.autofill_down)
        QShortcut(QKeySequence("Ctrl+R"), self, self.autofill_right)
        QShortcut(QKeySequence("F2"), self, self.edit_current_cell)
        QShortcut(QKeySequence("Ctrl+1"), self, self.show_format_cells_dialog)
        QShortcut(QKeySequence("Ctrl+Shift+="), self, self.insert_row)
        QShortcut(QKeySequence("Ctrl+-"), self, self.delete_row)
    
    def get_dialog_style(self):
        """Obtener estilo est√°ndar para di√°logos de Excel"""
        return """
            QDialog {
                background-color: #f3f3f3;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
            }
            QLineEdit, QTextEdit, QPlainTextEdit {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                padding: 6px;
                font-size: 10pt;
            }
            QLineEdit:focus, QTextEdit:focus {
                border: 1px solid #217346;
            }
            QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                padding: 5px;
                font-size: 10pt;
            }
            QComboBox:focus {
                border: 1px solid #217346;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
                selection-color: #ffffff;
            }
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 3px;
                font-size: 10pt;
                font-weight: bold;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
            QPushButton:pressed {
                background-color: #145a2c;
            }
            QCheckBox {
                color: #333333;
                font-size: 10pt;
            }
            QRadioButton {
                color: #333333;
                font-size: 10pt;
            }
            QSpinBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                padding: 4px;
                font-size: 10pt;
            }
            QGroupBox {
                color: #333333;
                font-weight: bold;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                margin-top: 8px;
                padding-top: 8px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }
            QListWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
            }
            QListWidget::item {
                padding: 6px;
            }
            QListWidget::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
            QListWidget::item:hover {
                background-color: #e5f3eb;
            }
            QTabWidget::pane {
                border: 1px solid #c0c0c0;
                background-color: #ffffff;
            }
            QTabBar::tab {
                background-color: #e9ecef;
                color: #333333;
                padding: 8px 16px;
                border: 1px solid #c0c0c0;
                border-bottom: none;
            }
            QTabBar::tab:selected {
                background-color: #ffffff;
                border-bottom: 1px solid #ffffff;
            }
        """
    
    def create_ribbon(self):
        """Crear cinta de opciones estilo Microsoft Excel"""
        ribbon_container = QWidget()
        ribbon_container.setStyleSheet("""
            QWidget {
                background-color: #f3f3f3;
                border-bottom: 1px solid #d4d4d4;
            }
        """)
        ribbon_container.setFixedHeight(140)
        
        layout = QVBoxLayout(ribbon_container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Pesta√±as del Ribbon
        self.ribbon_tabs = QTabWidget()
        self.ribbon_tabs.setStyleSheet("""
            QTabWidget::pane {
                border: none;
                background-color: #f3f3f3;
            }
            QTabBar::tab {
                background-color: #f3f3f3;
                color: #444444;
                padding: 8px 16px;
                margin-right: 2px;
                border: none;
                border-bottom: 3px solid transparent;
                font-weight: 500;
                font-size: 10pt;
            }
            QTabBar::tab:hover {
                background-color: #e5e5e5;
            }
            QTabBar::tab:selected {
                background-color: #ffffff;
                border-bottom: 3px solid #217346;
                color: #217346;
                font-weight: bold;
            }
        """)
        
        # === PESTA√ëA INICIO ===
        inicio_tab = self.create_tab_inicio()
        self.ribbon_tabs.addTab(inicio_tab, "Inicio")
        
        # === PESTA√ëA INSERTAR ===
        insertar_tab = self.create_tab_insertar()
        self.ribbon_tabs.addTab(insertar_tab, "Insertar")
        
        # === PESTA√ëA F√ìRMULAS ===
        formulas_tab = self.create_tab_formulas()
        self.ribbon_tabs.addTab(formulas_tab, "F√≥rmulas")
        
        # === PESTA√ëA DATOS ===
        datos_tab = self.create_tab_datos()
        self.ribbon_tabs.addTab(datos_tab, "Datos")
        
        # === PESTA√ëA VISTA ===
        vista_tab = self.create_tab_vista()
        self.ribbon_tabs.addTab(vista_tab, "Vista")
        
        layout.addWidget(self.ribbon_tabs)
        
        return ribbon_container
    
    def create_ribbon_button(self, icon, text, tooltip="", size="normal"):
        """Crear bot√≥n del Ribbon con estilo Excel mejorado"""
        btn = QPushButton()
        btn.setToolTip(tooltip if tooltip else text)
        
        if size == "large":
            btn.setMinimumSize(65, 66)
            btn.setMaximumSize(80, 66)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid transparent;
                    border-radius: 3px;
                    padding: 3px;
                    font-size: 9pt;
                    color: #333333;
                    font-family: 'Segoe UI', 'Arial', sans-serif;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                    border: 1px solid #c0c0c0;
                }
                QPushButton:pressed {
                    background-color: #d0d0d0;
                }
            """)
            btn.setText(f"{icon}\n{text}")
        else:
            btn.setMinimumHeight(22)
            btn.setMinimumWidth(80)
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid transparent;
                    border-radius: 2px;
                    padding: 2px 6px;
                    font-size: 9pt;
                    color: #333333;
                    text-align: left;
                    font-family: 'Segoe UI', 'Arial', sans-serif;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                    border: 1px solid #c0c0c0;
                }
                QPushButton:pressed {
                    background-color: #d0d0d0;
                }
            """)
            btn.setText(f"{icon} {text}")
        
        return btn
    
    def create_ribbon_separator(self):
        """Crear separador vertical para el Ribbon"""
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.VLine)
        separator.setStyleSheet("background-color: #c0c0c0; margin: 5px 8px;")
        separator.setFixedWidth(1)
        return separator
    
    def create_ribbon_group(self, title):
        """Crear grupo del Ribbon con t√≠tulo"""
        group = QWidget()
        group.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
        """)
        
        layout = QVBoxLayout(group)
        layout.setContentsMargins(5, 2, 5, 2)
        layout.setSpacing(2)
        
        content = QWidget()
        content_layout = QHBoxLayout(content)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(3)
        
        label = QLabel(title)
        label.setStyleSheet("""
            color: #666666;
            font-size: 8pt;
            padding: 2px;
        """)
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        layout.addWidget(content, 1)
        layout.addWidget(label)
        
        return group, content_layout
    
    def create_tab_inicio(self):
        """Crear pesta√±a Inicio del Ribbon"""
        tab = QWidget()
        tab.setStyleSheet("background-color: #ffffff;")
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)
        
        # === GRUPO PORTAPAPELES ===
        clipboard_group, clipboard_layout = self.create_ribbon_group("Portapapeles")
        
        paste_btn = self.create_ribbon_button("üìã", "Pegar", "Pegar (Ctrl+V)", "large")
        paste_btn.clicked.connect(self.paste_cells)
        clipboard_layout.addWidget(paste_btn)
        
        clipboard_actions = QWidget()
        clipboard_actions_layout = QVBoxLayout(clipboard_actions)
        clipboard_actions_layout.setContentsMargins(0, 0, 0, 0)
        clipboard_actions_layout.setSpacing(2)
        
        cut_btn = self.create_ribbon_button("‚úÇÔ∏è", "Cortar", "Cortar (Ctrl+X)")
        cut_btn.clicked.connect(self.cut_cells)
        copy_btn = self.create_ribbon_button("üìÑ", "Copiar", "Copiar (Ctrl+C)")
        copy_btn.clicked.connect(self.copy_cells)
        format_painter_btn = self.create_ribbon_button("üñåÔ∏è", "Copiar formato")
        format_painter_btn.clicked.connect(self.copy_format)
        
        clipboard_actions_layout.addWidget(cut_btn)
        clipboard_actions_layout.addWidget(copy_btn)
        clipboard_actions_layout.addWidget(format_painter_btn)
        clipboard_layout.addWidget(clipboard_actions)
        
        layout.addWidget(clipboard_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO FUENTE ===
        font_group, font_layout = self.create_ribbon_group("Fuente")
        
        font_widget = QWidget()
        font_widget_layout = QVBoxLayout(font_widget)
        font_widget_layout.setContentsMargins(0, 0, 0, 0)
        font_widget_layout.setSpacing(3)
        
        # Fila 1: Selector de fuente y tama√±o
        font_row1 = QWidget()
        font_row1_layout = QHBoxLayout(font_row1)
        font_row1_layout.setContentsMargins(0, 0, 0, 0)
        font_row1_layout.setSpacing(3)
        
        self.font_combo = QComboBox()
        self.font_combo.addItems([
            "Calibri", "Arial", "Times New Roman", "Verdana", "Tahoma", 
            "Georgia", "Trebuchet MS", "Segoe UI", "Consolas", "Courier New",
            "Comic Sans MS", "Impact", "Palatino Linotype", "Century Gothic"
        ])
        self.font_combo.setFixedWidth(120)
        self.font_combo.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 2px;
                padding: 2px 5px;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #217346;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                selection-background-color: #217346;
                selection-color: #ffffff;
            }
        """)
        self.font_combo.currentTextChanged.connect(self.change_font_family)
        font_row1_layout.addWidget(self.font_combo)
        
        self.font_size_combo = QComboBox()
        self.font_size_combo.addItems(["8", "9", "10", "11", "12", "14", "16", "18", "20", "22", "24", "26", "28", "36", "48", "72"])
        self.font_size_combo.setCurrentText("11")
        self.font_size_combo.setFixedWidth(50)
        self.font_size_combo.setEditable(True)
        self.font_size_combo.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 2px;
                padding: 2px 5px;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #217346;
            }
        """)
        self.font_size_combo.currentTextChanged.connect(self.change_font_size)
        font_row1_layout.addWidget(self.font_size_combo)
        
        font_widget_layout.addWidget(font_row1)
        
        # Fila 2: Formato de texto
        font_row2 = QWidget()
        font_row2_layout = QHBoxLayout(font_row2)
        font_row2_layout.setContentsMargins(0, 0, 0, 0)
        font_row2_layout.setSpacing(2)
        
        self.bold_btn = QPushButton("B")
        self.bold_btn.setFixedSize(24, 24)
        self.bold_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                font-weight: bold;
                font-size: 11pt;
                color: #333333;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
            }
            QPushButton:checked {
                background-color: #d0d0d0;
                border: 1px solid #217346;
            }
        """)
        self.bold_btn.setCheckable(True)
        self.bold_btn.clicked.connect(self.quick_toggle_bold)
        font_row2_layout.addWidget(self.bold_btn)
        
        self.italic_btn = QPushButton("I")
        self.italic_btn.setFixedSize(24, 24)
        self.italic_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                font-style: italic;
                font-size: 11pt;
                color: #333333;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
            }
            QPushButton:checked {
                background-color: #d0d0d0;
                border: 1px solid #217346;
            }
        """)
        self.italic_btn.setCheckable(True)
        self.italic_btn.clicked.connect(self.quick_toggle_italic)
        font_row2_layout.addWidget(self.italic_btn)
        
        self.underline_btn = QPushButton("U")
        self.underline_btn.setFixedSize(24, 24)
        self.underline_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                text-decoration: underline;
                font-size: 11pt;
                color: #333333;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
            }
            QPushButton:checked {
                background-color: #d0d0d0;
                border: 1px solid #217346;
            }
        """)
        self.underline_btn.setCheckable(True)
        self.underline_btn.clicked.connect(self.quick_toggle_underline)
        font_row2_layout.addWidget(self.underline_btn)
        
        # Separador
        sep1 = QLabel("|")
        sep1.setStyleSheet("color: #c0c0c0; padding: 0 2px;")
        font_row2_layout.addWidget(sep1)
        
        # Bordes
        borders_btn = QPushButton("‚ñ¶")
        borders_btn.setFixedSize(24, 24)
        borders_btn.setToolTip("Bordes")
        borders_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                font-size: 12pt;
                color: #333333;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
            }
        """)
        borders_btn.clicked.connect(self.show_borders_menu)
        font_row2_layout.addWidget(borders_btn)
        
        # Color de relleno
        self.fill_color_btn = QPushButton("üé®")
        self.fill_color_btn.setFixedSize(24, 24)
        self.fill_color_btn.setToolTip("Color de relleno")
        self.fill_color_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
            }
        """)
        self.fill_color_btn.clicked.connect(self.change_cell_background)
        font_row2_layout.addWidget(self.fill_color_btn)
        
        # Color de texto
        self.text_color_btn = QPushButton("A")
        self.text_color_btn.setFixedSize(24, 24)
        self.text_color_btn.setToolTip("Color de fuente")
        self.text_color_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: 1px solid transparent;
                border-radius: 2px;
                font-size: 11pt;
                font-weight: bold;
                color: #c00000;
                border-bottom: 3px solid #c00000;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
                border: 1px solid #c0c0c0;
                border-bottom: 3px solid #c00000;
            }
        """)
        self.text_color_btn.clicked.connect(self.change_cell_text_color)
        font_row2_layout.addWidget(self.text_color_btn)
        
        font_widget_layout.addWidget(font_row2)
        font_layout.addWidget(font_widget)
        
        layout.addWidget(font_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO ALINEACI√ìN ===
        align_group, align_layout = self.create_ribbon_group("Alineaci√≥n")
        
        align_widget = QWidget()
        align_widget_layout = QVBoxLayout(align_widget)
        align_widget_layout.setContentsMargins(0, 0, 0, 0)
        align_widget_layout.setSpacing(3)
        
        # Fila 1: Alineaci√≥n vertical
        align_row1 = QWidget()
        align_row1_layout = QHBoxLayout(align_row1)
        align_row1_layout.setContentsMargins(0, 0, 0, 0)
        align_row1_layout.setSpacing(2)
        
        top_align = QPushButton("‚¨Ü")
        top_align.setFixedSize(24, 24)
        top_align.setToolTip("Alinear arriba")
        top_align.clicked.connect(lambda: self.set_vertical_alignment("top"))
        
        middle_align = QPushButton("‚¨å")
        middle_align.setFixedSize(24, 24)
        middle_align.setToolTip("Centrar verticalmente")
        middle_align.clicked.connect(lambda: self.set_vertical_alignment("middle"))
        
        bottom_align = QPushButton("‚¨á")
        bottom_align.setFixedSize(24, 24)
        bottom_align.setToolTip("Alinear abajo")
        bottom_align.clicked.connect(lambda: self.set_vertical_alignment("bottom"))
        
        for btn in [top_align, middle_align, bottom_align]:
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid transparent;
                    border-radius: 2px;
                    font-size: 10pt;
                    color: #333333;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                    border: 1px solid #c0c0c0;
                }
            """)
            align_row1_layout.addWidget(btn)
        
        align_widget_layout.addWidget(align_row1)
        
        # Fila 2: Alineaci√≥n horizontal
        align_row2 = QWidget()
        align_row2_layout = QHBoxLayout(align_row2)
        align_row2_layout.setContentsMargins(0, 0, 0, 0)
        align_row2_layout.setSpacing(2)
        
        left_align = QPushButton("‚â°")
        left_align.setFixedSize(24, 24)
        left_align.setToolTip("Alinear izquierda")
        left_align.clicked.connect(lambda: self.quick_align(Qt.AlignmentFlag.AlignLeft))
        
        center_align = QPushButton("‚â£")
        center_align.setFixedSize(24, 24)
        center_align.setToolTip("Centrar")
        center_align.clicked.connect(lambda: self.quick_align(Qt.AlignmentFlag.AlignHCenter))
        
        right_align = QPushButton("‚â°")
        right_align.setFixedSize(24, 24)
        right_align.setToolTip("Alinear derecha")
        right_align.clicked.connect(lambda: self.quick_align(Qt.AlignmentFlag.AlignRight))
        
        for btn in [left_align, center_align, right_align]:
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid transparent;
                    border-radius: 2px;
                    font-size: 12pt;
                    color: #333333;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                    border: 1px solid #c0c0c0;
                }
            """)
            align_row2_layout.addWidget(btn)
        
        align_widget_layout.addWidget(align_row2)
        
        # Bot√≥n combinar celdas
        merge_btn = self.create_ribbon_button("‚¨å", "Combinar y centrar")
        merge_btn.clicked.connect(self.merge_cells)
        align_widget_layout.addWidget(merge_btn)
        
        align_layout.addWidget(align_widget)
        
        layout.addWidget(align_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO N√öMERO ===
        number_group, number_layout = self.create_ribbon_group("N√∫mero")
        
        number_widget = QWidget()
        number_widget_layout = QVBoxLayout(number_widget)
        number_widget_layout.setContentsMargins(0, 0, 0, 0)
        number_widget_layout.setSpacing(3)
        
        # Selector de formato num√©rico
        self.number_format_combo = QComboBox()
        self.number_format_combo.addItems([
            "General", "N√∫mero", "Moneda", "Contabilidad", 
            "Fecha corta", "Fecha larga", "Hora", "Porcentaje",
            "Fracci√≥n", "Cient√≠fico", "Texto", "Personalizado..."
        ])
        self.number_format_combo.setFixedWidth(110)
        self.number_format_combo.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 2px;
                padding: 2px 5px;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #217346;
            }
        """)
        self.number_format_combo.currentTextChanged.connect(self.apply_number_format)
        number_widget_layout.addWidget(self.number_format_combo)
        
        # Botones de formato r√°pido
        number_buttons = QWidget()
        number_buttons_layout = QHBoxLayout(number_buttons)
        number_buttons_layout.setContentsMargins(0, 0, 0, 0)
        number_buttons_layout.setSpacing(2)
        
        currency_btn = QPushButton("$")
        currency_btn.setFixedSize(24, 24)
        currency_btn.setToolTip("Formato moneda")
        currency_btn.clicked.connect(self.format_as_currency)
        
        percent_btn = QPushButton("%")
        percent_btn.setFixedSize(24, 24)
        percent_btn.setToolTip("Formato porcentaje")
        percent_btn.clicked.connect(self.format_as_percentage)
        
        comma_btn = QPushButton(",")
        comma_btn.setFixedSize(24, 24)
        comma_btn.setToolTip("Separador de miles")
        comma_btn.clicked.connect(self.format_with_comma)
        
        dec_increase_btn = QPushButton(".0‚Üí")
        dec_increase_btn.setFixedSize(30, 24)
        dec_increase_btn.setToolTip("Aumentar decimales")
        dec_increase_btn.clicked.connect(self.increase_decimals)
        
        dec_decrease_btn = QPushButton("‚Üê.0")
        dec_decrease_btn.setFixedSize(30, 24)
        dec_decrease_btn.setToolTip("Disminuir decimales")
        dec_decrease_btn.clicked.connect(self.decrease_decimals)
        
        for btn in [currency_btn, percent_btn, comma_btn, dec_increase_btn, dec_decrease_btn]:
            btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    border: 1px solid transparent;
                    border-radius: 2px;
                    font-size: 10pt;
                    color: #333333;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                    border: 1px solid #c0c0c0;
                }
            """)
            number_buttons_layout.addWidget(btn)
        
        number_widget_layout.addWidget(number_buttons)
        number_layout.addWidget(number_widget)
        
        layout.addWidget(number_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO ESTILOS ===
        styles_group, styles_layout = self.create_ribbon_group("Estilos")
        
        cond_format_btn = self.create_ribbon_button("üéØ", "Formato\nCondicional", "Formato condicional", "large")
        cond_format_btn.clicked.connect(self.show_conditional_format)
        styles_layout.addWidget(cond_format_btn)
        
        table_styles_btn = self.create_ribbon_button("üìä", "Dar formato\ncomo tabla", "Estilos de tabla", "large")
        table_styles_btn.clicked.connect(self.create_table)
        styles_layout.addWidget(table_styles_btn)
        
        cell_styles_btn = self.create_ribbon_button("üé®", "Estilos\nde celda", "Estilos de celda", "large")
        cell_styles_btn.clicked.connect(self.show_cell_styles)
        styles_layout.addWidget(cell_styles_btn)
        
        layout.addWidget(styles_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO CELDAS ===
        cells_group, cells_layout = self.create_ribbon_group("Celdas")
        
        insert_btn = self.create_ribbon_button("‚ûï", "Insertar", "Insertar celdas", "large")
        insert_btn.clicked.connect(self.show_insert_menu)
        cells_layout.addWidget(insert_btn)
        
        delete_btn = self.create_ribbon_button("‚ùå", "Eliminar", "Eliminar celdas", "large")
        delete_btn.clicked.connect(self.show_delete_menu)
        cells_layout.addWidget(delete_btn)
        
        format_btn = self.create_ribbon_button("üìê", "Formato", "Formato de celdas", "large")
        format_btn.clicked.connect(self.show_format_cells_dialog)
        cells_layout.addWidget(format_btn)
        
        layout.addWidget(cells_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO EDICI√ìN ===
        edit_group, edit_layout = self.create_ribbon_group("Edici√≥n")
        
        edit_widget = QWidget()
        edit_widget_layout = QVBoxLayout(edit_widget)
        edit_widget_layout.setContentsMargins(0, 0, 0, 0)
        edit_widget_layout.setSpacing(2)
        
        sum_btn = self.create_ribbon_button("Œ£", "Autosuma")
        sum_btn.clicked.connect(self.insert_autosum)
        
        fill_btn = self.create_ribbon_button("‚Üì", "Rellenar")
        fill_btn.clicked.connect(self.autofill_down)
        
        clear_btn = self.create_ribbon_button("üóëÔ∏è", "Borrar")
        clear_btn.clicked.connect(self.clear_selected_cells)
        
        sort_btn = self.create_ribbon_button("üîΩ", "Ordenar y filtrar")
        sort_btn.clicked.connect(self.show_sort_filter_menu)
        
        find_btn = self.create_ribbon_button("üîç", "Buscar y seleccionar")
        find_btn.clicked.connect(self.show_search_dialog)
        
        edit_widget_layout.addWidget(sum_btn)
        edit_widget_layout.addWidget(fill_btn)
        edit_widget_layout.addWidget(clear_btn)
        edit_layout.addWidget(edit_widget)
        
        edit_widget2 = QWidget()
        edit_widget2_layout = QVBoxLayout(edit_widget2)
        edit_widget2_layout.setContentsMargins(0, 0, 0, 0)
        edit_widget2_layout.setSpacing(2)
        edit_widget2_layout.addWidget(sort_btn)
        edit_widget2_layout.addWidget(find_btn)
        edit_layout.addWidget(edit_widget2)
        
        layout.addWidget(edit_group)
        
        layout.addStretch()
        
        return tab
    
    def create_tab_insertar(self):
        """Crear pesta√±a Insertar del Ribbon"""
        tab = QWidget()
        tab.setStyleSheet("background-color: #ffffff;")
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)
        
        # === GRUPO TABLAS ===
        tables_group, tables_layout = self.create_ribbon_group("Tablas")
        
        pivot_btn = self.create_ribbon_button("üìä", "Tabla\ndin√°mica", "Crear tabla din√°mica", "large")
        tables_layout.addWidget(pivot_btn)
        
        table_btn = self.create_ribbon_button("üìã", "Tabla", "Insertar tabla", "large")
        table_btn.clicked.connect(self.create_table)
        tables_layout.addWidget(table_btn)
        
        layout.addWidget(tables_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO GR√ÅFICOS ===
        charts_group, charts_layout = self.create_ribbon_group("Gr√°ficos")
        
        bar_chart_btn = self.create_ribbon_button("üìä", "Columnas", "Gr√°fico de columnas", "large")
        bar_chart_btn.clicked.connect(lambda: self.insert_chart("columnas"))
        charts_layout.addWidget(bar_chart_btn)
        
        line_chart_btn = self.create_ribbon_button("üìà", "L√≠neas", "Gr√°fico de l√≠neas", "large")
        line_chart_btn.clicked.connect(lambda: self.insert_chart("lineas"))
        charts_layout.addWidget(line_chart_btn)
        
        pie_chart_btn = self.create_ribbon_button("ü•ß", "Circular", "Gr√°fico circular", "large")
        pie_chart_btn.clicked.connect(lambda: self.insert_chart("circular"))
        charts_layout.addWidget(pie_chart_btn)
        
        area_chart_btn = self.create_ribbon_button("üìâ", "√Årea", "Gr√°fico de √°rea", "large")
        area_chart_btn.clicked.connect(lambda: self.insert_chart("area"))
        charts_layout.addWidget(area_chart_btn)
        
        layout.addWidget(charts_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO ILUSTRACIONES ===
        illust_group, illust_layout = self.create_ribbon_group("Ilustraciones")
        
        image_btn = self.create_ribbon_button("üñºÔ∏è", "Imagen", "Insertar imagen", "large")
        illust_layout.addWidget(image_btn)
        
        shapes_btn = self.create_ribbon_button("‚¨°", "Formas", "Insertar formas", "large")
        illust_layout.addWidget(shapes_btn)
        
        layout.addWidget(illust_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO V√çNCULOS ===
        links_group, links_layout = self.create_ribbon_group("V√≠nculos")
        
        hyperlink_btn = self.create_ribbon_button("üîó", "Hiperv√≠nculo", "Insertar hiperv√≠nculo", "large")
        hyperlink_btn.clicked.connect(self.insert_hyperlink)
        links_layout.addWidget(hyperlink_btn)
        
        layout.addWidget(links_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO TEXTO ===
        text_group, text_layout = self.create_ribbon_group("Texto")
        
        textbox_btn = self.create_ribbon_button("üìù", "Cuadro\nde texto", "Insertar cuadro de texto", "large")
        text_layout.addWidget(textbox_btn)
        
        header_btn = self.create_ribbon_button("üìÑ", "Encabezado\ny pie", "Encabezado y pie de p√°gina", "large")
        text_layout.addWidget(header_btn)
        
        layout.addWidget(text_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO S√çMBOLOS ===
        symbols_group, symbols_layout = self.create_ribbon_group("S√≠mbolos")
        
        equation_btn = self.create_ribbon_button("‚àë", "Ecuaci√≥n", "Insertar ecuaci√≥n", "large")
        symbols_layout.addWidget(equation_btn)
        
        symbol_btn = self.create_ribbon_button("Œ©", "S√≠mbolo", "Insertar s√≠mbolo", "large")
        symbol_btn.clicked.connect(self.insert_symbol)
        symbols_layout.addWidget(symbol_btn)
        
        layout.addWidget(symbols_group)
        
        layout.addStretch()
        
        return tab
    
    def create_tab_formulas(self):
        """Crear pesta√±a F√≥rmulas del Ribbon"""
        tab = QWidget()
        tab.setStyleSheet("background-color: #ffffff;")
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)
        
        # === GRUPO BIBLIOTECA DE FUNCIONES ===
        func_group, func_layout = self.create_ribbon_group("Biblioteca de funciones")
        
        insert_func_btn = self.create_ribbon_button("fx", "Insertar\nfunci√≥n", "Insertar funci√≥n", "large")
        insert_func_btn.clicked.connect(self.show_function_wizard)
        func_layout.addWidget(insert_func_btn)
        
        func_buttons = QWidget()
        func_buttons_layout = QVBoxLayout(func_buttons)
        func_buttons_layout.setContentsMargins(0, 0, 0, 0)
        func_buttons_layout.setSpacing(2)
        
        autosum_btn = self.create_ribbon_button("Œ£", "Autosuma")
        autosum_btn.clicked.connect(self.insert_autosum)
        
        recent_btn = self.create_ribbon_button("üïê", "Usadas recientemente")
        
        financial_btn = self.create_ribbon_button("üí∞", "Financieras")
        financial_btn.clicked.connect(lambda: self.show_function_category("financieras"))
        
        func_buttons_layout.addWidget(autosum_btn)
        func_buttons_layout.addWidget(recent_btn)
        func_buttons_layout.addWidget(financial_btn)
        func_layout.addWidget(func_buttons)
        
        func_buttons2 = QWidget()
        func_buttons2_layout = QVBoxLayout(func_buttons2)
        func_buttons2_layout.setContentsMargins(0, 0, 0, 0)
        func_buttons2_layout.setSpacing(2)
        
        logical_btn = self.create_ribbon_button("üîÄ", "L√≥gicas")
        logical_btn.clicked.connect(lambda: self.show_function_category("logicas"))
        
        text_btn = self.create_ribbon_button("üìù", "Texto")
        text_btn.clicked.connect(lambda: self.show_function_category("texto"))
        
        datetime_btn = self.create_ribbon_button("üìÖ", "Fecha y hora")
        datetime_btn.clicked.connect(lambda: self.show_function_category("fecha"))
        
        func_buttons2_layout.addWidget(logical_btn)
        func_buttons2_layout.addWidget(text_btn)
        func_buttons2_layout.addWidget(datetime_btn)
        func_layout.addWidget(func_buttons2)
        
        func_buttons3 = QWidget()
        func_buttons3_layout = QVBoxLayout(func_buttons3)
        func_buttons3_layout.setContentsMargins(0, 0, 0, 0)
        func_buttons3_layout.setSpacing(2)
        
        lookup_btn = self.create_ribbon_button("üîç", "B√∫squeda y referencia")
        lookup_btn.clicked.connect(lambda: self.show_function_category("busqueda"))
        
        math_btn = self.create_ribbon_button("üî¢", "Matem√°ticas")
        math_btn.clicked.connect(lambda: self.show_function_category("matematicas"))
        
        more_btn = self.create_ribbon_button("üìö", "M√°s funciones")
        more_btn.clicked.connect(self.show_all_functions)
        
        func_buttons3_layout.addWidget(lookup_btn)
        func_buttons3_layout.addWidget(math_btn)
        func_buttons3_layout.addWidget(more_btn)
        func_layout.addWidget(func_buttons3)
        
        layout.addWidget(func_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO NOMBRES DEFINIDOS ===
        names_group, names_layout = self.create_ribbon_group("Nombres definidos")
        
        name_manager_btn = self.create_ribbon_button("üìã", "Administrador\nde nombres", "Administrar nombres", "large")
        names_layout.addWidget(name_manager_btn)
        
        define_name_btn = self.create_ribbon_button("‚ûï", "Definir nombre")
        names_layout.addWidget(define_name_btn)
        
        layout.addWidget(names_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO AUDITOR√çA DE F√ìRMULAS ===
        audit_group, audit_layout = self.create_ribbon_group("Auditor√≠a de f√≥rmulas")
        
        trace_prec_btn = self.create_ribbon_button("‚Üê‚óè", "Rastrear\nprecedentes", "", "large")
        audit_layout.addWidget(trace_prec_btn)
        
        trace_dep_btn = self.create_ribbon_button("‚óè‚Üí", "Rastrear\ndependientes", "", "large")
        audit_layout.addWidget(trace_dep_btn)
        
        audit_buttons = QWidget()
        audit_buttons_layout = QVBoxLayout(audit_buttons)
        audit_buttons_layout.setContentsMargins(0, 0, 0, 0)
        audit_buttons_layout.setSpacing(2)
        
        remove_arrows_btn = self.create_ribbon_button("‚úï", "Quitar flechas")
        show_formulas_btn = self.create_ribbon_button("fx", "Mostrar f√≥rmulas")
        show_formulas_btn.clicked.connect(self.toggle_show_formulas)
        error_check_btn = self.create_ribbon_button("‚úì", "Comprobaci√≥n de errores")
        
        audit_buttons_layout.addWidget(remove_arrows_btn)
        audit_buttons_layout.addWidget(show_formulas_btn)
        audit_buttons_layout.addWidget(error_check_btn)
        audit_layout.addWidget(audit_buttons)
        
        layout.addWidget(audit_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO C√ÅLCULO ===
        calc_group, calc_layout = self.create_ribbon_group("C√°lculo")
        
        calc_options_btn = self.create_ribbon_button("‚öôÔ∏è", "Opciones\nde c√°lculo", "", "large")
        calc_layout.addWidget(calc_options_btn)
        
        calc_now_btn = self.create_ribbon_button("üîÑ", "Calcular ahora")
        calc_now_btn.clicked.connect(self.recalculate_all)
        calc_layout.addWidget(calc_now_btn)
        
        layout.addWidget(calc_group)
        
        layout.addStretch()
        
        return tab
    
    def create_tab_datos(self):
        """Crear pesta√±a Datos del Ribbon"""
        tab = QWidget()
        tab.setStyleSheet("background-color: #ffffff;")
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)
        
        # === GRUPO OBTENER DATOS EXTERNOS ===
        external_group, external_layout = self.create_ribbon_group("Obtener datos externos")
        
        from_text_btn = self.create_ribbon_button("üìÑ", "Desde\ntexto/CSV", "Importar desde archivo de texto", "large")
        from_text_btn.clicked.connect(self.import_data)
        external_layout.addWidget(from_text_btn)
        
        from_web_btn = self.create_ribbon_button("üåê", "Desde\nWeb", "Importar desde Web", "large")
        external_layout.addWidget(from_web_btn)
        
        layout.addWidget(external_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO ORDENAR Y FILTRAR ===
        sort_group, sort_layout = self.create_ribbon_group("Ordenar y filtrar")
        
        sort_az_btn = self.create_ribbon_button("üîº", "Ordenar\nA-Z", "Ordenar ascendente", "large")
        sort_az_btn.clicked.connect(self.sort_ascending)
        sort_layout.addWidget(sort_az_btn)
        
        sort_za_btn = self.create_ribbon_button("üîΩ", "Ordenar\nZ-A", "Ordenar descendente", "large")
        sort_za_btn.clicked.connect(self.sort_descending)
        sort_layout.addWidget(sort_za_btn)
        
        sort_buttons = QWidget()
        sort_buttons_layout = QVBoxLayout(sort_buttons)
        sort_buttons_layout.setContentsMargins(0, 0, 0, 0)
        sort_buttons_layout.setSpacing(2)
        
        custom_sort_btn = self.create_ribbon_button("üìã", "Ordenar")
        custom_sort_btn.clicked.connect(self.show_custom_sort)
        
        filter_btn = self.create_ribbon_button("üîΩ", "Filtro")
        filter_btn.clicked.connect(self.toggle_filter)
        
        clear_btn = self.create_ribbon_button("‚úï", "Borrar")
        
        sort_buttons_layout.addWidget(custom_sort_btn)
        sort_buttons_layout.addWidget(filter_btn)
        sort_buttons_layout.addWidget(clear_btn)
        sort_layout.addWidget(sort_buttons)
        
        layout.addWidget(sort_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO HERRAMIENTAS DE DATOS ===
        tools_group, tools_layout = self.create_ribbon_group("Herramientas de datos")
        
        text_to_cols_btn = self.create_ribbon_button("üìä", "Texto en\ncolumnas", "", "large")
        text_to_cols_btn.clicked.connect(self.text_to_columns)
        tools_layout.addWidget(text_to_cols_btn)
        
        remove_dup_btn = self.create_ribbon_button("üóëÔ∏è", "Quitar\nduplicados", "", "large")
        remove_dup_btn.clicked.connect(self.remove_duplicates)
        tools_layout.addWidget(remove_dup_btn)
        
        validation_btn = self.create_ribbon_button("‚úì", "Validaci√≥n\nde datos", "", "large")
        validation_btn.clicked.connect(self.show_data_validation)
        tools_layout.addWidget(validation_btn)
        
        layout.addWidget(tools_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO EXPORTAR ===
        export_group, export_layout = self.create_ribbon_group("Exportar")
        
        export_csv_btn = self.create_ribbon_button("üíæ", "Exportar\na CSV", "Exportar a CSV", "large")
        export_csv_btn.clicked.connect(self.export_data)
        export_layout.addWidget(export_csv_btn)
        
        export_html_btn = self.create_ribbon_button("üåê", "Exportar\na HTML", "Exportar a HTML", "large")
        export_html_btn.clicked.connect(lambda: self.export_to_html_dialog())
        export_layout.addWidget(export_html_btn)
        
        layout.addWidget(export_group)
        
        layout.addStretch()
        
        return tab
    
    def create_tab_vista(self):
        """Crear pesta√±a Vista del Ribbon"""
        tab = QWidget()
        tab.setStyleSheet("background-color: #ffffff;")
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(3)
        
        # === GRUPO VISTAS DEL LIBRO ===
        views_group, views_layout = self.create_ribbon_group("Vistas del libro")
        
        normal_btn = self.create_ribbon_button("üìÑ", "Normal", "Vista normal", "large")
        views_layout.addWidget(normal_btn)
        
        page_layout_btn = self.create_ribbon_button("üìã", "Dise√±o de\np√°gina", "Vista dise√±o de p√°gina", "large")
        views_layout.addWidget(page_layout_btn)
        
        page_break_btn = self.create_ribbon_button("üìê", "Vista previa\nsalto de p√°gina", "", "large")
        views_layout.addWidget(page_break_btn)
        
        layout.addWidget(views_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO MOSTRAR ===
        show_group, show_layout = self.create_ribbon_group("Mostrar")
        
        show_widget = QWidget()
        show_widget_layout = QVBoxLayout(show_widget)
        show_widget_layout.setContentsMargins(0, 0, 0, 0)
        show_widget_layout.setSpacing(2)
        
        self.gridlines_check = QCheckBox("L√≠neas de cuadr√≠cula")
        self.gridlines_check.setChecked(True)
        self.gridlines_check.setStyleSheet("color: #333333; font-size: 9pt;")
        self.gridlines_check.stateChanged.connect(self.toggle_gridlines)
        
        self.headings_check = QCheckBox("Encabezados")
        self.headings_check.setChecked(True)
        self.headings_check.setStyleSheet("color: #333333; font-size: 9pt;")
        self.headings_check.stateChanged.connect(self.toggle_headings)
        
        self.formula_bar_check = QCheckBox("Barra de f√≥rmulas")
        self.formula_bar_check.setChecked(True)
        self.formula_bar_check.setStyleSheet("color: #333333; font-size: 9pt;")
        self.formula_bar_check.stateChanged.connect(self.toggle_formula_bar)
        
        show_widget_layout.addWidget(self.gridlines_check)
        show_widget_layout.addWidget(self.headings_check)
        show_widget_layout.addWidget(self.formula_bar_check)
        show_layout.addWidget(show_widget)
        
        layout.addWidget(show_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO ZOOM ===
        zoom_group, zoom_layout = self.create_ribbon_group("Zoom")
        
        zoom_btn = self.create_ribbon_button("üîç", "Zoom", "Configurar zoom", "large")
        zoom_btn.clicked.connect(self.show_zoom_dialog)
        zoom_layout.addWidget(zoom_btn)
        
        zoom_buttons = QWidget()
        zoom_buttons_layout = QVBoxLayout(zoom_buttons)
        zoom_buttons_layout.setContentsMargins(0, 0, 0, 0)
        zoom_buttons_layout.setSpacing(2)
        
        zoom_100_btn = self.create_ribbon_button("100%", "100%")
        zoom_100_btn.clicked.connect(lambda: self.set_zoom(100))
        
        zoom_selection_btn = self.create_ribbon_button("üîé", "Zoom a selecci√≥n")
        
        zoom_buttons_layout.addWidget(zoom_100_btn)
        zoom_buttons_layout.addWidget(zoom_selection_btn)
        zoom_layout.addWidget(zoom_buttons)
        
        layout.addWidget(zoom_group)
        layout.addWidget(self.create_ribbon_separator())
        
        # === GRUPO VENTANA ===
        window_group, window_layout = self.create_ribbon_group("Ventana")
        
        freeze_btn = self.create_ribbon_button("‚ùÑÔ∏è", "Inmovilizar\npaneles", "Inmovilizar paneles", "large")
        freeze_btn.clicked.connect(self.show_freeze_menu)
        window_layout.addWidget(freeze_btn)
        
        window_buttons = QWidget()
        window_buttons_layout = QVBoxLayout(window_buttons)
        window_buttons_layout.setContentsMargins(0, 0, 0, 0)
        window_buttons_layout.setSpacing(2)
        
        split_btn = self.create_ribbon_button("‚äû", "Dividir")
        split_btn.clicked.connect(self.toggle_split)
        
        hide_btn = self.create_ribbon_button("üëÅÔ∏è", "Ocultar")
        
        window_buttons_layout.addWidget(split_btn)
        window_buttons_layout.addWidget(hide_btn)
        window_layout.addWidget(window_buttons)
        
        layout.addWidget(window_group)
        
        layout.addStretch()
        
        return tab
    
    def create_formula_bar(self):
        """Crear barra de f√≥rmulas estilo Excel"""
        formula_bar = QWidget()
        formula_bar.setStyleSheet("""
            QWidget {
                background-color: #ffffff;
                border-bottom: 1px solid #d4d4d4;
            }
        """)
        formula_bar.setFixedHeight(28)
        
        layout = QHBoxLayout(formula_bar)
        layout.setContentsMargins(0, 0, 5, 0)
        layout.setSpacing(0)
        
        # Cuadro de nombre de celda
        self.cell_name_box = QLineEdit()
        self.cell_name_box.setFixedWidth(80)
        self.cell_name_box.setText("A1")
        self.cell_name_box.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cell_name_box.setStyleSheet("""
            QLineEdit {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-right: none;
                padding: 4px 8px;
                font-size: 10pt;
                font-weight: 500;
            }
            QLineEdit:focus {
                border: 1px solid #217346;
            }
        """)
        self.cell_name_box.returnPressed.connect(self.go_to_cell)
        layout.addWidget(self.cell_name_box)
        
        # Botones de f√≥rmula
        fx_btn = QPushButton("fx")
        fx_btn.setFixedSize(30, 26)
        fx_btn.setStyleSheet("""
            QPushButton {
                background-color: #f3f3f3;
                border: 1px solid #c0c0c0;
                font-size: 10pt;
                font-style: italic;
                color: #333333;
            }
            QPushButton:hover {
                background-color: #e5e5e5;
            }
        """)
        fx_btn.clicked.connect(self.show_function_wizard)
        layout.addWidget(fx_btn)
        
        # Barra de edici√≥n de f√≥rmulas
        self.formula_bar_edit = QLineEdit()
        self.formula_bar_edit.setPlaceholderText("")
        self.formula_bar_edit.setStyleSheet("""
            QLineEdit {
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-left: none;
                padding: 4px 8px;
                font-size: 11pt;
                font-family: 'Calibri', 'Segoe UI', sans-serif;
            }
            QLineEdit:focus {
                border: 1px solid #217346;
            }
        """)
        self.formula_bar_edit.returnPressed.connect(self.apply_formula)
        self.formula_bar_edit.textChanged.connect(self.on_formula_text_changed)
        
        # Alias para compatibilidad
        self.formula_bar = self.formula_bar_edit
        
        # Autocompletado de funciones
        self.setup_autocomplete()
        
        layout.addWidget(self.formula_bar_edit, 1)
        
        return formula_bar
    
    def create_bottom_panel(self):
        """Crear panel inferior con pesta√±as de hojas estilo Excel"""
        bottom_panel = QWidget()
        bottom_panel.setFixedHeight(55)
        bottom_panel.setStyleSheet("""
            QWidget {
                background-color: #e9ecef;
                border-top: 1px solid #c0c0c0;
            }
        """)
        
        layout = QVBoxLayout(bottom_panel)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Fila de pesta√±as de hojas
        sheets_row = QWidget()
        sheets_row.setStyleSheet("background-color: #e9ecef;")
        sheets_layout = QHBoxLayout(sheets_row)
        sheets_layout.setContentsMargins(5, 3, 5, 0)
        sheets_layout.setSpacing(3)
        
        # Botones de navegaci√≥n de hojas
        nav_left_btn = QPushButton("‚óÄ")
        nav_left_btn.setFixedSize(22, 20)
        nav_left_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #666666;
                font-size: 8pt;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
            }
        """)
        sheets_layout.addWidget(nav_left_btn)
        
        nav_right_btn = QPushButton("‚ñ∂")
        nav_right_btn.setFixedSize(22, 20)
        nav_right_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #666666;
                font-size: 8pt;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
            }
        """)
        sheets_layout.addWidget(nav_right_btn)
        
        # Bot√≥n agregar hoja
        add_sheet_btn = QPushButton("‚ûï")
        add_sheet_btn.setFixedSize(22, 20)
        add_sheet_btn.setToolTip("Nueva hoja")
        add_sheet_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #666666;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #d0d0d0;
            }
        """)
        add_sheet_btn.clicked.connect(self.add_new_sheet)
        sheets_layout.addWidget(add_sheet_btn)
        
        # Contenedor de pesta√±as de hojas
        self.sheets_tabs_container = QWidget()
        self.sheets_tabs_layout = QHBoxLayout(self.sheets_tabs_container)
        self.sheets_tabs_layout.setContentsMargins(5, 0, 5, 0)
        self.sheets_tabs_layout.setSpacing(0)
        
        # Crear pesta√±a para Hoja1
        self.create_sheet_tab("Hoja1", active=True)
        
        sheets_layout.addWidget(self.sheets_tabs_container)
        sheets_layout.addStretch()
        
        layout.addWidget(sheets_row)
        
        # Barra de estado
        status_bar = self.create_excel_status_bar()
        layout.addWidget(status_bar)
        
        return bottom_panel
    
    def create_sheet_tab(self, name, active=False):
        """Crear pesta√±a individual de hoja"""
        tab_btn = QPushButton(name)
        tab_btn.setFixedHeight(22)
        tab_btn.setMinimumWidth(80)
        
        if active:
            tab_btn.setStyleSheet("""
                QPushButton {
                    background-color: #ffffff;
                    border: 1px solid #c0c0c0;
                    border-bottom: none;
                    border-top-left-radius: 3px;
                    border-top-right-radius: 3px;
                    padding: 3px 12px;
                    font-size: 9pt;
                    color: #000000;
                }
            """)
        else:
            tab_btn.setStyleSheet("""
                QPushButton {
                    background-color: #d5d8dc;
                    border: 1px solid #c0c0c0;
                    border-bottom: none;
                    border-top-left-radius: 3px;
                    border-top-right-radius: 3px;
                    padding: 3px 12px;
                    font-size: 9pt;
                    color: #333333;
                }
                QPushButton:hover {
                    background-color: #e5e5e5;
                }
            """)
        
        tab_btn.clicked.connect(lambda checked, n=name: self.switch_to_sheet(n))
        tab_btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        tab_btn.customContextMenuRequested.connect(lambda pos, n=name: self.show_sheet_context_menu(n, pos))
        
        self.sheets_tabs_layout.addWidget(tab_btn)
        return tab_btn
    
    def create_excel_status_bar(self):
        """Crear barra de estado estilo Excel"""
        status_bar = QWidget()
        status_bar.setFixedHeight(24)
        status_bar.setStyleSheet("""
            QWidget {
                background-color: #217346;
            }
        """)
        
        layout = QHBoxLayout(status_bar)
        layout.setContentsMargins(10, 0, 10, 0)
        layout.setSpacing(20)
        
        # Estado a la izquierda
        self.ready_label = QLabel("Listo")
        self.ready_label.setStyleSheet("color: #ffffff; font-size: 9pt;")
        layout.addWidget(self.ready_label)
        
        layout.addStretch()
        
        # Estad√≠sticas de selecci√≥n
        self.stats_label = QLabel("")
        self.stats_label.setStyleSheet("color: #ffffff; font-size: 9pt;")
        layout.addWidget(self.stats_label)
        
        # Separador
        sep = QLabel("|")
        sep.setStyleSheet("color: #4a9e6d;")
        layout.addWidget(sep)
        
        # Promedio
        self.avg_label = QLabel("Promedio: -")
        self.avg_label.setStyleSheet("color: #ffffff; font-size: 9pt;")
        layout.addWidget(self.avg_label)
        
        # Cuenta
        self.count_label = QLabel("Recuento: -")
        self.count_label.setStyleSheet("color: #ffffff; font-size: 9pt;")
        layout.addWidget(self.count_label)
        
        # Suma
        self.sum_label = QLabel("Suma: -")
        self.sum_label.setStyleSheet("color: #ffffff; font-size: 9pt;")
        layout.addWidget(self.sum_label)
        
        layout.addStretch()
        
        # Zoom a la derecha
        zoom_layout = QHBoxLayout()
        zoom_layout.setSpacing(5)
        
        zoom_out_btn = QPushButton("-")
        zoom_out_btn.setFixedSize(20, 18)
        zoom_out_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        zoom_out_btn.clicked.connect(self.zoom_out)
        zoom_layout.addWidget(zoom_out_btn)
        
        from PyQt6.QtWidgets import QSlider
        self.zoom_slider = QSlider(Qt.Orientation.Horizontal)
        self.zoom_slider.setFixedWidth(100)
        self.zoom_slider.setMinimum(10)
        self.zoom_slider.setMaximum(400)
        self.zoom_slider.setValue(100)
        self.zoom_slider.setStyleSheet("""
            QSlider::groove:horizontal {
                background: #4a9e6d;
                height: 4px;
                border-radius: 2px;
            }
            QSlider::handle:horizontal {
                background: #ffffff;
                width: 12px;
                height: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }
        """)
        self.zoom_slider.valueChanged.connect(self.on_zoom_changed)
        zoom_layout.addWidget(self.zoom_slider)
        
        zoom_in_btn = QPushButton("+")
        zoom_in_btn.setFixedSize(20, 18)
        zoom_in_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
                color: #ffffff;
                font-size: 12pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        zoom_in_btn.clicked.connect(self.zoom_in)
        zoom_layout.addWidget(zoom_in_btn)
        
        self.zoom_percent_label = QLabel("100%")
        self.zoom_percent_label.setStyleSheet("color: #ffffff; font-size: 9pt; min-width: 35px;")
        zoom_layout.addWidget(self.zoom_percent_label)
        
        layout.addLayout(zoom_layout)
        
        return status_bar
    
    # ===== FUNCIONES DE SOPORTE PARA RIBBON Y NUEVAS CARACTER√çSTICAS =====
    
    def on_selection_changed(self):
        """Manejar cambio de selecci√≥n para actualizar estad√≠sticas"""
        self.update_selection_stats()
    
    def update_selection_stats(self):
        """Actualizar estad√≠sticas de la selecci√≥n en la barra de estado"""
        ranges = self.table.selectedRanges()
        if not ranges:
            self.avg_label.setText("Promedio: -")
            self.count_label.setText("Recuento: -")
            self.sum_label.setText("Suma: -")
            return
        
        values = []
        count = 0
        
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        count += 1
                        try:
                            val = float(item.text().replace('$', '').replace(',', '').replace('%', ''))
                            values.append(val)
                        except:
                            pass
        
        if values:
            avg = sum(values) / len(values)
            total = sum(values)
            self.avg_label.setText(f"Promedio: {avg:,.2f}")
            self.sum_label.setText(f"Suma: {total:,.2f}")
        else:
            self.avg_label.setText("Promedio: -")
            self.sum_label.setText("Suma: -")
        
        self.count_label.setText(f"Recuento: {count}")
    
    def change_font_family(self, font_name):
        """Cambiar familia de fuente de las celdas seleccionadas"""
        self.current_font_family = font_name
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item:
                        font = item.font()
                        font.setFamily(font_name)
                        item.setFont(font)
                    else:
                        item = QTableWidgetItem()
                        font = item.font()
                        font.setFamily(font_name)
                        item.setFont(font)
                        self.table.setItem(row, col, item)
    
    def change_font_size(self, size_str):
        """Cambiar tama√±o de fuente de las celdas seleccionadas"""
        try:
            size = int(size_str)
            self.current_font_size = size
            ranges = self.table.selectedRanges()
            for r in ranges:
                for row in range(r.topRow(), r.bottomRow() + 1):
                    for col in range(r.leftColumn(), r.rightColumn() + 1):
                        item = self.table.item(row, col)
                        if item:
                            font = item.font()
                            font.setPointSize(size)
                            item.setFont(font)
        except:
            pass
    
    def set_vertical_alignment(self, alignment):
        """Establecer alineaci√≥n vertical"""
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item:
                        current = item.textAlignment()
                        if alignment == "top":
                            item.setTextAlignment(Qt.AlignmentFlag.AlignTop | (current & Qt.AlignmentFlag.AlignHorizontal_Mask))
                        elif alignment == "middle":
                            item.setTextAlignment(Qt.AlignmentFlag.AlignVCenter | (current & Qt.AlignmentFlag.AlignHorizontal_Mask))
                        elif alignment == "bottom":
                            item.setTextAlignment(Qt.AlignmentFlag.AlignBottom | (current & Qt.AlignmentFlag.AlignHorizontal_Mask))
    
    def apply_number_format(self, format_name):
        """Aplicar formato num√©rico a las celdas seleccionadas"""
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        try:
                            value = float(item.text().replace('$', '').replace(',', '').replace('%', ''))
                            cell_ref = f"{self.current_sheet}:{self.get_cell_reference(row, col)}"
                            
                            if format_name == "N√∫mero":
                                item.setText(f"{value:,.2f}")
                                self.number_formats[cell_ref] = "number"
                            elif format_name == "Moneda":
                                item.setText(f"${value:,.2f}")
                                self.number_formats[cell_ref] = "currency"
                            elif format_name == "Contabilidad":
                                item.setText(f"$ {value:>12,.2f}")
                                self.number_formats[cell_ref] = "accounting"
                            elif format_name == "Porcentaje":
                                item.setText(f"{value * 100:.2f}%")
                                self.number_formats[cell_ref] = "percentage"
                            elif format_name == "Cient√≠fico":
                                item.setText(f"{value:.2E}")
                                self.number_formats[cell_ref] = "scientific"
                            elif format_name == "Fecha corta":
                                from datetime import datetime, timedelta
                                base_date = datetime(1900, 1, 1)
                                date = base_date + timedelta(days=int(value) - 2)
                                item.setText(date.strftime("%d/%m/%Y"))
                                self.number_formats[cell_ref] = "date_short"
                            elif format_name == "Fecha larga":
                                from datetime import datetime, timedelta
                                base_date = datetime(1900, 1, 1)
                                date = base_date + timedelta(days=int(value) - 2)
                                item.setText(date.strftime("%A, %d de %B de %Y"))
                                self.number_formats[cell_ref] = "date_long"
                            elif format_name == "Fracci√≥n":
                                from fractions import Fraction
                                frac = Fraction(value).limit_denominator(100)
                                item.setText(str(frac))
                                self.number_formats[cell_ref] = "fraction"
                            elif format_name == "General":
                                if value == int(value):
                                    item.setText(str(int(value)))
                                else:
                                    item.setText(str(value))
                                self.number_formats[cell_ref] = "general"
                        except:
                            pass
    
    def format_with_comma(self):
        """Formatear n√∫meros con separador de miles"""
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        try:
                            value = float(item.text().replace('$', '').replace(',', '').replace('%', ''))
                            item.setText(f"{value:,.0f}")
                        except:
                            pass
    
    def decrease_decimals(self):
        """Disminuir decimales"""
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        try:
                            text = item.text().replace('$', '').replace(',', '').replace('%', '')
                            value = float(text)
                            # Contar decimales actuales
                            if '.' in item.text():
                                current_decimals = len(item.text().split('.')[-1].rstrip('%'))
                                new_decimals = max(0, current_decimals - 1)
                                item.setText(f"{value:.{new_decimals}f}")
                            else:
                                item.setText(f"{int(value)}")
                        except:
                            pass
    
    def show_cell_styles(self):
        """Mostrar galer√≠a de estilos de celda"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QGridLayout, QLabel, QPushButton, QScrollArea
        from PyQt6.QtGui import QColor, QBrush, QFont
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Estilos de celda")
        dialog.setMinimumSize(500, 400)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        title = QLabel("Selecciona un estilo de celda:")
        title.setStyleSheet("font-size: 12pt; font-weight: bold; padding: 10px; color: #333333;")
        layout.addWidget(title)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_widget = QWidget()
        grid = QGridLayout(scroll_widget)
        grid.setSpacing(10)
        
        styles = [
            ("Normal", "#ffffff", "#000000", False),
            ("Bueno", "#c6efce", "#006100", False),
            ("Malo", "#ffc7ce", "#9c0006", False),
            ("Neutro", "#ffeb9c", "#9c5700", False),
            ("Entrada", "#ffcc99", "#3f3f76", False),
            ("Salida", "#f2f2f2", "#3f3f3f", True),
            ("C√°lculo", "#f2f2f2", "#fa7d00", True),
            ("Celda de comprobaci√≥n", "#a5a5a5", "#ffffff", True),
            ("Celda vinculada", "#ffcc99", "#fa7d00", False),
            ("T√≠tulo 1", "#4472c4", "#ffffff", True),
            ("T√≠tulo 2", "#5b9bd5", "#ffffff", True),
            ("T√≠tulo 3", "#9dc3e6", "#1f4e79", True),
            ("T√≠tulo 4", "#bdd7ee", "#1f4e79", False),
            ("√ânfasis 1", "#4472c4", "#ffffff", True),
            ("√ânfasis 2", "#ed7d31", "#ffffff", True),
            ("√ânfasis 3", "#a5a5a5", "#ffffff", True),
            ("20% - √ânfasis 1", "#d6dce4", "#4472c4", False),
            ("40% - √ânfasis 1", "#acb9ca", "#4472c4", False),
            ("Advertencia", "#ff0000", "#ffffff", True),
            ("Nota", "#ffff00", "#000000", False),
        ]
        
        row = 0
        col = 0
        for name, bg_color, text_color, bold in styles:
            btn = QPushButton(name)
            btn.setFixedSize(110, 40)
            font_weight = "bold" if bold else "normal"
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {bg_color};
                    color: {text_color};
                    border: 1px solid #c0c0c0;
                    font-weight: {font_weight};
                    font-size: 9pt;
                }}
                QPushButton:hover {{
                    border: 2px solid #217346;
                }}
            """)
            btn.clicked.connect(lambda checked, n=name, bg=bg_color, tc=text_color, b=bold: 
                               self.apply_cell_style(bg, tc, b, dialog))
            grid.addWidget(btn, row, col)
            col += 1
            if col >= 4:
                col = 0
                row += 1
        
        scroll.setWidget(scroll_widget)
        layout.addWidget(scroll)
        
        dialog.exec()
    
    def apply_cell_style(self, bg_color, text_color, bold, dialog):
        """Aplicar estilo de celda"""
        from PyQt6.QtGui import QColor, QBrush, QFont
        
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(row, col, item)
                    
                    item.setBackground(QBrush(QColor(bg_color)))
                    item.setForeground(QBrush(QColor(text_color)))
                    font = item.font()
                    font.setBold(bold)
                    item.setFont(font)
        
        dialog.close()
    
    def show_insert_menu(self):
        """Mostrar men√∫ de inserci√≥n"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
        """)
        
        menu.addAction("Insertar celdas...").triggered.connect(self.insert_cells_dialog)
        menu.addSeparator()
        menu.addAction("Insertar fila de hoja").triggered.connect(self.insert_row)
        menu.addAction("Insertar columna de hoja").triggered.connect(self.insert_column)
        menu.addSeparator()
        menu.addAction("Insertar hoja").triggered.connect(self.add_new_sheet)
        
        menu.exec(self.mapToGlobal(self.sender().rect().bottomLeft()))
    
    def show_delete_menu(self):
        """Mostrar men√∫ de eliminaci√≥n"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
        """)
        
        menu.addAction("Eliminar celdas...").triggered.connect(self.delete_cells_dialog)
        menu.addSeparator()
        menu.addAction("Eliminar fila de hoja").triggered.connect(self.delete_row)
        menu.addAction("Eliminar columna de hoja").triggered.connect(self.delete_column)
        menu.addSeparator()
        menu.addAction("Eliminar hoja").triggered.connect(self.delete_current_sheet)
        
        menu.exec(self.mapToGlobal(self.sender().rect().bottomLeft()))
    
    def insert_cells_dialog(self):
        """Di√°logo para insertar celdas"""
        QMessageBox.information(self, "Insertar celdas", "Usa Ctrl+Shift++ para insertar celdas r√°pidamente")
    
    def delete_cells_dialog(self):
        """Di√°logo para eliminar celdas"""
        QMessageBox.information(self, "Eliminar celdas", "Usa Ctrl+- para eliminar celdas r√°pidamente")
    
    def insert_autosum(self):
        """Insertar funci√≥n SUMA autom√°ticamente"""
        current_row = self.table.currentRow()
        current_col = self.table.currentColumn()
        
        if current_row < 0 or current_col < 0:
            return
        
        # Buscar rango de n√∫meros arriba
        start_row = current_row - 1
        while start_row >= 0:
            item = self.table.item(start_row, current_col)
            if not item or not item.text():
                break
            try:
                float(item.text().replace('$', '').replace(',', ''))
                start_row -= 1
            except:
                break
        start_row += 1
        
        if start_row < current_row:
            col_letter = chr(65 + current_col) if current_col < 26 else 'A' + chr(65 + current_col - 26)
            formula = f"=SUMA({col_letter}{start_row + 1}:{col_letter}{current_row})"
            
            item = self.table.item(current_row, current_col)
            if not item:
                item = QTableWidgetItem()
                self.table.setItem(current_row, current_col, item)
            item.setText(formula)
    
    def show_sort_filter_menu(self):
        """Mostrar men√∫ de ordenar y filtrar"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
        """)
        
        menu.addAction("üîº Ordenar A a Z").triggered.connect(self.sort_ascending)
        menu.addAction("üîΩ Ordenar Z a A").triggered.connect(self.sort_descending)
        menu.addSeparator()
        menu.addAction("üìã Ordenar personalizado...").triggered.connect(self.show_custom_sort)
        menu.addSeparator()
        menu.addAction("üîΩ Filtro").triggered.connect(self.toggle_filter)
        menu.addAction("‚úï Borrar filtro")
        
        menu.exec(self.mapToGlobal(self.sender().rect().bottomLeft()))
    
    def show_custom_sort(self):
        """Mostrar di√°logo de ordenaci√≥n personalizada"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDialogButtonBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Ordenar")
        dialog.setMinimumWidth(400)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        # Columna
        col_layout = QHBoxLayout()
        col_layout.addWidget(QLabel("Ordenar por:"))
        col_combo = QComboBox()
        col_combo.addItems([chr(65 + i) for i in range(26)])
        col_combo.setCurrentIndex(self.table.currentColumn() if self.table.currentColumn() >= 0 else 0)
        col_layout.addWidget(col_combo)
        layout.addLayout(col_layout)
        
        # Orden
        order_layout = QHBoxLayout()
        order_layout.addWidget(QLabel("Orden:"))
        order_combo = QComboBox()
        order_combo.addItems(["A a Z (ascendente)", "Z a A (descendente)"])
        order_layout.addWidget(order_combo)
        layout.addLayout(order_layout)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            col = col_combo.currentIndex()
            if order_combo.currentIndex() == 0:
                self.table.sortItems(col, Qt.SortOrder.AscendingOrder)
            else:
                self.table.sortItems(col, Qt.SortOrder.DescendingOrder)
    
    def insert_chart(self, chart_type):
        """Insertar gr√°fico del tipo especificado"""
        self.create_chart()
    
    def insert_hyperlink(self):
        """Insertar hiperv√≠nculo en celda"""
        from PyQt6.QtWidgets import QInputDialog
        
        current = self.table.currentItem()
        if not current:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona una celda primero")
            return
        
        url, ok = QInputDialog.getText(self, "Insertar hiperv√≠nculo", "URL:")
        if ok and url:
            from PyQt6.QtGui import QBrush, QColor
            current.setText(url)
            current.setForeground(QBrush(QColor("#0563c1")))
            font = current.font()
            font.setUnderline(True)
            current.setFont(font)
            current.setToolTip(f"Enlace: {url}")
    
    def insert_symbol(self):
        """Insertar s√≠mbolo especial"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QGridLayout, QPushButton
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Insertar s√≠mbolo")
        dialog.setMinimumSize(400, 300)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        symbols = [
            "¬©", "¬Æ", "‚Ñ¢", "‚Ç¨", "¬£", "¬•", "¬¢", "¬ß", "¬∂", "‚Ä†",
            "‚Ä°", "‚Ä¢", "¬∞", "¬±", "√ó", "√∑", "‚â†", "‚â§", "‚â•", "‚âà",
            "‚àû", "œÄ", "Œ£", "‚àö", "‚à´", "Œî", "Œ©", "Œ±", "Œ≤", "Œ≥",
            "‚Üí", "‚Üê", "‚Üë", "‚Üì", "‚Üî", "‚ô†", "‚ô£", "‚ô•", "‚ô¶", "‚òÖ",
            "‚òÜ", "‚òé", "‚úì", "‚úó", "‚ù§", "‚ô™", "‚ô´", "‚òÄ", "‚òÅ", "‚òÇ"
        ]
        
        grid = QGridLayout()
        row = col = 0
        for symbol in symbols:
            btn = QPushButton(symbol)
            btn.setFixedSize(40, 40)
            btn.setStyleSheet("""
                QPushButton {
                    font-size: 16pt;
                    background-color: #ffffff;
                    border: 1px solid #c0c0c0;
                }
                QPushButton:hover {
                    background-color: #e5f3ff;
                    border: 1px solid #217346;
                }
            """)
            btn.clicked.connect(lambda checked, s=symbol: self.insert_symbol_to_cell(s, dialog))
            grid.addWidget(btn, row, col)
            col += 1
            if col >= 10:
                col = 0
                row += 1
        
        layout.addLayout(grid)
        dialog.exec()
    
    def insert_symbol_to_cell(self, symbol, dialog):
        """Insertar s√≠mbolo en la celda actual"""
        current = self.table.currentItem()
        if current:
            current.setText(current.text() + symbol)
        else:
            row = self.table.currentRow()
            col = self.table.currentColumn()
            if row >= 0 and col >= 0:
                item = QTableWidgetItem(symbol)
                self.table.setItem(row, col, item)
        dialog.close()
    
    def show_function_wizard(self):
        """Mostrar asistente de funciones"""
        self.show_all_functions()
    
    def show_function_category(self, category):
        """Mostrar funciones de una categor√≠a espec√≠fica"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QListWidget, QLabel, QDialogButtonBox
        
        categories = {
            "financieras": ["VA", "VF", "PAGO", "TASA", "NPER", "TIR", "VNA"],
            "logicas": ["SI", "Y", "O", "NO", "SI.ERROR", "VERDADERO", "FALSO"],
            "texto": ["CONCATENAR", "IZQUIERDA", "DERECHA", "EXTRAE", "LARGO", "MAYUSC", "MINUSC", "ESPACIOS", "TEXTO"],
            "fecha": ["HOY", "AHORA", "A√ëO", "MES", "DIA", "HORA", "MINUTO", "SEGUNDO", "FECHA"],
            "busqueda": ["BUSCARV", "BUSCARH", "INDICE", "COINCIDIR", "DIRECCION", "INDIRECTO"],
            "matematicas": ["SUMA", "PROMEDIO", "MAX", "MIN", "CONTAR", "REDONDEAR", "POTENCIA", "RAIZ", "ABS", "PI", "ALEATORIO"]
        }
        
        funcs = categories.get(category, [])
        
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Funciones - {category.capitalize()}")
        dialog.setMinimumSize(300, 400)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        label = QLabel(f"Funciones {category}:")
        label.setStyleSheet("font-weight: bold; font-size: 11pt; padding: 10px; color: #333333;")
        layout.addWidget(label)
        
        list_widget = QListWidget()
        list_widget.setStyleSheet("""
            QListWidget {
                border: 1px solid #c0c0c0;
                font-size: 10pt;
            }
            QListWidget::item {
                padding: 8px;
            }
            QListWidget::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
        """)
        for func in funcs:
            list_widget.addItem(func)
        layout.addWidget(list_widget)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected = list_widget.selectedItems()
            if selected:
                func_name = selected[0].text()
                current = self.table.currentItem()
                if current:
                    current.setText(f"={func_name}()")
                else:
                    row = self.table.currentRow()
                    col = self.table.currentColumn()
                    if row >= 0 and col >= 0:
                        item = QTableWidgetItem(f"={func_name}()")
                        self.table.setItem(row, col, item)
    
    def show_all_functions(self):
        """Mostrar todas las funciones disponibles"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QLabel, QTextEdit, QDialogButtonBox, QLineEdit
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Insertar funci√≥n")
        dialog.setMinimumSize(600, 450)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        # B√∫squeda
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Buscar:"))
        search_input = QLineEdit()
        search_input.setPlaceholderText("Escribe para buscar una funci√≥n...")
        search_layout.addWidget(search_input)
        layout.addLayout(search_layout)
        
        content_layout = QHBoxLayout()
        
        # Lista de funciones
        func_list = QListWidget()
        func_list.setFixedWidth(200)
        
        all_functions = [
            ("SUMA", "Suma los valores de un rango"),
            ("PROMEDIO", "Calcula el promedio de un rango"),
            ("MAX", "Devuelve el valor m√°ximo"),
            ("MIN", "Devuelve el valor m√≠nimo"),
            ("CONTAR", "Cuenta celdas con n√∫meros"),
            ("CONTAR.SI", "Cuenta celdas que cumplen una condici√≥n"),
            ("SUMA.SI", "Suma celdas que cumplen una condici√≥n"),
            ("SI", "Eval√∫a una condici√≥n"),
            ("BUSCARV", "B√∫squeda vertical"),
            ("BUSCARH", "B√∫squeda horizontal"),
            ("CONCATENAR", "Une textos"),
            ("IZQUIERDA", "Extrae caracteres de la izquierda"),
            ("DERECHA", "Extrae caracteres de la derecha"),
            ("LARGO", "Cuenta caracteres"),
            ("HOY", "Devuelve la fecha actual"),
            ("AHORA", "Devuelve fecha y hora actual"),
            ("REDONDEAR", "Redondea un n√∫mero"),
            ("ABS", "Valor absoluto"),
            ("RAIZ", "Ra√≠z cuadrada"),
            ("POTENCIA", "Eleva a una potencia"),
            ("MEDIANA", "Calcula la mediana"),
            ("MODA", "Calcula la moda"),
            ("VARIANZA", "Calcula la varianza"),
            ("DESVEST", "Desviaci√≥n est√°ndar"),
            ("Y", "AND l√≥gico"),
            ("O", "OR l√≥gico"),
            ("NO", "NOT l√≥gico"),
        ]
        
        for func_name, _ in all_functions:
            func_list.addItem(func_name)
        
        content_layout.addWidget(func_list)
        
        # Descripci√≥n
        desc_widget = QWidget()
        desc_layout = QVBoxLayout(desc_widget)
        
        desc_title = QLabel("Descripci√≥n:")
        desc_title.setStyleSheet("font-weight: bold; color: #333333;")
        desc_layout.addWidget(desc_title)
        
        desc_text = QTextEdit()
        desc_text.setReadOnly(True)
        desc_text.setStyleSheet("border: 1px solid #c0c0c0; background-color: #f9f9f9;")
        desc_layout.addWidget(desc_text)
        
        content_layout.addWidget(desc_widget)
        layout.addLayout(content_layout)
        
        # Actualizar descripci√≥n al seleccionar
        def update_description():
            selected = func_list.selectedItems()
            if selected:
                func_name = selected[0].text()
                for name, desc in all_functions:
                    if name == func_name:
                        desc_text.setText(f"<b>{name}</b><br><br>{desc}<br><br><b>Sintaxis:</b> ={name}(argumentos)")
                        break
        
        func_list.itemSelectionChanged.connect(update_description)
        
        # Filtrar funciones
        def filter_functions():
            search_text = search_input.text().upper()
            for i in range(func_list.count()):
                item = func_list.item(i)
                item.setHidden(search_text not in item.text())
        
        search_input.textChanged.connect(filter_functions)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected = func_list.selectedItems()
            if selected:
                func_name = selected[0].text()
                row = self.table.currentRow()
                col = self.table.currentColumn()
                if row >= 0 and col >= 0:
                    item = self.table.item(row, col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(row, col, item)
                    item.setText(f"={func_name}()")
                    self.table.setCurrentCell(row, col)
                    self.table.editItem(item)
    
    def toggle_show_formulas(self):
        """Alternar mostrar f√≥rmulas en lugar de valores"""
        # Implementaci√≥n simplificada
        QMessageBox.information(self, "Mostrar f√≥rmulas", 
                               "Presiona Ctrl+` para alternar entre mostrar f√≥rmulas y valores")
    
    def recalculate_all(self):
        """Recalcular todas las f√≥rmulas"""
        for key, formula in self.formulas.items():
            parts = key.split(":")
            if len(parts) == 2 and parts[0] == self.current_sheet:
                cell_ref = parts[1]
                row, col = self.parse_cell_reference(cell_ref)
                if row is not None:
                    result = self.evaluate_formula(formula, cell_ref)
                    item = self.table.item(row, col)
                    if item:
                        self.table.blockSignals(True)
                        item.setText(str(result))
                        self.table.blockSignals(False)
        
        QMessageBox.information(self, "C√°lculo", "Todas las f√≥rmulas han sido recalculadas")
    
    def text_to_columns(self):
        """Convertir texto a columnas"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QRadioButton, QLineEdit, QDialogButtonBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Texto en columnas")
        dialog.setMinimumWidth(350)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Selecciona el delimitador:"))
        
        tab_radio = QRadioButton("Tabulaci√≥n")
        comma_radio = QRadioButton("Coma")
        comma_radio.setChecked(True)
        semicolon_radio = QRadioButton("Punto y coma")
        space_radio = QRadioButton("Espacio")
        other_radio = QRadioButton("Otro:")
        
        other_input = QLineEdit()
        other_input.setFixedWidth(50)
        
        layout.addWidget(tab_radio)
        layout.addWidget(comma_radio)
        layout.addWidget(semicolon_radio)
        layout.addWidget(space_radio)
        
        other_layout = QHBoxLayout()
        other_layout.addWidget(other_radio)
        other_layout.addWidget(other_input)
        other_layout.addStretch()
        layout.addLayout(other_layout)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            delimiter = ","
            if tab_radio.isChecked():
                delimiter = "\t"
            elif semicolon_radio.isChecked():
                delimiter = ";"
            elif space_radio.isChecked():
                delimiter = " "
            elif other_radio.isChecked() and other_input.text():
                delimiter = other_input.text()
            
            # Aplicar a la selecci√≥n
            current = self.table.currentItem()
            if current:
                row = self.table.currentRow()
                col = self.table.currentColumn()
                parts = current.text().split(delimiter)
                
                for i, part in enumerate(parts):
                    new_col = col + i
                    if new_col < self.table.columnCount():
                        item = self.table.item(row, new_col)
                        if not item:
                            item = QTableWidgetItem()
                            self.table.setItem(row, new_col, item)
                        item.setText(part.strip())
    
    def remove_duplicates(self):
        """Quitar filas duplicadas"""
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona un rango de datos")
            return
        
        r = ranges[0]
        seen = set()
        rows_to_remove = []
        
        for row in range(r.topRow(), r.bottomRow() + 1):
            row_data = []
            for col in range(r.leftColumn(), r.rightColumn() + 1):
                item = self.table.item(row, col)
                row_data.append(item.text() if item else "")
            
            row_tuple = tuple(row_data)
            if row_tuple in seen:
                rows_to_remove.append(row)
            else:
                seen.add(row_tuple)
        
        # Eliminar filas duplicadas (de abajo hacia arriba)
        for row in reversed(rows_to_remove):
            self.table.removeRow(row)
        
        QMessageBox.information(self, "Duplicados eliminados", 
                               f"Se eliminaron {len(rows_to_remove)} filas duplicadas")
    
    def export_to_html_dialog(self):
        """Di√°logo para exportar a HTML"""
        from PyQt6.QtWidgets import QFileDialog
        
        file_name, _ = QFileDialog.getSaveFileName(
            self, "Exportar a HTML", "", "Archivo HTML (*.html)"
        )
        
        if file_name:
            if not file_name.endswith('.html'):
                file_name += '.html'
            self.export_to_html(file_name)
            QMessageBox.information(self, "Exportaci√≥n exitosa", f"Archivo exportado a:\n{file_name}")
    
    def toggle_gridlines(self, state):
        """Alternar l√≠neas de cuadr√≠cula"""
        self.table.setShowGrid(state == Qt.CheckState.Checked.value)
    
    def toggle_headings(self, state):
        """Alternar encabezados"""
        if state == Qt.CheckState.Checked.value:
            self.table.horizontalHeader().show()
            self.table.verticalHeader().show()
        else:
            self.table.horizontalHeader().hide()
            self.table.verticalHeader().hide()
    
    def toggle_formula_bar(self, state):
        """Alternar barra de f√≥rmulas"""
        # Se implementar√≠a ocultando/mostrando el widget de la barra de f√≥rmulas
        pass
    
    def show_zoom_dialog(self):
        """Mostrar di√°logo de zoom"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QRadioButton, QSpinBox, QDialogButtonBox, QLabel, QHBoxLayout
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Zoom")
        dialog.setMinimumWidth(250)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Ampliaci√≥n:"))
        
        zoom_200 = QRadioButton("200%")
        zoom_100 = QRadioButton("100%")
        zoom_100.setChecked(True)
        zoom_75 = QRadioButton("75%")
        zoom_50 = QRadioButton("50%")
        zoom_25 = QRadioButton("25%")
        
        custom_layout = QHBoxLayout()
        zoom_custom = QRadioButton("Personalizado:")
        zoom_spin = QSpinBox()
        zoom_spin.setRange(10, 400)
        zoom_spin.setValue(100)
        zoom_spin.setSuffix("%")
        custom_layout.addWidget(zoom_custom)
        custom_layout.addWidget(zoom_spin)
        custom_layout.addStretch()
        
        layout.addWidget(zoom_200)
        layout.addWidget(zoom_100)
        layout.addWidget(zoom_75)
        layout.addWidget(zoom_50)
        layout.addWidget(zoom_25)
        layout.addLayout(custom_layout)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            if zoom_200.isChecked():
                self.set_zoom(200)
            elif zoom_100.isChecked():
                self.set_zoom(100)
            elif zoom_75.isChecked():
                self.set_zoom(75)
            elif zoom_50.isChecked():
                self.set_zoom(50)
            elif zoom_25.isChecked():
                self.set_zoom(25)
            else:
                self.set_zoom(zoom_spin.value())
    
    def set_zoom(self, percent):
        """Establecer nivel de zoom"""
        self.zoom_slider.setValue(percent)
    
    def on_zoom_changed(self, value):
        """Manejar cambio de zoom"""
        self.zoom_percent_label.setText(f"{value}%")
        scale = value / 100.0
        
        # Ajustar tama√±o de fuente
        font = self.table.font()
        font.setPointSize(int(11 * scale))
        self.table.setFont(font)
        
        # Ajustar tama√±o de filas y columnas
        default_row_height = 22
        default_col_width = 85
        
        for row in range(min(100, self.table.rowCount())):
            self.table.setRowHeight(row, int(default_row_height * scale))
        for col in range(min(26, self.table.columnCount())):
            self.table.setColumnWidth(col, int(default_col_width * scale))
    
    def zoom_in(self):
        """Aumentar zoom"""
        current = self.zoom_slider.value()
        self.zoom_slider.setValue(min(400, current + 10))
    
    def zoom_out(self):
        """Disminuir zoom"""
        current = self.zoom_slider.value()
        self.zoom_slider.setValue(max(10, current - 10))
    
    def show_freeze_menu(self):
        """Mostrar men√∫ de congelar paneles"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
        """)
        
        menu.addAction("Inmovilizar paneles").triggered.connect(self.freeze_panes)
        menu.addAction("Inmovilizar fila superior").triggered.connect(self.freeze_top_row)
        menu.addAction("Inmovilizar primera columna").triggered.connect(self.freeze_first_column)
        menu.addSeparator()
        menu.addAction("Movilizar paneles").triggered.connect(self.unfreeze_panes)
        
        menu.exec(self.mapToGlobal(self.sender().rect().bottomLeft()))
    
    def freeze_panes(self):
        """Congelar paneles en la celda actual"""
        row = self.table.currentRow()
        col = self.table.currentColumn()
        if row > 0:
            self.frozen_rows = row
        if col > 0:
            self.frozen_cols = col
        QMessageBox.information(self, "Paneles inmovilizados", 
                               f"Paneles inmovilizados en fila {row + 1}, columna {chr(65 + col)}")
    
    def freeze_top_row(self):
        """Congelar fila superior"""
        self.frozen_rows = 1
        QMessageBox.information(self, "Fila inmovilizada", "Fila superior inmovilizada")
    
    def freeze_first_column(self):
        """Congelar primera columna"""
        self.frozen_cols = 1
        QMessageBox.information(self, "Columna inmovilizada", "Primera columna inmovilizada")
    
    def unfreeze_panes(self):
        """Descongelar paneles"""
        self.frozen_rows = 0
        self.frozen_cols = 0
        QMessageBox.information(self, "Paneles movilizados", "Todos los paneles han sido movilizados")
    
    def toggle_split(self):
        """Alternar divisi√≥n de ventana"""
        QMessageBox.information(self, "Dividir", "Usa el men√∫ Ver > Dividir para dividir la vista")
    
    def go_to_cell(self):
        """Ir a una celda espec√≠fica"""
        cell_ref = self.cell_name_box.text().upper()
        row, col = self.parse_cell_reference(cell_ref)
        if row is not None and col is not None:
            if row < self.table.rowCount() and col < self.table.columnCount():
                self.table.setCurrentCell(row, col)
                self.table.scrollToItem(self.table.item(row, col) or self.table.itemAt(0, 0))
    
    def switch_to_sheet(self, sheet_name):
        """Cambiar a una hoja espec√≠fica"""
        if sheet_name != self.current_sheet:
            # Guardar hoja actual
            self.save_current_sheet()
            
            # Cambiar a nueva hoja
            self.current_sheet = sheet_name
            self.load_sheet(sheet_name)
            
            # Actualizar pesta√±as visuales
            self.update_sheet_tabs()
    
    def update_sheet_tabs(self):
        """Actualizar aspecto de las pesta√±as de hojas"""
        # Limpiar pesta√±as existentes
        while self.sheets_tabs_layout.count():
            item = self.sheets_tabs_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Crear nuevas pesta√±as
        for sheet_name in self.sheets.keys():
            self.create_sheet_tab(sheet_name, active=(sheet_name == self.current_sheet))
    
    def show_sheet_context_menu(self, sheet_name, pos):
        """Mostrar men√∫ contextual para pesta√±as de hojas"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
        """)
        
        menu.addAction("Insertar...").triggered.connect(self.add_new_sheet)
        menu.addAction("Eliminar").triggered.connect(self.delete_current_sheet)
        menu.addAction("Cambiar nombre...").triggered.connect(self.rename_current_sheet)
        menu.addSeparator()
        menu.addAction("Mover o copiar...")
        menu.addAction("Ver c√≥digo")
        menu.addSeparator()
        menu.addAction("Proteger hoja...")
        menu.addAction("Color de etiqueta").triggered.connect(self.change_sheet_tab_color)
        
        menu.exec(self.sender().mapToGlobal(pos))
    
    def change_sheet_tab_color(self):
        """Cambiar color de la etiqueta de hoja"""
        from PyQt6.QtWidgets import QColorDialog
        color = QColorDialog.getColor(QColor("#ffffff"), self, "Color de etiqueta")
        if color.isValid():
            # Actualizar color de la pesta√±a actual
            pass
    
    def copy_cells(self):
        """Copiar celdas seleccionadas"""
        ranges = self.table.selectedRanges()
        if not ranges:
            return
        
        r = ranges[0]
        self.clipboard_data = []
        self.clipboard_format = []
        
        for row in range(r.topRow(), r.bottomRow() + 1):
            row_data = []
            row_format = []
            for col in range(r.leftColumn(), r.rightColumn() + 1):
                item = self.table.item(row, col)
                if item:
                    row_data.append(item.text())
                    row_format.append({
                        'font': item.font(),
                        'bg': item.background(),
                        'fg': item.foreground(),
                        'align': item.textAlignment()
                    })
                else:
                    row_data.append("")
                    row_format.append(None)
            self.clipboard_data.append(row_data)
            self.clipboard_format.append(row_format)
        
        # Tambi√©n copiar al portapapeles del sistema
        from PyQt6.QtWidgets import QApplication
        clipboard = QApplication.clipboard()
        text = "\n".join(["\t".join(row) for row in self.clipboard_data])
        clipboard.setText(text)
    
    def paste_cells(self):
        """Pegar celdas"""
        if not self.clipboard_data:
            # Intentar pegar desde portapapeles del sistema
            from PyQt6.QtWidgets import QApplication
            clipboard = QApplication.clipboard()
            text = clipboard.text()
            if text:
                lines = text.split("\n")
                self.clipboard_data = [line.split("\t") for line in lines]
                self.clipboard_format = [[None] * len(row) for row in self.clipboard_data]
        
        if not self.clipboard_data:
            return
        
        start_row = self.table.currentRow()
        start_col = self.table.currentColumn()
        
        if start_row < 0 or start_col < 0:
            return
        
        self.table.blockSignals(True)
        
        for i, row_data in enumerate(self.clipboard_data):
            for j, value in enumerate(row_data):
                target_row = start_row + i
                target_col = start_col + j
                
                if target_row < self.table.rowCount() and target_col < self.table.columnCount():
                    item = self.table.item(target_row, target_col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(target_row, target_col, item)
                    
                    item.setText(value)
                    
                    # Aplicar formato si existe
                    if self.clipboard_format and i < len(self.clipboard_format) and j < len(self.clipboard_format[i]):
                        fmt = self.clipboard_format[i][j]
                        if fmt:
                            item.setFont(fmt['font'])
                            item.setBackground(fmt['bg'])
                            item.setForeground(fmt['fg'])
                            item.setTextAlignment(fmt['align'])
        
        self.table.blockSignals(False)
        self.data_changed.emit()
    
    def cut_cells(self):
        """Cortar celdas"""
        self.copy_cells()
        self.clear_selected_cells()
    
    def clear_selected_cells(self):
        """Limpiar celdas seleccionadas"""
        ranges = self.table.selectedRanges()
        self.table.blockSignals(True)
        
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item:
                        item.setText("")
        
        self.table.blockSignals(False)
        self.data_changed.emit()
    
    def copy_format(self):
        """Copiar formato de celda"""
        current = self.table.currentItem()
        if current:
            self.clipboard_format = [{
                'font': current.font(),
                'bg': current.background(),
                'fg': current.foreground(),
                'align': current.textAlignment()
            }]
            QMessageBox.information(self, "Copiar formato", 
                                   "Formato copiado. Selecciona celdas y pega para aplicar.")
    
    def undo_action(self):
        """Deshacer √∫ltima acci√≥n"""
        if self.undo_stack:
            action = self.undo_stack.pop()
            self.redo_stack.append(action)
            # Implementar deshacer
    
    def redo_action(self):
        """Rehacer √∫ltima acci√≥n deshecha"""
        if self.redo_stack:
            action = self.redo_stack.pop()
            self.undo_stack.append(action)
            # Implementar rehacer
    
    def edit_current_cell(self):
        """Editar celda actual"""
        current = self.table.currentItem()
        if current:
            self.table.editItem(current)
    
    def show_format_cells_dialog(self):
        """Mostrar di√°logo de formato de celdas completo"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QTabWidget, QWidget, QFormLayout, QComboBox, QSpinBox, QCheckBox, QDialogButtonBox, QColorDialog, QPushButton, QLabel, QHBoxLayout
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Formato de celdas")
        dialog.setMinimumSize(450, 400)
        dialog.setStyleSheet("background-color: #ffffff;")
        
        layout = QVBoxLayout(dialog)
        
        tabs = QTabWidget()
        
        # Pesta√±a N√∫mero
        number_tab = QWidget()
        number_layout = QFormLayout(number_tab)
        
        category_combo = QComboBox()
        category_combo.addItems(["General", "N√∫mero", "Moneda", "Contabilidad", "Fecha", "Hora", "Porcentaje", "Fracci√≥n", "Cient√≠fico", "Texto"])
        number_layout.addRow("Categor√≠a:", category_combo)
        
        decimals_spin = QSpinBox()
        decimals_spin.setRange(0, 30)
        decimals_spin.setValue(2)
        number_layout.addRow("Posiciones decimales:", decimals_spin)
        
        use_separator = QCheckBox("Usar separador de miles")
        use_separator.setChecked(True)
        number_layout.addRow(use_separator)
        
        tabs.addTab(number_tab, "N√∫mero")
        
        # Pesta√±a Alineaci√≥n
        align_tab = QWidget()
        align_layout = QFormLayout(align_tab)
        
        h_align_combo = QComboBox()
        h_align_combo.addItems(["General", "Izquierda", "Centro", "Derecha", "Rellenar", "Justificar"])
        align_layout.addRow("Horizontal:", h_align_combo)
        
        v_align_combo = QComboBox()
        v_align_combo.addItems(["Superior", "Centro", "Inferior"])
        v_align_combo.setCurrentText("Centro")
        align_layout.addRow("Vertical:", v_align_combo)
        
        wrap_text = QCheckBox("Ajustar texto")
        align_layout.addRow(wrap_text)
        
        merge_cells = QCheckBox("Combinar celdas")
        align_layout.addRow(merge_cells)
        
        tabs.addTab(align_tab, "Alineaci√≥n")
        
        # Pesta√±a Fuente
        font_tab = QWidget()
        font_layout = QFormLayout(font_tab)
        
        font_family_combo = QComboBox()
        font_family_combo.addItems(["Calibri", "Arial", "Times New Roman", "Verdana", "Consolas"])
        font_layout.addRow("Fuente:", font_family_combo)
        
        font_size_spin = QSpinBox()
        font_size_spin.setRange(6, 72)
        font_size_spin.setValue(11)
        font_layout.addRow("Tama√±o:", font_size_spin)
        
        bold_check = QCheckBox("Negrita")
        italic_check = QCheckBox("Cursiva")
        underline_check = QCheckBox("Subrayado")
        strikeout_check = QCheckBox("Tachado")
        
        font_layout.addRow(bold_check)
        font_layout.addRow(italic_check)
        font_layout.addRow(underline_check)
        font_layout.addRow(strikeout_check)
        
        tabs.addTab(font_tab, "Fuente")
        
        # Pesta√±a Relleno
        fill_tab = QWidget()
        fill_layout = QVBoxLayout(fill_tab)
        
        fill_layout.addWidget(QLabel("Color de fondo:"))
        
        colors_grid = QWidget()
        colors_grid_layout = QGridLayout(colors_grid)
        colors_grid_layout.setSpacing(2)
        
        colors = [
            "#FFFFFF", "#000000", "#E7E6E6", "#44546A", "#4472C4", "#ED7D31",
            "#A5A5A5", "#FFC000", "#5B9BD5", "#70AD47", "#FF0000", "#00B050",
            "#FFFF00", "#00B0F0", "#7030A0", "#FF00FF"
        ]
        
        selected_color = [None]
        
        for i, color in enumerate(colors):
            btn = QPushButton()
            btn.setFixedSize(25, 25)
            btn.setStyleSheet(f"background-color: {color}; border: 1px solid #c0c0c0;")
            btn.clicked.connect(lambda checked, c=color: selected_color.__setitem__(0, c))
            colors_grid_layout.addWidget(btn, i // 8, i % 8)
        
        fill_layout.addWidget(colors_grid)
        
        more_colors_btn = QPushButton("M√°s colores...")
        more_colors_btn.clicked.connect(lambda: selected_color.__setitem__(0, QColorDialog.getColor().name()))
        fill_layout.addWidget(more_colors_btn)
        
        fill_layout.addStretch()
        
        tabs.addTab(fill_tab, "Relleno")
        
        layout.addWidget(tabs)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Aplicar formato a las celdas seleccionadas
            from PyQt6.QtGui import QFont, QBrush, QColor
            
            ranges = self.table.selectedRanges()
            for r in ranges:
                for row in range(r.topRow(), r.bottomRow() + 1):
                    for col in range(r.leftColumn(), r.rightColumn() + 1):
                        item = self.table.item(row, col)
                        if not item:
                            item = QTableWidgetItem()
                            self.table.setItem(row, col, item)
                        
                        # Aplicar fuente
                        font = QFont(font_family_combo.currentText(), font_size_spin.value())
                        font.setBold(bold_check.isChecked())
                        font.setItalic(italic_check.isChecked())
                        font.setUnderline(underline_check.isChecked())
                        font.setStrikeOut(strikeout_check.isChecked())
                        item.setFont(font)
                        
                        # Aplicar color de fondo
                        if selected_color[0]:
                            item.setBackground(QBrush(QColor(selected_color[0])))
                        
                        # Aplicar alineaci√≥n
                        h_align = Qt.AlignmentFlag.AlignLeft
                        if h_align_combo.currentText() == "Centro":
                            h_align = Qt.AlignmentFlag.AlignHCenter
                        elif h_align_combo.currentText() == "Derecha":
                            h_align = Qt.AlignmentFlag.AlignRight
                        
                        v_align = Qt.AlignmentFlag.AlignVCenter
                        if v_align_combo.currentText() == "Superior":
                            v_align = Qt.AlignmentFlag.AlignTop
                        elif v_align_combo.currentText() == "Inferior":
                            v_align = Qt.AlignmentFlag.AlignBottom
                        
                        item.setTextAlignment(h_align | v_align)
    
    def autofill_right(self):
        """Autorrellenar hacia la derecha"""
        ranges = self.table.selectedRanges()
        if not ranges:
            return
        
        r = ranges[0]
        left_col = r.leftColumn()
        
        for row in range(r.topRow(), r.bottomRow() + 1):
            source_item = self.table.item(row, left_col)
            if source_item:
                for col in range(left_col + 1, r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(row, col, item)
                    item.setText(source_item.text())
                    item.setFont(source_item.font())
                    item.setBackground(source_item.background())
                    item.setForeground(source_item.foreground())
    
    def autofit_columns(self):
        """Autoajustar ancho de columnas seg√∫n contenido"""
        for col in range(self.table.columnCount()):
            max_width = 50  # Ancho m√≠nimo
            for row in range(min(100, self.table.rowCount())):  # Revisar primeras 100 filas
                item = self.table.item(row, col)
                if item and item.text():
                    # Calcular ancho aproximado del texto
                    from PyQt6.QtGui import QFontMetrics
                    fm = QFontMetrics(item.font() if item.font().family() else self.table.font())
                    text_width = fm.horizontalAdvance(item.text()) + 20  # Padding
                    max_width = max(max_width, min(text_width, 300))  # M√°ximo 300px
            self.table.setColumnWidth(col, max_width)
        
        self.ready_label.setText("Columnas autoajustadas")
    
    def autofit_rows(self):
        """Autoajustar alto de filas seg√∫n contenido"""
        for row in range(min(100, self.table.rowCount())):
            max_height = 22  # Alto m√≠nimo
            for col in range(self.table.columnCount()):
                item = self.table.item(row, col)
                if item and item.text():
                    from PyQt6.QtGui import QFontMetrics
                    fm = QFontMetrics(item.font() if item.font().family() else self.table.font())
                    lines = item.text().count('\n') + 1
                    text_height = fm.height() * lines + 10
                    max_height = max(max_height, text_height)
            self.table.setRowHeight(row, max_height)
        
        self.ready_label.setText("Filas autoajustadas")
    
    def insert_current_date(self):
        """Insertar fecha actual en la celda seleccionada"""
        from datetime import datetime
        current = self.table.currentItem()
        row = self.table.currentRow()
        col = self.table.currentColumn()
        
        if row >= 0 and col >= 0:
            if not current:
                current = QTableWidgetItem()
                self.table.setItem(row, col, current)
            current.setText(datetime.now().strftime("%d/%m/%Y"))
    
    def insert_current_time(self):
        """Insertar hora actual en la celda seleccionada"""
        from datetime import datetime
        current = self.table.currentItem()
        row = self.table.currentRow()
        col = self.table.currentColumn()
        
        if row >= 0 and col >= 0:
            if not current:
                current = QTableWidgetItem()
                self.table.setItem(row, col, current)
            current.setText(datetime.now().strftime("%H:%M:%S"))
    
    def insert_datetime(self):
        """Insertar fecha y hora actual en la celda seleccionada"""
        from datetime import datetime
        current = self.table.currentItem()
        row = self.table.currentRow()
        col = self.table.currentColumn()
        
        if row >= 0 and col >= 0:
            if not current:
                current = QTableWidgetItem()
                self.table.setItem(row, col, current)
            current.setText(datetime.now().strftime("%d/%m/%Y %H:%M"))
    
    def select_all_cells(self):
        """Seleccionar todas las celdas"""
        self.table.selectAll()
    
    def select_column(self):
        """Seleccionar toda la columna actual"""
        from PyQt6.QtWidgets import QTableWidgetSelectionRange
        col = self.table.currentColumn()
        if col >= 0:
            self.table.setRangeSelected(
                QTableWidgetSelectionRange(0, col, self.table.rowCount() - 1, col),
                True
            )
    
    def select_row(self):
        """Seleccionar toda la fila actual"""
        from PyQt6.QtWidgets import QTableWidgetSelectionRange
        row = self.table.currentRow()
        if row >= 0:
            self.table.setRangeSelected(
                QTableWidgetSelectionRange(row, 0, row, self.table.columnCount() - 1),
                True
            )
    
    def hide_column(self):
        """Ocultar columna actual"""
        col = self.table.currentColumn()
        if col >= 0:
            self.table.hideColumn(col)
            self.ready_label.setText(f"Columna {chr(65 + col)} oculta")
    
    def hide_row(self):
        """Ocultar fila actual"""
        row = self.table.currentRow()
        if row >= 0:
            self.table.hideRow(row)
            self.ready_label.setText(f"Fila {row + 1} oculta")
    
    def show_all_columns(self):
        """Mostrar todas las columnas ocultas"""
        for col in range(self.table.columnCount()):
            self.table.showColumn(col)
        self.ready_label.setText("Todas las columnas visibles")
    
    def show_all_rows(self):
        """Mostrar todas las filas ocultas"""
        for row in range(self.table.rowCount()):
            self.table.showRow(row)
        self.ready_label.setText("Todas las filas visibles")
    
    def set_column_width_dialog(self):
        """Mostrar di√°logo para establecer ancho de columna"""
        from PyQt6.QtWidgets import QInputDialog
        
        col = self.table.currentColumn()
        if col < 0:
            return
        
        current_width = self.table.columnWidth(col)
        width, ok = QInputDialog.getInt(
            self,
            "Ancho de columna",
            f"Ancho para columna {chr(65 + col)}:",
            current_width, 20, 500
        )
        
        if ok:
            self.table.setColumnWidth(col, width)
    
    def set_row_height_dialog(self):
        """Mostrar di√°logo para establecer alto de fila"""
        from PyQt6.QtWidgets import QInputDialog
        
        row = self.table.currentRow()
        if row < 0:
            return
        
        current_height = self.table.rowHeight(row)
        height, ok = QInputDialog.getInt(
            self,
            "Alto de fila",
            f"Alto para fila {row + 1}:",
            current_height, 15, 200
        )
        
        if ok:
            self.table.setRowHeight(row, height)
    
    def transpose_selection(self):
        """Transponer datos seleccionados (intercambiar filas y columnas)"""
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona un rango de celdas")
            return
        
        r = ranges[0]
        
        # Leer datos
        data = []
        for row in range(r.topRow(), r.bottomRow() + 1):
            row_data = []
            for col in range(r.leftColumn(), r.rightColumn() + 1):
                item = self.table.item(row, col)
                row_data.append(item.text() if item else "")
            data.append(row_data)
        
        # Transponer
        transposed = list(map(list, zip(*data)))
        
        # Escribir datos transpuestos
        self.table.blockSignals(True)
        for i, row_data in enumerate(transposed):
            for j, value in enumerate(row_data):
                target_row = r.topRow() + i
                target_col = r.leftColumn() + j
                if target_row < self.table.rowCount() and target_col < self.table.columnCount():
                    item = self.table.item(target_row, target_col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(target_row, target_col, item)
                    item.setText(value)
        self.table.blockSignals(False)
        
        self.ready_label.setText("Datos transpuestos")
    
    def fill_series(self):
        """Rellenar serie num√©rica en las celdas seleccionadas"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QSpinBox, QDialogButtonBox
        
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona un rango de celdas")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Rellenar serie")
        dialog.setStyleSheet(self.get_dialog_style())
        
        layout = QVBoxLayout(dialog)
        
        start_layout = QHBoxLayout()
        start_layout.addWidget(QLabel("Valor inicial:"))
        start_spin = QSpinBox()
        start_spin.setRange(-10000, 10000)
        start_spin.setValue(1)
        start_layout.addWidget(start_spin)
        layout.addLayout(start_layout)
        
        step_layout = QHBoxLayout()
        step_layout.addWidget(QLabel("Incremento:"))
        step_spin = QSpinBox()
        step_spin.setRange(-100, 100)
        step_spin.setValue(1)
        step_layout.addWidget(step_spin)
        layout.addLayout(step_layout)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            r = ranges[0]
            start = start_spin.value()
            step = step_spin.value()
            
            self.table.blockSignals(True)
            idx = 0
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(row, col, item)
                    item.setText(str(start + idx * step))
                    idx += 1
            self.table.blockSignals(False)
            
            self.ready_label.setText("Serie creada")
    
    def calculate_selection_info(self):
        """Calcular y mostrar informaci√≥n de la selecci√≥n"""
        ranges = self.table.selectedRanges()
        if not ranges:
            return
        
        values = []
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        try:
                            values.append(float(item.text().replace('$', '').replace(',', '').replace('%', '')))
                        except:
                            pass
        
        if values:
            import statistics
            info = f"""
            <h3>Estad√≠sticas de la selecci√≥n</h3>
            <table style='font-size: 10pt;'>
            <tr><td><b>Suma:</b></td><td>{sum(values):,.2f}</td></tr>
            <tr><td><b>Promedio:</b></td><td>{statistics.mean(values):,.2f}</td></tr>
            <tr><td><b>Mediana:</b></td><td>{statistics.median(values):,.2f}</td></tr>
            <tr><td><b>M√≠nimo:</b></td><td>{min(values):,.2f}</td></tr>
            <tr><td><b>M√°ximo:</b></td><td>{max(values):,.2f}</td></tr>
            <tr><td><b>Recuento:</b></td><td>{len(values)}</td></tr>
            </table>
            """
            if len(values) > 1:
                info = info.replace("</table>", f"""
                <tr><td><b>Desv. Est.:</b></td><td>{statistics.stdev(values):,.4f}</td></tr>
                <tr><td><b>Varianza:</b></td><td>{statistics.variance(values):,.4f}</td></tr>
                </table>
                """)
            
            QMessageBox.information(self, "Estad√≠sticas", info)
        else:
            QMessageBox.information(self, "Sin datos", "No hay valores num√©ricos en la selecci√≥n")
    
    def apply_strikethrough(self):
        """Aplicar tachado al texto de las celdas seleccionadas"""
        ranges = self.table.selectedRanges()
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item:
                        font = item.font()
                        font.setStrikeOut(not font.strikeOut())
                        item.setFont(font)
    
    def wrap_text(self):
        """Activar ajuste de texto en las celdas seleccionadas"""
        # En QTableWidget esto se maneja con setWordWrap
        ranges = self.table.selectedRanges()
        if ranges:
            for r in ranges:
                for row in range(r.topRow(), r.bottomRow() + 1):
                    self.table.setRowHeight(row, 50)  # Aumentar alto para texto ajustado
            self.ready_label.setText("Ajuste de texto activado")
    
    def create_quick_format_button(self, text, tooltip, bold=False, italic=False, underline=False):
        """Crear bot√≥n de formato r√°pido"""
        btn = QPushButton(text)
        btn.setToolTip(tooltip)
        btn.setFixedSize(28, 28)
        
        font_style = ""
        if bold:
            font_style += "font-weight: bold;"
        if italic:
            font_style += "font-style: italic;"
        if underline:
            font_style += "text-decoration: underline;"
        
        btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #ffffff;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                color: #ffffff;
                font-size: 11pt;
                {font_style}
                padding: 2px;
            }}
            QPushButton:hover {{
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }}
            QPushButton:pressed {{
                background-color: #217346;
            }}
        """)
        return btn
    
    def add_separator(self, layout):
        """Agregar separador vertical"""
        separator = QLabel("|")
        separator.setStyleSheet("color: #3a3a3a; padding: 0 3px; font-size: 16pt;")
        layout.addWidget(separator)
    
    # Funciones de formato r√°pido
    def quick_toggle_bold(self):
        """Alternar negrita r√°pidamente"""
        current = self.table.currentItem()
        if current:
            font = current.font()
            font.setBold(not font.bold())
            current.setFont(font)
    
    def quick_toggle_italic(self):
        """Alternar cursiva r√°pidamente"""
        current = self.table.currentItem()
        if current:
            font = current.font()
            font.setItalic(not font.italic())
            current.setFont(font)
    
    def quick_toggle_underline(self):
        """Alternar subrayado r√°pidamente"""
        current = self.table.currentItem()
        if current:
            font = current.font()
            font.setUnderline(not font.underline())
            current.setFont(font)
    
    def quick_align(self, alignment):
        """Alinear celda r√°pidamente"""
        current = self.table.currentItem()
        if current:
            current.setTextAlignment(alignment | Qt.AlignmentFlag.AlignVCenter)
    
    def format_as_percentage(self):
        """Formatear como porcentaje"""
        current = self.table.currentItem()
        if current:
            try:
                value = float(current.text())
                current.setText(f"{value:.2f}%")
            except:
                pass
    
    def format_as_currency(self):
        """Formatear como moneda"""
        current = self.table.currentItem()
        if current:
            try:
                value = float(current.text())
                current.setText(f"${value:,.2f}")
            except:
                pass
    
    def increase_decimals(self):
        """Aumentar decimales"""
        current = self.table.currentItem()
        if current:
            try:
                value = float(current.text().replace('$', '').replace(',', '').replace('%', ''))
                current.setText(f"{value:.2f}")
            except:
                pass
    
    def show_borders_menu(self):
        """Mostrar men√∫ de bordes estilo Excel"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 6px 20px;
            }
            QMenu::item:selected {
                background-color: #e5f3ff;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 3px 10px;
            }
        """)
        
        menu.addAction("‚äû Todos los bordes").triggered.connect(lambda: self.apply_borders("all"))
        menu.addAction("‚ä° Borde exterior").triggered.connect(lambda: self.apply_borders("outer"))
        menu.addAction("‚äü Bordes gruesos").triggered.connect(lambda: self.apply_borders("thick"))
        menu.addSeparator()
        menu.addAction("‚ñî Borde superior").triggered.connect(lambda: self.apply_borders("top"))
        menu.addAction("‚ñÅ Borde inferior").triggered.connect(lambda: self.apply_borders("bottom"))
        menu.addAction("‚ñè Borde izquierdo").triggered.connect(lambda: self.apply_borders("left"))
        menu.addAction("‚ñï Borde derecho").triggered.connect(lambda: self.apply_borders("right"))
        menu.addSeparator()
        menu.addAction("‚äû Borde inferior doble").triggered.connect(lambda: self.apply_borders("double_bottom"))
        menu.addAction("‚äü Borde inferior grueso").triggered.connect(lambda: self.apply_borders("thick_bottom"))
        menu.addSeparator()
        menu.addAction("‚òê Sin bordes").triggered.connect(lambda: self.apply_borders("none"))
        menu.addSeparator()
        menu.addAction("üé® Dibujar borde...").triggered.connect(self.show_border_drawing_dialog)
        menu.addAction("‚öôÔ∏è M√°s bordes...").triggered.connect(self.show_format_cells_dialog)
        
        menu.exec(self.sender().mapToGlobal(self.sender().rect().bottomLeft()))
    
    def apply_borders(self, border_type):
        """Aplicar bordes a celdas seleccionadas"""
        from PyQt6.QtGui import QColor, QBrush
        
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona un rango de celdas")
            return
        
        border_color = QColor("#000000")
        
        for r in ranges:
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(row, col, item)
                    
                    # Aplicar estilo de borde seg√∫n el tipo
                    if border_type == "all":
                        # Simular bordes con fondo ligero en las esquinas
                        pass
                    elif border_type == "none":
                        # Quitar bordes
                        pass
        
        self.ready_label.setText(f"Bordes '{border_type}' aplicados")
    
    def show_border_drawing_dialog(self):
        """Mostrar di√°logo para dibujar bordes personalizados"""
        QMessageBox.information(self, "Dibujar borde", 
                               "Selecciona las celdas y usa el men√∫ de bordes para aplicar estilos")
    
    def sort_ascending(self):
        """Ordenar columna ascendente"""
        current_col = self.table.currentColumn()
        if current_col < 0:
            return
        
        self.table.sortItems(current_col, Qt.SortOrder.AscendingOrder)
    
    def sort_descending(self):
        """Ordenar columna descendente"""
        current_col = self.table.currentColumn()
        if current_col < 0:
            return
        
        self.table.sortItems(current_col, Qt.SortOrder.DescendingOrder)
    
    def toggle_filter(self):
        """Alternar filtros (simplificado)"""
        QMessageBox.information(
            self,
            "Filtros",
            "Funci√≥n de filtros activada.\nUsa el men√∫ contextual para ordenar y filtrar datos."
        )
    
    def apply_zoom(self, zoom_text):
        """Aplicar zoom a la tabla"""
        try:
            zoom_value = int(zoom_text.replace("%", ""))
            scale_factor = zoom_value / 100.0
            
            # Ajustar tama√±o de fuente basado en zoom
            font = self.table.font()
            base_size = 10
            font.setPointSize(int(base_size * scale_factor))
            self.table.setFont(font)
            
            # Ajustar alto de filas y ancho de columnas
            for row in range(self.table.rowCount()):
                self.table.setRowHeight(row, int(25 * scale_factor))
            for col in range(self.table.columnCount()):
                self.table.setColumnWidth(col, int(80 * scale_factor))
                
        except Exception as e:
            print(f"Error applying zoom: {e}")
    
    def add_new_sheet(self):
        """Agregar nueva hoja"""
        from PyQt6.QtWidgets import QInputDialog
        
        sheet_name, ok = QInputDialog.getText(
            self,
            "Nueva Hoja",
            "Nombre de la nueva hoja:",
            text=f"Hoja{len(self.sheets) + 1}"
        )
        
        if ok and sheet_name:
            if sheet_name not in self.sheets:
                # Guardar hoja actual
                self.save_current_sheet()
                
                # Crear nueva hoja
                self.sheets[sheet_name] = {"data": {}, "formulas": {}, "dependencies": {}}
                
                # Actualizar pesta√±as visuales
                self.update_sheet_tabs()
                
                # Cambiar a la nueva hoja
                self.switch_to_sheet(sheet_name)
                
                self.ready_label.setText(f"Hoja '{sheet_name}' creada")
            else:
                QMessageBox.warning(self, "Nombre duplicado", "Ya existe una hoja con ese nombre")
    
    def rename_current_sheet(self):
        """Renombrar hoja actual"""
        from PyQt6.QtWidgets import QInputDialog
        
        if self.current_sheet == "Hoja1" and len(self.sheets) == 1:
            QMessageBox.warning(
                self,
                "No se puede renombrar",
                "Debe haber al menos una hoja. Crea otra hoja antes de renombrar esta."
            )
            return
        
        new_name, ok = QInputDialog.getText(
            self,
            "Renombrar Hoja",
            "Nuevo nombre:",
            text=self.current_sheet
        )
        
        if ok and new_name and new_name != self.current_sheet:
            if new_name not in self.sheets:
                # Guardar datos actuales
                self.save_current_sheet()
                
                # Renombrar en el diccionario
                self.sheets[new_name] = self.sheets.pop(self.current_sheet)
                
                # Actualizar referencias en formulas
                for key in list(self.formulas.keys()):
                    if key.startswith(f"{self.current_sheet}:"):
                        new_key = key.replace(f"{self.current_sheet}:", f"{new_name}:")
                        self.formulas[new_key] = self.formulas.pop(key)
                
                self.current_sheet = new_name
                
                # Actualizar pesta√±as visuales
                self.update_sheet_tabs()
                
                self.ready_label.setText(f"Hoja renombrada a '{new_name}'")
            else:
                QMessageBox.warning(self, "Nombre duplicado", "Ya existe una hoja con ese nombre")
    
    def delete_current_sheet(self):
        """Eliminar hoja actual"""
        if len(self.sheets) <= 1:
            QMessageBox.warning(
                self,
                "No se puede eliminar",
                "Debe haber al menos una hoja en el libro."
            )
            return
        
        reply = QMessageBox.question(
            self,
            "Confirmar eliminaci√≥n",
            f"¬øEst√°s seguro de que quieres eliminar la hoja '{self.current_sheet}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Eliminar hoja
            del self.sheets[self.current_sheet]
            
            # Cambiar a la primera hoja disponible
            self.current_sheet = list(self.sheets.keys())[0]
            self.load_sheet(self.current_sheet)
            
            # Actualizar pesta√±as visuales
            self.update_sheet_tabs()
            
            self.ready_label.setText("Hoja eliminada exitosamente")
    
    def show_search_dialog(self):
        """Mostrar di√°logo de b√∫squeda y reemplazo"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QHBoxLayout
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Buscar y Reemplazar")
        dialog.setMinimumWidth(450)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
            QLineEdit {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                padding: 8px;
                font-size: 10pt;
            }
            QLineEdit:focus {
                border: 1px solid #217346;
            }
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 3px;
                font-size: 10pt;
                font-weight: bold;
                min-width: 120px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        # Campo de b√∫squeda
        layout.addWidget(QLabel("Buscar:"))
        search_input = QLineEdit()
        search_input.setPlaceholderText("Texto a buscar...")
        layout.addWidget(search_input)
        
        # Campo de reemplazo
        layout.addWidget(QLabel("Reemplazar con:"))
        replace_input = QLineEdit()
        replace_input.setPlaceholderText("Texto de reemplazo...")
        layout.addWidget(replace_input)
        
        # Botones
        button_layout = QHBoxLayout()
        
        find_btn = QPushButton("üîç Buscar siguiente")
        find_btn.clicked.connect(lambda: self.find_text(search_input.text()))
        button_layout.addWidget(find_btn)
        
        replace_btn = QPushButton("‚ÜîÔ∏è Reemplazar")
        replace_btn.clicked.connect(lambda: self.replace_text(search_input.text(), replace_input.text()))
        button_layout.addWidget(replace_btn)
        
        replace_all_btn = QPushButton("‚áÑ Reemplazar todo")
        replace_all_btn.clicked.connect(lambda: self.replace_all_text(search_input.text(), replace_input.text()))
        button_layout.addWidget(replace_all_btn)
        
        layout.addLayout(button_layout)
        
        # Bot√≥n cerrar
        close_btn = QPushButton("Cerrar")
        close_btn.clicked.connect(dialog.close)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def find_text(self, search_text):
        """Buscar texto en la hoja"""
        if not search_text:
            return
        
        # Empezar desde la celda actual
        start_row = self.table.currentRow() if self.table.currentRow() >= 0 else 0
        start_col = self.table.currentColumn() if self.table.currentColumn() >= 0 else 0
        
        # Buscar en todas las celdas
        for row in range(start_row, self.table.rowCount()):
            for col in range(start_col if row == start_row else 0, self.table.columnCount()):
                item = self.table.item(row, col)
                if item and search_text.lower() in item.text().lower():
                    self.table.setCurrentCell(row, col)
                    self.table.scrollToItem(item)
                    return
        
        # Si no se encontr√≥, buscar desde el principio
        for row in range(0, start_row + 1):
            for col in range(0, self.table.columnCount()):
                item = self.table.item(row, col)
                if item and search_text.lower() in item.text().lower():
                    self.table.setCurrentCell(row, col)
                    self.table.scrollToItem(item)
                    return
        
        QMessageBox.information(self, "B√∫squeda", "No se encontr√≥ el texto buscado")
    
    def replace_text(self, search_text, replace_text):
        """Reemplazar texto en la celda actual"""
        current = self.table.currentItem()
        if current and search_text.lower() in current.text().lower():
            new_text = current.text().replace(search_text, replace_text)
            current.setText(new_text)
            QMessageBox.information(self, "Reemplazar", "Texto reemplazado")
        else:
            QMessageBox.information(self, "Reemplazar", "No se encontr√≥ el texto en la celda actual")
    
    def replace_all_text(self, search_text, replace_text):
        """Reemplazar todo el texto en la hoja"""
        if not search_text:
            return
        
        count = 0
        for row in range(self.table.rowCount()):
            for col in range(self.table.columnCount()):
                item = self.table.item(row, col)
                if item and search_text.lower() in item.text().lower():
                    new_text = item.text().replace(search_text, replace_text)
                    item.setText(new_text)
                    count += 1
        
        QMessageBox.information(self, "Reemplazar todo", f"Se reemplazaron {count} ocurrencias")
    
    def setup_autocomplete(self):
        """Configurar autocompletado de funciones"""
        from PyQt6.QtWidgets import QCompleter
        from PyQt6.QtCore import Qt
        
        # Lista de todas las funciones disponibles
        self.functions_list = [
            "SUMA(", "SUM(", "PROMEDIO(", "AVERAGE(", "MAX(", "MIN(",
            "MEDIANA(", "MEDIAN(", "MODA(", "MODE(", "CONTAR(", "COUNT(",
            "REDONDEAR(", "ROUND(", "POTENCIA(", "POWER(", "RAIZ(", "SQRT(",
            "ABS(", "SI(", "IF(", "CONTAR.SI(", "COUNTIF(", "SUMA.SI(", "SUMIF(",
            "CONCATENAR(", "CONCAT(", "IZQUIERDA(", "LEFT(", "DERECHA(", "RIGHT(",
            "EXTRAE(", "MID(", "LARGO(", "LEN(", "MAYUSC(", "UPPER(",
            "MINUSC(", "LOWER(", "HOY()", "TODAY()", "AHORA()", "NOW()",
            "A√ëO()", "YEAR()", "MES()", "MONTH()", "DIA()", "DAY()",
            "BUSCARV(", "VLOOKUP(", "Y(", "AND(", "O(", "OR(", "NO(", "NOT("
        ]
        
        self.completer = QCompleter(self.functions_list)
        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.completer.setCompletionMode(QCompleter.CompletionMode.PopupCompletion)
        self.completer.setMaxVisibleItems(10)
        
        # Estilo del popup de autocompletado
        self.completer.popup().setStyleSheet("""
            QListView {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #4a90e2;
                selection-background-color: #217346;
                padding: 5px;
                font-size: 10pt;
            }
            QListView::item {
                padding: 5px;
                border-radius: 3px;
            }
            QListView::item:hover {
                background-color: #3a3a3a;
            }
        """)
        
        self.formula_bar.setCompleter(self.completer)
    
    def on_formula_text_changed(self, text):
        """Manejar cambio en barra de f√≥rmulas para autocompletado"""
        # Si empieza con =, activar autocompletado
        if text.startswith("="):
            # Extraer la √∫ltima palabra despu√©s del =
            import re
            matches = re.findall(r'([A-Z]+)\(?$', text.upper())
            if matches:
                prefix = matches[-1]
                # Filtrar funciones que empiecen con el prefijo
                filtered = [f for f in self.functions_list if f.upper().startswith(prefix)]
                self.completer.model().setStringList(filtered)
        else:
            self.completer.model().setStringList(self.functions_list)
    
    def show_format_menu(self):
        """Mostrar men√∫ de formato"""
        current = self.table.currentItem()
        if not current:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona una celda primero")
            return
        
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
        """)
        
        # Opciones de formato
        bold_action = menu.addAction("üî§ Negrita")
        bold_action.triggered.connect(self.toggle_cell_bold)
        
        menu.addSeparator()
        
        bg_color_action = menu.addAction("üé® Color de fondo")
        bg_color_action.triggered.connect(self.change_cell_background)
        
        text_color_action = menu.addAction("üñäÔ∏è Color de texto")
        text_color_action.triggered.connect(self.change_cell_text_color)
        
        menu.addSeparator()
        
        merge_action = menu.addAction("‚¨å Combinar celdas")
        merge_action.triggered.connect(self.merge_cells)
        
        unmerge_action = menu.addAction("‚¨ç Separar celdas")
        unmerge_action.triggered.connect(self.unmerge_cells)
        
        menu.addSeparator()
        
        clear_format_action = menu.addAction("‚úï Limpiar formato")
        clear_format_action.triggered.connect(self.clear_cell_format)
        
        menu.exec(self.sender().mapToGlobal(self.sender().rect().bottomLeft()))
    
    def toggle_cell_bold(self):
        """Alternar negrita en celda"""
        current = self.table.currentItem()
        if current:
            font = current.font()
            font.setBold(not font.bold())
            current.setFont(font)
    
    def change_cell_background(self):
        """Cambiar color de fondo de celda"""
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor, QBrush
        
        current = self.table.currentItem()
        if current:
            color = QColorDialog.getColor(QColor("#ffffff"), self, "Color de fondo")
            if color.isValid():
                current.setBackground(QBrush(color))
    
    def change_cell_text_color(self):
        """Cambiar color de texto de celda"""
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor, QBrush
        
        current = self.table.currentItem()
        if current:
            color = QColorDialog.getColor(QColor("#ffffff"), self, "Color de texto")
            if color.isValid():
                current.setForeground(QBrush(color))
    
    def merge_cells(self):
        """Combinar celdas seleccionadas"""
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(self, "Sin selecci√≥n", "Selecciona un rango de celdas para combinar")
            return
        
        for r in ranges:
            top_row = r.topRow()
            left_col = r.leftColumn()
            row_count = r.rowCount()
            col_count = r.columnCount()
            
            if row_count > 1 or col_count > 1:
                self.table.setSpan(top_row, left_col, row_count, col_count)
    
    def unmerge_cells(self):
        """Separar celdas combinadas"""
        current = self.table.currentItem()
        if current:
            row = self.table.currentRow()
            col = self.table.currentColumn()
            self.table.setSpan(row, col, 1, 1)
    
    def clear_cell_format(self):
        """Limpiar formato de celda"""
        from PyQt6.QtGui import QFont, QBrush, QColor
        
        current = self.table.currentItem()
        if current:
            # Restaurar formato por defecto
            font = QFont()
            current.setFont(font)
            current.setBackground(QBrush(QColor("#1a1a1a")))
            current.setForeground(QBrush(QColor("#e0e0e0")))
    
    def create_table(self):
        """Crear tabla con formato"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QSpinBox, QComboBox, QDialogButtonBox
        from PyQt6.QtGui import QColor, QBrush, QFont
        
        # Di√°logo para configurar la tabla
        dialog = QDialog(self)
        dialog.setWindowTitle("Crear Tabla")
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
            QSpinBox, QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        # Filas
        layout.addWidget(QLabel("N√∫mero de filas:"))
        rows_spin = QSpinBox()
        rows_spin.setMinimum(1)
        rows_spin.setMaximum(50)
        rows_spin.setValue(5)
        layout.addWidget(rows_spin)
        
        # Columnas
        layout.addWidget(QLabel("N√∫mero de columnas:"))
        cols_spin = QSpinBox()
        cols_spin.setMinimum(1)
        cols_spin.setMaximum(10)
        cols_spin.setValue(3)
        layout.addWidget(cols_spin)
        
        # Estilo
        layout.addWidget(QLabel("Estilo de tabla:"))
        style_combo = QComboBox()
        style_combo.addItems([
            "üîµ Cl√°sico Azul",
            "üü¢ Verde Profesional",
            "üü† Naranja Vibrante",
            "üü£ Morado Elegante",
            "üî¥ Rojo Corporativo",
            "‚ö´ Oscuro Minimalista",
            "‚ö™ Claro Moderno",
            "üåà Arco√≠ris",
            "üíº Ejecutivo",
            "üé® Pastel",
            "‚ö° Ne√≥n",
            "üèÜ Dorado Premium"
        ])
        layout.addWidget(style_combo)
        
        # Con bordes
        border_check = QCheckBox("Bordes visibles")
        border_check.setChecked(True)
        border_check.setStyleSheet("color: #ffffff;")
        layout.addWidget(border_check)
        
        # Bordes gruesos
        thick_border_check = QCheckBox("Bordes gruesos")
        thick_border_check.setChecked(False)
        thick_border_check.setStyleSheet("color: #ffffff;")
        layout.addWidget(thick_border_check)
        
        # Con encabezado
        header_check = QCheckBox("Incluir fila de encabezado")
        header_check.setChecked(True)
        header_check.setStyleSheet("color: #ffffff;")
        layout.addWidget(header_check)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Obtener celda actual
            current_row = self.table.currentRow()
            current_col = self.table.currentColumn()
            
            if current_row < 0 or current_col < 0:
                current_row = 0
                current_col = 0
            
            num_rows = rows_spin.value()
            num_cols = cols_spin.value()
            has_header = header_check.isChecked()
            style = style_combo.currentText()
            show_borders = border_check.isChecked()
            thick_borders = thick_border_check.isChecked()
            
            # Esquemas de color mejorados y m√°s visuales
            color_schemes = {
                "üîµ Cl√°sico Azul": {
                    "header": "#4a90e2", "header_text": "#ffffff",
                    "row1": "#e3f2fd", "row1_text": "#0d47a1",
                    "row2": "#bbdefb", "row2_text": "#0d47a1",
                    "border": "#2196F3", "border_width": 2
                },
                "üü¢ Verde Profesional": {
                    "header": "#4CAF50", "header_text": "#ffffff",
                    "row1": "#e8f5e9", "row1_text": "#1b5e20",
                    "row2": "#c8e6c9", "row2_text": "#1b5e20",
                    "border": "#388E3C", "border_width": 2
                },
                "üü† Naranja Vibrante": {
                    "header": "#FF9800", "header_text": "#ffffff",
                    "row1": "#fff3e0", "row1_text": "#e65100",
                    "row2": "#ffe0b2", "row2_text": "#e65100",
                    "border": "#F57C00", "border_width": 2
                },
                "üü£ Morado Elegante": {
                    "header": "#9C27B0", "header_text": "#ffffff",
                    "row1": "#f3e5f5", "row1_text": "#4a148c",
                    "row2": "#e1bee7", "row2_text": "#4a148c",
                    "border": "#7B1FA2", "border_width": 2
                },
                "üî¥ Rojo Corporativo": {
                    "header": "#e53935", "header_text": "#ffffff",
                    "row1": "#ffebee", "row1_text": "#b71c1c",
                    "row2": "#ffcdd2", "row2_text": "#b71c1c",
                    "border": "#c62828", "border_width": 2
                },
                "‚ö´ Oscuro Minimalista": {
                    "header": "#212121", "header_text": "#ffffff",
                    "row1": "#424242", "row1_text": "#ffffff",
                    "row2": "#616161", "row2_text": "#ffffff",
                    "border": "#9e9e9e", "border_width": 1
                },
                "‚ö™ Claro Moderno": {
                    "header": "#fafafa", "header_text": "#212121",
                    "row1": "#ffffff", "row1_text": "#424242",
                    "row2": "#f5f5f5", "row2_text": "#424242",
                    "border": "#bdbdbd", "border_width": 1
                },
                "üåà Arco√≠ris": {
                    "header": "#e91e63", "header_text": "#ffffff",
                    "row1": "#fff9c4", "row1_text": "#f57f17",
                    "row2": "#b2dfdb", "row2_text": "#00695c",
                    "border": "#7e57c2", "border_width": 2
                },
                "üíº Ejecutivo": {
                    "header": "#263238", "header_text": "#ffffff",
                    "row1": "#eceff1", "row1_text": "#263238",
                    "row2": "#cfd8dc", "row2_text": "#263238",
                    "border": "#546e7a", "border_width": 2
                },
                "üé® Pastel": {
                    "header": "#ba68c8", "header_text": "#ffffff",
                    "row1": "#f8bbd0", "row1_text": "#880e4f",
                    "row2": "#f48fb1", "row2_text": "#880e4f",
                    "border": "#ec407a", "border_width": 1
                },
                "‚ö° Ne√≥n": {
                    "header": "#00e676", "header_text": "#000000",
                    "row1": "#1de9b6", "row1_text": "#000000",
                    "row2": "#00bfa5", "row2_text": "#000000",
                    "border": "#00e676", "border_width": 3
                },
                "üèÜ Dorado Premium": {
                    "header": "#ffd700", "header_text": "#000000",
                    "row1": "#fff8dc", "row1_text": "#8b4513",
                    "row2": "#ffe4b5", "row2_text": "#8b4513",
                    "border": "#daa520", "border_width": 3
                }
            }
            
            colors = color_schemes.get(style, color_schemes["üîµ Cl√°sico Azul"])
            border_width = colors["border_width"]
            if thick_borders:
                border_width = 3
            
            # Crear tabla con bordes reales y formato visual
            from PyQt6.QtCore import Qt
            
            for row in range(num_rows):
                for col in range(num_cols):
                    cell_row = current_row + row
                    cell_col = current_col + col
                    
                    item = self.table.item(cell_row, cell_col)
                    if not item:
                        item = QTableWidgetItem()
                        self.table.setItem(cell_row, cell_col, item)
                    
                    # Aplicar formato
                    font = QFont()
                    font.setPointSize(10)
                    
                    if has_header and row == 0:
                        # Encabezado con formato especial
                        item.setBackground(QBrush(QColor(colors["header"])))
                        item.setForeground(QBrush(QColor(colors["header_text"])))
                        font.setBold(True)
                        font.setPointSize(11)
                        item.setFont(font)
                        item.setTextAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
                        
                        # Texto de ejemplo para encabezados
                        if not item.text():
                            item.setText(f"Columna {col+1}")
                    else:
                        # Alternar colores de filas con contraste
                        actual_row = row - (1 if has_header else 0)
                        if actual_row % 2 == 0:
                            item.setBackground(QBrush(QColor(colors["row1"])))
                            item.setForeground(QBrush(QColor(colors["row1_text"])))
                        else:
                            item.setBackground(QBrush(QColor(colors["row2"])))
                            item.setForeground(QBrush(QColor(colors["row2_text"])))
                        item.setFont(font)
                        item.setTextAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
                    
                    # Los bordes se aplicar√°n mediante el grid de QTableWidget
                    # que ya est√° configurado m√°s abajo
            
            # Aplicar bordes a toda la tabla usando el estilo de QTableWidget
            if show_borders:
                self.apply_table_borders(current_row, current_col, num_rows, num_cols, colors["border"], border_width)
            
            QMessageBox.information(
                self,
                "‚ú® Tabla Creada",
                f"Tabla de {num_rows}x{num_cols} creada exitosamente\n\nEstilo: {style}\nBordes: {'S√≠' if show_borders else 'No'}"
            )
    
    def apply_table_borders(self, start_row, start_col, num_rows, num_cols, border_color, border_width):
        """Aplicar bordes visuales a una tabla (solo al rango espec√≠fico)"""
        # Ajustar el tama√±o SOLO de las celdas del rango de la tabla
        for row in range(start_row, start_row + num_rows):
            self.table.setRowHeight(row, 35)  # Altura ligeramente mayor
        
        for col in range(start_col, start_col + num_cols):
            self.table.setColumnWidth(col, 120)  # Ancho ligeramente mayor
        
        # Asegurar que el grid est√© visible (esto es global pero necesario)
        self.table.setShowGrid(True)
        
        # Para bordes m√°s visuales, podemos agregar un indicador visual a cada celda del rango
        # usando el estilo de fondo ligeramente modificado en los bordes
    
    def create_chart(self):
        """Crear gr√°fico basado en datos seleccionados"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QComboBox, QDialogButtonBox, QMessageBox
        
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Selecciona un rango de datos para crear un gr√°fico"
            )
            return
        
        # Di√°logo para configurar el gr√°fico
        dialog = QDialog(self)
        dialog.setWindowTitle("Crear Gr√°fico")
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
            QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Tipo de gr√°fico:"))
        chart_type = QComboBox()
        chart_type.addItems([
            "üìä Gr√°fico de barras",
            "üìà Gr√°fico de l√≠neas",
            "ü•ß Gr√°fico circular",
            "üìâ Gr√°fico de √°rea"
        ])
        layout.addWidget(chart_type)
        
        # Botones
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_type = chart_type.currentText()
            
            # Extraer datos del rango seleccionado
            r = ranges[0]
            data = []
            labels = []
            
            for row in range(r.topRow(), r.bottomRow() + 1):
                for col in range(r.leftColumn(), r.rightColumn() + 1):
                    item = self.table.item(row, col)
                    if item and item.text():
                        try:
                            value = float(item.text())
                            data.append(value)
                            labels.append(f"{chr(65 + col)}{row + 1}")
                        except:
                            labels.append(item.text())
            
            if data:
                self.show_chart_dialog(selected_type, data, labels)
            else:
                QMessageBox.warning(
                    self,
                    "Sin datos",
                    "No se encontraron datos num√©ricos en la selecci√≥n"
                )
    
    def show_chart_dialog(self, chart_type, data, labels):
        """Mostrar di√°logo con gr√°fico simple"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel
        from PyQt6.QtGui import QPainter, QColor, QPen
        from PyQt6.QtCore import Qt, QRect
        
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Gr√°fico - {chart_type}")
        dialog.setMinimumSize(600, 400)
        dialog.setStyleSheet("QDialog { background-color: #f3f3f3; }")
        
        layout = QVBoxLayout(dialog)
        
        # T√≠tulo
        title = QLabel(chart_type)
        title.setStyleSheet("color: #ffffff; font-size: 14pt; font-weight: bold; padding: 10px;")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)
        
        # Widget de gr√°fico simple (visualizaci√≥n de barras)
        chart_widget = SimpleChartWidget(data, labels, chart_type)
        layout.addWidget(chart_widget)
        
        # Informaci√≥n
        info = QLabel(f"Datos: {len(data)} valores\nRango: {min(data):.2f} - {max(data):.2f}\nPromedio: {sum(data)/len(data):.2f}")
        info.setStyleSheet("color: #aaaaaa; font-size: 9pt; padding: 10px;")
        layout.addWidget(info)
        
        dialog.exec()
    
    def export_data(self):
        """Exportar datos a CSV o Excel"""
        from PyQt6.QtWidgets import QFileDialog, QMessageBox
        
        file_name, filter_type = QFileDialog.getSaveFileName(
            self,
            "Exportar Hoja de C√°lculo",
            "",
            "Archivo CSV (*.csv);;Archivo de Texto (*.txt);;Archivo HTML (*.html)"
        )
        
        if not file_name:
            return
        
        try:
            if file_name.endswith('.csv') or filter_type.startswith("Archivo CSV"):
                self.export_to_csv(file_name)
            elif file_name.endswith('.txt') or filter_type.startswith("Archivo de Texto"):
                self.export_to_txt(file_name)
            elif file_name.endswith('.html') or filter_type.startswith("Archivo HTML"):
                self.export_to_html(file_name)
            else:
                file_name += '.csv'
                self.export_to_csv(file_name)
            
            QMessageBox.information(
                self,
                "Exportaci√≥n exitosa",
                f"Datos exportados a:\n{file_name}"
            )
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de exportaci√≥n",
                f"No se pudo exportar el archivo:\n{str(e)}"
            )
    
    def export_to_csv(self, file_name):
        """Exportar a formato CSV"""
        import csv
        
        with open(file_name, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            for row in range(self.table.rowCount()):
                row_data = []
                for col in range(self.table.columnCount()):
                    item = self.table.item(row, col)
                    if item:
                        row_data.append(item.text())
                    else:
                        row_data.append('')
                
                # Solo exportar filas que tengan al menos un dato
                if any(row_data):
                    writer.writerow(row_data)
    
    def export_to_txt(self, file_name):
        """Exportar a formato TXT"""
        with open(file_name, 'w', encoding='utf-8') as f:
            for row in range(self.table.rowCount()):
                row_data = []
                for col in range(self.table.columnCount()):
                    item = self.table.item(row, col)
                    if item:
                        row_data.append(item.text())
                    else:
                        row_data.append('')
                
                if any(row_data):
                    f.write('\t'.join(row_data) + '\n')
    
    def export_to_html(self, file_name):
        """Exportar a formato HTML"""
        with open(file_name, 'w', encoding='utf-8') as f:
            f.write('<!DOCTYPE html>\n')
            f.write('<html>\n<head>\n')
            f.write('<meta charset="UTF-8">\n')
            f.write(f'<title>Hoja de C√°lculo - {self.current_sheet}</title>\n')
            f.write('<style>\n')
            f.write('table { border-collapse: collapse; width: 100%; }\n')
            f.write('th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n')
            f.write('th { background-color: #217346; color: white; }\n')
            f.write('tr:nth-child(even) { background-color: #f2f2f2; }\n')
            f.write('</style>\n</head>\n<body>\n')
            f.write(f'<h1>Hoja: {self.current_sheet}</h1>\n')
            f.write('<table>\n')
            
            for row in range(self.table.rowCount()):
                row_data = []
                for col in range(self.table.columnCount()):
                    item = self.table.item(row, col)
                    if item:
                        row_data.append(item.text())
                    else:
                        row_data.append('')
                
                if any(row_data):
                    f.write('<tr>\n')
                    for data in row_data:
                        f.write(f'<td>{data}</td>\n')
                    f.write('</tr>\n')
            
            f.write('</table>\n</body>\n</html>')
    
    def import_data(self):
        """Importar datos desde CSV"""
        from PyQt6.QtWidgets import QFileDialog, QMessageBox
        
        file_name, _ = QFileDialog.getOpenFileName(
            self,
            "Importar Datos",
            "",
            "Archivo CSV (*.csv);;Archivo de Texto (*.txt);;Todos los archivos (*.*)"
        )
        
        if not file_name:
            return
        
        try:
            import csv
            
            with open(file_name, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                
                self.table.blockSignals(True)
                
                for row_idx, row_data in enumerate(reader):
                    for col_idx, cell_data in enumerate(row_data):
                        if row_idx < self.table.rowCount() and col_idx < self.table.columnCount():
                            item = self.table.item(row_idx, col_idx)
                            if not item:
                                item = QTableWidgetItem()
                                self.table.setItem(row_idx, col_idx, item)
                            item.setText(cell_data)
                
                self.table.blockSignals(False)
            
            QMessageBox.information(
                self,
                "Importaci√≥n exitosa",
                f"Datos importados desde:\n{file_name}"
            )
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de importaci√≥n",
                f"No se pudo importar el archivo:\n{str(e)}"
            )
    
    def show_conditional_format(self):
        """Mostrar di√°logo de formato condicional"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QComboBox, QLineEdit, QDialogButtonBox
        from PyQt6.QtGui import QColor, QBrush
        
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Selecciona un rango de celdas para aplicar formato condicional"
            )
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Formato Condicional")
        dialog.setMinimumWidth(350)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
                font-family: 'Segoe UI', 'Arial', sans-serif;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
            QLineEdit, QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 3px;
                padding: 6px;
                font-size: 10pt;
            }
            QLineEdit:focus, QComboBox:focus {
                border: 1px solid #217346;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Regla de formato:"))
        rule_combo = QComboBox()
        rule_combo.addItems([
            "Mayor que...",
            "Menor que...",
            "Entre...",
            "Igual a...",
            "Contiene texto...",
            "Duplicados",
            "√önicos",
            "Top 10",
            "Barra de datos",
            "Escala de colores"
        ])
        layout.addWidget(rule_combo)
        
        layout.addWidget(QLabel("Valor:"))
        value_input = QLineEdit()
        value_input.setPlaceholderText("Ingresa un valor...")
        layout.addWidget(value_input)
        
        layout.addWidget(QLabel("Formato:"))
        format_combo = QComboBox()
        format_combo.addItems([
            "üü¢ Verde claro",
            "üî¥ Rojo claro",
            "üü° Amarillo claro",
            "üîµ Azul claro",
            "üü† Naranja claro",
            "üü£ Morado claro",
            "‚¨õ Negrita",
            "üé® Personalizado"
        ])
        layout.addWidget(format_combo)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            rule = rule_combo.currentText()
            value = value_input.text()
            format_type = format_combo.currentText()
            
            self.apply_conditional_format(ranges[0], rule, value, format_type)
    
    def apply_conditional_format(self, cell_range, rule, value, format_type):
        """Aplicar formato condicional al rango"""
        from PyQt6.QtGui import QColor, QBrush, QFont
        
        # Mapeo de colores
        colors = {
            "üü¢ Verde claro": "#c8e6c9",
            "üî¥ Rojo claro": "#ffcdd2",
            "üü° Amarillo claro": "#fff9c4",
            "üîµ Azul claro": "#bbdefb",
            "üü† Naranja claro": "#ffe0b2",
            "üü£ Morado claro": "#e1bee7"
        }
        
        count = 0
        
        for row in range(cell_range.topRow(), cell_range.bottomRow() + 1):
            for col in range(cell_range.leftColumn(), cell_range.rightColumn() + 1):
                item = self.table.item(row, col)
                if item and item.text():
                    apply_format = False
                    
                    try:
                        # Evaluar regla
                        if rule == "Mayor que...":
                            if float(item.text()) > float(value):
                                apply_format = True
                        elif rule == "Menor que...":
                            if float(item.text()) < float(value):
                                apply_format = True
                        elif rule == "Igual a...":
                            if item.text() == value:
                                apply_format = True
                        elif rule == "Contiene texto...":
                            if value.lower() in item.text().lower():
                                apply_format = True
                        elif rule == "Escala de colores":
                            # Aplicar gradiente de colores
                            apply_format = True
                        
                        # Aplicar formato si cumple la condici√≥n
                        if apply_format:
                            if format_type in colors:
                                item.setBackground(QBrush(QColor(colors[format_type])))
                                count += 1
                            elif format_type == "‚¨õ Negrita":
                                font = item.font()
                                font.setBold(True)
                                item.setFont(font)
                                count += 1
                    except:
                        pass
        
        QMessageBox.information(
            self,
            "Formato aplicado",
            f"Formato condicional aplicado a {count} celdas"
        )
    
    def show_data_validation(self):
        """Mostrar di√°logo de validaci√≥n de datos"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QComboBox, QLineEdit, QDialogButtonBox
        
        current = self.table.currentItem()
        if not current:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Selecciona una celda para aplicar validaci√≥n de datos"
            )
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Validaci√≥n de Datos")
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
            }
            QLabel {
                color: #333333;
                font-size: 10pt;
                padding: 5px;
            }
            QLineEdit, QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 5px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        layout.addWidget(QLabel("Tipo de validaci√≥n:"))
        validation_type = QComboBox()
        validation_type.addItems([
            "N√∫mero entero",
            "N√∫mero decimal",
            "Lista de valores",
            "Fecha",
            "Hora",
            "Longitud de texto",
            "Personalizado"
        ])
        layout.addWidget(validation_type)
        
        layout.addWidget(QLabel("Criterio:"))
        criteria = QComboBox()
        criteria.addItems([
            "Entre",
            "No entre",
            "Igual a",
            "Diferente de",
            "Mayor que",
            "Menor que",
            "Mayor o igual que",
            "Menor o igual que"
        ])
        layout.addWidget(criteria)
        
        layout.addWidget(QLabel("Valores (separados por coma):"))
        values_input = QLineEdit()
        values_input.setPlaceholderText("Ej: 1,100 o S√≠,No,Quiz√°s")
        layout.addWidget(values_input)
        
        layout.addWidget(QLabel("Mensaje de entrada:"))
        message_input = QLineEdit()
        message_input.setPlaceholderText("Mensaje opcional al seleccionar la celda")
        layout.addWidget(message_input)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            QMessageBox.information(
                self,
                "Validaci√≥n configurada",
                f"Validaci√≥n de datos configurada\n\nTipo: {validation_type.currentText()}\nCriterio: {criteria.currentText()}"
            )
    
    def show_templates(self):
        """Mostrar plantillas predefinidas"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QListWidget, QDialogButtonBox, QListWidgetItem
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Plantillas de Hojas de C√°lculo")
        dialog.setMinimumSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #f3f3f3;
            }
            QLabel {
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                padding: 10px;
            }
            QListWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                border-radius: 4px;
                padding: 5px;
                font-size: 10pt;
            }
            QListWidget::item {
                padding: 10px;
                border-radius: 4px;
                margin: 2px;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:selected {
                background-color: #217346;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        
        title = QLabel("Selecciona una plantilla para comenzar:")
        layout.addWidget(title)
        
        templates_list = QListWidget()
        
        templates = [
            "üí∞ Presupuesto Personal",
            "üìä Registro de Gastos",
            "üìÖ Planificador Mensual",
            "üìà An√°lisis de Ventas",
            "üìù Lista de Tareas (To-Do)",
            "üéØ Seguimiento de Objetivos",
            "üíº Factura Comercial",
            "üì¶ Inventario de Productos",
            "üë• Lista de Contactos",
            "‚è∞ Registro de Horas",
            "üèãÔ∏è Seguimiento de Ejercicios",
            "üìö Control de Lectura",
            "üçΩÔ∏è Planificador de Men√∫s",
            "üí≥ Control de Tarjetas de Cr√©dito",
            "üéì Registro de Calificaciones"
        ]
        
        for template in templates:
            templates_list.addItem(template)
        
        layout.addWidget(templates_list)
        
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.setStyleSheet("""
            QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            selected_items = templates_list.selectedItems()
            if selected_items:
                template_name = selected_items[0].text()
                self.load_template(template_name)
    
    def load_template(self, template_name):
        """Cargar plantilla seleccionada"""
        from PyQt6.QtGui import QFont, QColor, QBrush
        
        # Limpiar tabla
        self.table.blockSignals(True)
        self.table.clearContents()
        
        # Plantillas predefinidas
        if "üí∞ Presupuesto Personal" in template_name:
            # Encabezados
            headers = ["Categor√≠a", "Presupuestado", "Gastado", "Diferencia", "%"]
            for col, header in enumerate(headers):
                item = QTableWidgetItem(header)
                font = QFont()
                font.setBold(True)
                item.setFont(font)
                item.setBackground(QBrush(QColor("#4a90e2")))
                item.setForeground(QBrush(QColor("#ffffff")))
                self.table.setItem(0, col, item)
            
            # Categor√≠as
            categories = ["Vivienda", "Alimentaci√≥n", "Transporte", "Entretenimiento", "Ahorros", "TOTAL"]
            for row, category in enumerate(categories, start=1):
                item = QTableWidgetItem(category)
                if category == "TOTAL":
                    font = QFont()
                    font.setBold(True)
                    item.setFont(font)
                self.table.setItem(row, 0, item)
                
                # F√≥rmulas para las √∫ltimas filas
                if category == "TOTAL":
                    for col in range(1, 4):
                        formula_item = QTableWidgetItem(f"=SUMA({chr(66+col)}2:{chr(66+col)}{row})")
                        self.table.setItem(row, col, formula_item)
        
        elif "üìä Registro de Gastos" in template_name:
            headers = ["Fecha", "Descripci√≥n", "Categor√≠a", "Monto", "M√©todo de Pago"]
            for col, header in enumerate(headers):
                item = QTableWidgetItem(header)
                font = QFont()
                font.setBold(True)
                item.setFont(font)
                item.setBackground(QBrush(QColor("#4CAF50")))
                item.setForeground(QBrush(QColor("#ffffff")))
                self.table.setItem(0, col, item)
        
        elif "üìÖ Planificador Mensual" in template_name:
            headers = ["D√≠a", "Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado", "Domingo"]
            for col, header in enumerate(headers):
                item = QTableWidgetItem(header)
                font = QFont()
                font.setBold(True)
                item.setFont(font)
                item.setBackground(QBrush(QColor("#9C27B0")))
                item.setForeground(QBrush(QColor("#ffffff")))
                self.table.setItem(0, col, item)
        
        elif "üìà An√°lisis de Ventas" in template_name:
            headers = ["Producto", "Enero", "Febrero", "Marzo", "Total", "Promedio"]
            for col, header in enumerate(headers):
                item = QTableWidgetItem(header)
                font = QFont()
                font.setBold(True)
                item.setFont(font)
                item.setBackground(QBrush(QColor("#FF9800")))
                item.setForeground(QBrush(QColor("#ffffff")))
                self.table.setItem(0, col, item)
        
        elif "üìù Lista de Tareas" in template_name:
            headers = ["‚úì", "Tarea", "Prioridad", "Fecha L√≠mite", "Estado", "Notas"]
            for col, header in enumerate(headers):
                item = QTableWidgetItem(header)
                font = QFont()
                font.setBold(True)
                item.setFont(font)
                item.setBackground(QBrush(QColor("#2196F3")))
                item.setForeground(QBrush(QColor("#ffffff")))
                self.table.setItem(0, col, item)
        
        self.table.blockSignals(False)
        
        QMessageBox.information(
            self,
            "Plantilla cargada",
            f"Plantilla '{template_name}' cargada exitosamente.\n\nPuedes comenzar a editar los datos."
        )
    
    def add_comment(self):
        """Agregar comentario a una celda"""
        from PyQt6.QtWidgets import QInputDialog
        
        current = self.table.currentItem()
        if not current:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Selecciona una celda para agregar un comentario"
            )
            return
        
        comment, ok = QInputDialog.getMultiLineText(
            self,
            "Agregar Comentario",
            "Escribe un comentario para esta celda:",
            current.toolTip() if current.toolTip() else ""
        )
        
        if ok:
            if comment.strip():
                current.setToolTip(f"üí¨ {comment}")
                # Cambiar el color de fondo ligeramente para indicar que hay un comentario
                from PyQt6.QtGui import QColor, QBrush
                current_bg = current.background().color()
                # Si no tiene color de fondo, usar un amarillo claro
                if current_bg == QColor("#1a1a1a") or not current_bg.isValid():
                    current.setBackground(QBrush(QColor("#fffacd")))
                    current.setForeground(QBrush(QColor("#000000")))
                
                QMessageBox.information(
                    self,
                    "Comentario agregado",
                    "Comentario agregado exitosamente.\nPasa el mouse sobre la celda para verlo."
                )
            else:
                # Eliminar comentario si est√° vac√≠o
                current.setToolTip("")
    
    def autofill_down(self):
        """Autorrellenar hacia abajo (como Ctrl+D en Excel)"""
        ranges = self.table.selectedRanges()
        if not ranges:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Selecciona un rango de celdas (la primera celda ser√° copiada al resto)"
            )
            return
        
        r = ranges[0]
        
        # La primera celda del rango
        top_row = r.topRow()
        left_col = r.leftColumn()
        source_item = self.table.item(top_row, left_col)
        
        if not source_item:
            QMessageBox.information(
                self,
                "Celda vac√≠a",
                "La celda de origen est√° vac√≠a. No hay nada que copiar."
            )
            return
        
        count = 0
        
        # Si es una f√≥rmula, ajustar las referencias
        is_formula = source_item.text().startswith("=")
        
        # Copiar a todas las celdas del rango
        for row in range(r.topRow(), r.bottomRow() + 1):
            for col in range(r.leftColumn(), r.rightColumn() + 1):
                # Saltar la celda de origen
                if row == top_row and col == left_col:
                    continue
                
                item = self.table.item(row, col)
                if not item:
                    item = QTableWidgetItem()
                    self.table.setItem(row, col, item)
                
                if is_formula:
                    # Ajustar f√≥rmula (simplificado)
                    row_diff = row - top_row
                    col_diff = col - left_col
                    
                    # Por ahora, copiar la f√≥rmula tal cual
                    # En una implementaci√≥n completa, ajustar√≠amos las referencias
                    item.setText(source_item.text())
                else:
                    # Copiar valor
                    item.setText(source_item.text())
                    
                    # Copiar formato
                    item.setFont(source_item.font())
                    item.setForeground(source_item.foreground())
                    item.setBackground(source_item.background())
                    item.setTextAlignment(source_item.textAlignment())
                
                count += 1
        
        QMessageBox.information(
            self,
            "Autorrellenado completo",
            f"Se copiaron los datos a {count} celdas"
        )
    
    def show_context_menu(self, position):
        """Mostrar men√∫ contextual en la tabla"""
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #c0c0c0;
                padding: 5px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 4px;
            }
            QMenu::item:selected {
                background-color: #217346;
                color: #ffffff;
            }
            QMenu::separator {
                height: 1px;
                background: #e0e0e0;
                margin: 5px 10px;
            }
        """)
        
        # Acciones de edici√≥n
        copy_action = menu.addAction("üìã Copiar")
        copy_action.triggered.connect(self.copy_cell)
        
        paste_action = menu.addAction("üìÑ Pegar")
        paste_action.triggered.connect(self.paste_cell)
        
        cut_action = menu.addAction("‚úÇÔ∏è Cortar")
        cut_action.triggered.connect(self.cut_cell)
        
        menu.addSeparator()
        
        # Acciones de fila/columna
        insert_row_action = menu.addAction("‚ûï Insertar fila")
        insert_row_action.triggered.connect(self.insert_row)
        
        insert_col_action = menu.addAction("‚ûï Insertar columna")
        insert_col_action.triggered.connect(self.insert_column)
        
        menu.addSeparator()
        
        delete_row_action = menu.addAction("‚ùå Eliminar fila")
        delete_row_action.triggered.connect(self.delete_row)
        
        delete_col_action = menu.addAction("‚ùå Eliminar columna")
        delete_col_action.triggered.connect(self.delete_column)
        
        menu.addSeparator()
        
        # Formato
        format_action = menu.addAction("üé® Formato de celda...")
        format_action.triggered.connect(self.show_format_menu)
        
        # Tabla
        table_action = menu.addAction("üìä Crear tabla...")
        table_action.triggered.connect(self.create_table)
        
        # Gr√°fico
        chart_action = menu.addAction("üìà Crear gr√°fico...")
        chart_action.triggered.connect(self.create_chart)
        
        menu.addSeparator()
        
        # Nuevas opciones avanzadas
        comment_action = menu.addAction("üí¨ Agregar comentario")
        comment_action.triggered.connect(self.add_comment)
        
        autofill_action = menu.addAction("‚Üì Autorrellenar hacia abajo")
        autofill_action.triggered.connect(self.autofill_down)
        
        autofill_right_action = menu.addAction("‚Üí Autorrellenar hacia derecha")
        autofill_right_action.triggered.connect(self.autofill_right)
        
        fill_series_action = menu.addAction("üî¢ Rellenar serie...")
        fill_series_action.triggered.connect(self.fill_series)
        
        menu.addSeparator()
        
        # Submen√∫ de Columna/Fila
        column_menu = menu.addMenu("üìä Columna")
        column_menu.addAction("Autoajustar ancho").triggered.connect(self.autofit_columns)
        column_menu.addAction("Establecer ancho...").triggered.connect(self.set_column_width_dialog)
        column_menu.addAction("Ocultar columna").triggered.connect(self.hide_column)
        column_menu.addAction("Mostrar todas").triggered.connect(self.show_all_columns)
        column_menu.addAction("Seleccionar columna").triggered.connect(self.select_column)
        
        row_menu = menu.addMenu("üìã Fila")
        row_menu.addAction("Autoajustar alto").triggered.connect(self.autofit_rows)
        row_menu.addAction("Establecer alto...").triggered.connect(self.set_row_height_dialog)
        row_menu.addAction("Ocultar fila").triggered.connect(self.hide_row)
        row_menu.addAction("Mostrar todas").triggered.connect(self.show_all_rows)
        row_menu.addAction("Seleccionar fila").triggered.connect(self.select_row)
        
        menu.addSeparator()
        
        # Submen√∫ de Insertar
        insert_menu = menu.addMenu("üìÖ Insertar")
        insert_menu.addAction("Fecha actual").triggered.connect(self.insert_current_date)
        insert_menu.addAction("Hora actual").triggered.connect(self.insert_current_time)
        insert_menu.addAction("Fecha y hora").triggered.connect(self.insert_datetime)
        insert_menu.addAction("S√≠mbolo...").triggered.connect(self.insert_symbol)
        insert_menu.addAction("Hiperv√≠nculo...").triggered.connect(self.insert_hyperlink)
        
        menu.addSeparator()
        
        # M√°s opciones
        transpose_action = menu.addAction("‚áÑ Transponer")
        transpose_action.triggered.connect(self.transpose_selection)
        
        stats_action = menu.addAction("üìä Ver estad√≠sticas")
        stats_action.triggered.connect(self.calculate_selection_info)
        
        menu.addSeparator()
        
        conditional_action = menu.addAction("üéØ Formato condicional...")
        conditional_action.triggered.connect(self.show_conditional_format)
        
        validation_action = menu.addAction("‚úì Validaci√≥n de datos...")
        validation_action.triggered.connect(self.show_data_validation)
        
        menu.exec(self.table.viewport().mapToGlobal(position))
    
    def copy_cell(self):
        """Copiar celda al portapapeles"""
        current = self.table.currentItem()
        if current:
            from PyQt6.QtWidgets import QApplication
            clipboard = QApplication.clipboard()
            clipboard.setText(current.text())
    
    def paste_cell(self):
        """Pegar desde portapapeles"""
        current = self.table.currentItem()
        if current:
            from PyQt6.QtWidgets import QApplication
            clipboard = QApplication.clipboard()
            current.setText(clipboard.text())
    
    def cut_cell(self):
        """Cortar celda"""
        current = self.table.currentItem()
        if current:
            from PyQt6.QtWidgets import QApplication
            clipboard = QApplication.clipboard()
            clipboard.setText(current.text())
            current.setText("")
    
    def insert_row(self):
        """Insertar nueva fila"""
        current_row = self.table.currentRow()
        if current_row >= 0:
            self.table.insertRow(current_row)
            QMessageBox.information(self, "Fila insertada", f"Nueva fila insertada en la posici√≥n {current_row + 1}")
    
    def insert_column(self):
        """Insertar nueva columna"""
        current_col = self.table.currentColumn()
        if current_col >= 0:
            self.table.insertColumn(current_col)
            # Actualizar encabezados
            column_headers = [chr(65 + i) if i < 26 else f"A{chr(65 + i - 26)}" for i in range(self.table.columnCount())]
            self.table.setHorizontalHeaderLabels(column_headers)
            QMessageBox.information(self, "Columna insertada", f"Nueva columna insertada en la posici√≥n {chr(65 + current_col)}")
    
    def delete_row(self):
        """Eliminar fila actual"""
        current_row = self.table.currentRow()
        if current_row >= 0:
            reply = QMessageBox.question(
                self,
                "Confirmar eliminaci√≥n",
                f"¬øEliminar la fila {current_row + 1}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.table.removeRow(current_row)
    
    def delete_column(self):
        """Eliminar columna actual"""
        current_col = self.table.currentColumn()
        if current_col >= 0:
            reply = QMessageBox.question(
                self,
                "Confirmar eliminaci√≥n",
                f"¬øEliminar la columna {chr(65 + current_col)}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.table.removeColumn(current_col)
                # Actualizar encabezados
                column_headers = [chr(65 + i) if i < 26 else f"A{chr(65 + i - 26)}" for i in range(self.table.columnCount())]
                self.table.setHorizontalHeaderLabels(column_headers)
        
    def create_status_bar(self):
        """Crear barra de estado (versi√≥n de compatibilidad)"""
        # Esta funci√≥n ya no se usa, se mantiene por compatibilidad
        # El panel inferior con pesta√±as reemplaza esta funcionalidad
        status_bar = QWidget()
        status_bar.setFixedHeight(0)  # Ocultar ya que usamos el panel inferior
        return status_bar
        
    def on_cell_selected(self, row, col, prev_row, prev_col):
        """Manejar selecci√≥n de celda"""
        if row >= 0 and col >= 0:
            cell_ref = self.get_cell_reference(row, col)
            
            # Actualizar barra de estado
            if hasattr(self, 'ready_label'):
                self.ready_label.setText(f"Celda: {cell_ref}")
            if hasattr(self, 'cell_info_label'):
                self.cell_info_label.setText(f"Celda: {cell_ref}")
            
            # Actualizar cuadro de nombre de celda
            self.cell_name_box.setText(cell_ref)
            
            # Actualizar botones de formato seg√∫n el estado de la celda actual
            item = self.table.item(row, col)
            if item and hasattr(self, 'bold_btn'):
                font = item.font()
                self.bold_btn.setChecked(font.bold())
                self.italic_btn.setChecked(font.italic())
                self.underline_btn.setChecked(font.underline())
            
            # Mostrar f√≥rmula en la barra de f√≥rmulas
            key = f"{self.current_sheet}:{cell_ref}"
            if key in self.formulas:
                self.formula_bar.setText(self.formulas[key])
            else:
                if item:
                    self.formula_bar.setText(item.text())
                else:
                    self.formula_bar.setText("")
                    
    def on_cell_changed(self, row, col):
        """Manejar cambio en celda con actualizaci√≥n autom√°tica"""
        item = self.table.item(row, col)
        if not item:
            return
            
        cell_ref = self.get_cell_reference(row, col)
        key = f"{self.current_sheet}:{cell_ref}"
        
        # Evitar recursi√≥n infinita
        if key in self.updating_cells:
            return
            
        self.updating_cells.add(key)
        
        try:
            text = item.text()
            
            # Si es una f√≥rmula, guardarla y registrar dependencias
            if text.startswith("="):
                self.formulas[key] = text
                
                # Registrar dependencias
                referenced_cells = self.extract_cell_references(text)
                self.dependencies[key] = referenced_cells
                
                # Evaluar y mostrar resultado
                result = self.evaluate_formula(text, cell_ref)
                self.table.blockSignals(True)
                item.setText(str(result))
                self.table.blockSignals(False)
            else:
                # Remover f√≥rmula y dependencias si existen
                if key in self.formulas:
                    del self.formulas[key]
                if key in self.dependencies:
                    del self.dependencies[key]
            
            # Actualizar celdas que dependen de esta
            self.update_dependent_cells(cell_ref)
            
            self.data_changed.emit()
            
        finally:
            self.updating_cells.discard(key)
    
    def extract_cell_references(self, formula):
        """Extraer todas las referencias de celdas de una f√≥rmula"""
        import re
        
        references = set()
        
        # Buscar rangos (A1:A10)
        ranges = re.findall(r"([A-Z]+\d+):([A-Z]+\d+)", formula.upper())
        for start_ref, end_ref in ranges:
            start_row, start_col = self.parse_cell_reference(start_ref)
            end_row, end_col = self.parse_cell_reference(end_ref)
            
            if start_row is not None and end_row is not None:
                for row in range(start_row, end_row + 1):
                    for col in range(start_col, end_col + 1):
                        references.add(self.get_cell_reference(row, col))
        
        # Buscar celdas individuales
        cells = re.findall(r"(?<![A-Z])([A-Z]+\d+)(?![A-Z\d:])", formula.upper())
        references.update(cells)
        
        return list(references)
    
    def update_dependent_cells(self, changed_cell_ref):
        """Actualizar todas las celdas que dependen de la celda modificada"""
        cells_to_update = []
        
        # Buscar celdas que dependen de la modificada
        for cell_key, deps in self.dependencies.items():
            if changed_cell_ref in deps:
                cells_to_update.append(cell_key)
        
        # Actualizar cada celda dependiente
        for cell_key in cells_to_update:
            if cell_key in self.formulas:
                # Extraer sheet y referencia
                parts = cell_key.split(":")
                if len(parts) == 2 and parts[0] == self.current_sheet:
                    cell_ref = parts[1]
                    row, col = self.parse_cell_reference(cell_ref)
                    
                    if row is not None:
                        formula = self.formulas[cell_key]
                        result = self.evaluate_formula(formula, cell_ref)
                        
                        item = self.table.item(row, col)
                        if not item:
                            item = QTableWidgetItem()
                            self.table.setItem(row, col, item)
                        
                        self.table.blockSignals(True)
                        item.setText(str(result))
                        self.table.blockSignals(False)
            
    def apply_formula(self):
        """Aplicar f√≥rmula desde la barra de f√≥rmulas"""
        current = self.table.currentItem()
        if current:
            text = self.formula_bar.text()
            current.setText(text)
            
    def get_cell_reference(self, row, col):
        """Obtener referencia de celda (ej: A1, B2)"""
        return f"{chr(65 + col)}{row + 1}"
        
    def parse_cell_reference(self, ref):
        """Parsear referencia de celda (A1 -> row, col)"""
        import re
        match = re.match(r"([A-Z]+)(\d+)", ref.upper())
        if match:
            col_letter = match.group(1)
            row_num = int(match.group(2))
            col = ord(col_letter) - 65
            row = row_num - 1
            return row, col
        return None, None
        
    def evaluate_formula(self, formula, current_cell=None):
        """Evaluar f√≥rmula tipo Excel con funciones avanzadas"""
        import re
        
        if not formula.startswith("="):
            return formula
            
        # Remover el signo =
        expression = formula[1:].strip()
        expr_upper = expression.upper()
        
        # Funciones matem√°ticas b√°sicas
        if expr_upper.startswith("SUMA(") or expr_upper.startswith("SUM("):
            return self.function_suma(expression)
        elif expr_upper.startswith("PROMEDIO(") or expr_upper.startswith("AVERAGE("):
            return self.function_promedio(expression)
        elif expr_upper.startswith("MAX("):
            return self.function_max(expression)
        elif expr_upper.startswith("MIN("):
            return self.function_min(expression)
        elif expr_upper.startswith("CONTAR(") or expr_upper.startswith("COUNT("):
            return self.function_contar(expression)
        
        # Funciones condicionales
        elif expr_upper.startswith("SI(") or expr_upper.startswith("IF("):
            return self.function_si(expression)
        elif expr_upper.startswith("CONTAR.SI(") or expr_upper.startswith("COUNTIF("):
            return self.function_contar_si(expression)
        elif expr_upper.startswith("SUMA.SI(") or expr_upper.startswith("SUMIF("):
            return self.function_suma_si(expression)
        
        # Funciones de texto
        elif expr_upper.startswith("CONCATENAR(") or expr_upper.startswith("CONCAT("):
            return self.function_concatenar(expression)
        elif expr_upper.startswith("IZQUIERDA(") or expr_upper.startswith("LEFT("):
            return self.function_izquierda(expression)
        elif expr_upper.startswith("DERECHA(") or expr_upper.startswith("RIGHT("):
            return self.function_derecha(expression)
        elif expr_upper.startswith("EXTRAE(") or expr_upper.startswith("MID("):
            return self.function_extrae(expression)
        elif expr_upper.startswith("LARGO(") or expr_upper.startswith("LEN("):
            return self.function_largo(expression)
        elif expr_upper.startswith("MAYUSC(") or expr_upper.startswith("UPPER("):
            return self.function_mayusc(expression)
        elif expr_upper.startswith("MINUSC(") or expr_upper.startswith("LOWER("):
            return self.function_minusc(expression)
        
        # Funciones de fecha y hora
        elif expr_upper.startswith("HOY(") or expr_upper.startswith("TODAY("):
            return self.function_hoy()
        elif expr_upper.startswith("AHORA(") or expr_upper.startswith("NOW("):
            return self.function_ahora()
        elif expr_upper.startswith("A√ëO(") or expr_upper.startswith("YEAR("):
            return self.function_a√±o(expression)
        elif expr_upper.startswith("MES(") or expr_upper.startswith("MONTH("):
            return self.function_mes(expression)
        elif expr_upper.startswith("DIA(") or expr_upper.startswith("DAY("):
            return self.function_dia(expression)
        
        # Funciones de b√∫squeda
        elif expr_upper.startswith("BUSCARV(") or expr_upper.startswith("VLOOKUP("):
            return self.function_buscarv(expression)
        
        # Funciones estad√≠sticas avanzadas
        elif expr_upper.startswith("MEDIANA(") or expr_upper.startswith("MEDIAN("):
            return self.function_mediana(expression)
        elif expr_upper.startswith("MODA(") or expr_upper.startswith("MODE("):
            return self.function_moda(expression)
        elif expr_upper.startswith("REDONDEAR(") or expr_upper.startswith("ROUND("):
            return self.function_redondear(expression)
        elif expr_upper.startswith("POTENCIA(") or expr_upper.startswith("POWER("):
            return self.function_potencia(expression)
        elif expr_upper.startswith("RAIZ(") or expr_upper.startswith("SQRT("):
            return self.function_raiz(expression)
        elif expr_upper.startswith("ABS("):
            return self.function_abs(expression)
        
        # Funciones l√≥gicas
        elif expr_upper.startswith("Y(") or expr_upper.startswith("AND("):
            return self.function_y(expression)
        elif expr_upper.startswith("O(") or expr_upper.startswith("OR("):
            return self.function_o(expression)
        elif expr_upper.startswith("NO(") or expr_upper.startswith("NOT("):
            return self.function_no(expression)
        
        # Funciones estad√≠sticas avanzadas (nuevas)
        elif expr_upper.startswith("VARIANZA(") or expr_upper.startswith("VAR("):
            return self.function_varianza(expression)
        elif expr_upper.startswith("DESVEST(") or expr_upper.startswith("STDEV("):
            return self.function_desvest(expression)
        elif expr_upper.startswith("PROMEDIO.SI(") or expr_upper.startswith("AVERAGEIF("):
            return self.function_promedio_si(expression)
        elif expr_upper.startswith("BUSCARH(") or expr_upper.startswith("HLOOKUP("):
            return self.function_buscarh(expression)
        elif expr_upper.startswith("CONTAR.BLANCO(") or expr_upper.startswith("COUNTBLANK("):
            return self.function_contar_blanco(expression)
        elif expr_upper.startswith("CONTARA(") or expr_upper.startswith("COUNTA("):
            return self.function_contara(expression)
        elif expr_upper.startswith("PRODUCTO(") or expr_upper.startswith("PRODUCT("):
            return self.function_producto(expression)
        elif expr_upper.startswith("ENTERO(") or expr_upper.startswith("INT("):
            return self.function_entero(expression)
        elif expr_upper.startswith("RESIDUO(") or expr_upper.startswith("MOD("):
            return self.function_residuo(expression)
        elif expr_upper.startswith("TRUNCAR(") or expr_upper.startswith("TRUNC("):
            return self.function_truncar(expression)
        elif expr_upper.startswith("ALEATORIO(") or expr_upper.startswith("RAND("):
            return self.function_aleatorio(expression)
        elif expr_upper.startswith("ALEATORIO.ENTRE(") or expr_upper.startswith("RANDBETWEEN("):
            return self.function_aleatorio_entre(expression)
        elif expr_upper.startswith("PI("):
            return self.function_pi(expression)
        elif expr_upper.startswith("SENO(") or expr_upper.startswith("SIN("):
            return self.function_seno(expression)
        elif expr_upper.startswith("COS(") or expr_upper.startswith("COSENO("):
            return self.function_coseno(expression)
        elif expr_upper.startswith("TAN(") or expr_upper.startswith("TANGENTE("):
            return self.function_tangente(expression)
        elif expr_upper.startswith("LOG("):
            return self.function_log(expression)
        elif expr_upper.startswith("LN("):
            return self.function_ln(expression)
        elif expr_upper.startswith("EXP("):
            return self.function_exp(expression)
        
        # Funciones de texto (nuevas)
        elif expr_upper.startswith("ESPACIOS(") or expr_upper.startswith("TRIM("):
            return self.function_espacios(expression)
        elif expr_upper.startswith("TEXTO(") or expr_upper.startswith("TEXT("):
            return self.function_texto(expression)
        elif expr_upper.startswith("VALOR(") or expr_upper.startswith("VALUE("):
            return self.function_valor(expression)
        elif expr_upper.startswith("SUSTITUIR(") or expr_upper.startswith("SUBSTITUTE("):
            return self.function_sustituir(expression)
        elif expr_upper.startswith("ENCONTRAR(") or expr_upper.startswith("FIND("):
            return self.function_encontrar(expression)
        elif expr_upper.startswith("REPETIR(") or expr_upper.startswith("REPT("):
            return self.function_repetir(expression)
        elif expr_upper.startswith("SI.ERROR(") or expr_upper.startswith("IFERROR("):
            return self.function_si_error(expression)
        
        else:
            # Intentar evaluar como expresi√≥n con referencias de celdas
            return self.evaluate_expression(expression)
            
    def function_suma(self, expr):
        """Funci√≥n SUMA/SUM"""
        values = self.extract_range_values(expr)
        try:
            return sum(float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit())
        except:
            return 0
            
    def function_promedio(self, expr):
        """Funci√≥n PROMEDIO/AVERAGE"""
        values = self.extract_range_values(expr)
        try:
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            return sum(numeric_values) / len(numeric_values) if numeric_values else 0
        except:
            return 0
            
    def function_max(self, expr):
        """Funci√≥n MAX"""
        values = self.extract_range_values(expr)
        try:
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            return max(numeric_values) if numeric_values else 0
        except:
            return 0
            
    def function_min(self, expr):
        """Funci√≥n MIN"""
        values = self.extract_range_values(expr)
        try:
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            return min(numeric_values) if numeric_values else 0
        except:
            return 0
            
    def function_contar(self, expr):
        """Funci√≥n CONTAR/COUNT"""
        values = self.extract_range_values(expr)
        return len([v for v in values if v])
        
    def function_si(self, expr):
        """Funci√≥n SI/IF"""
        import re
        # SI(condici√≥n; valor_si_verdadero; valor_si_falso)
        match = re.match(r"SI\((.*?);(.*?);(.*?)\)", expr.upper())
        if not match:
            match = re.match(r"IF\((.*?),(.*?),(.*?)\)", expr.upper())
        
        if match:
            condition = match.group(1).strip()
            true_value = match.group(2).strip()
            false_value = match.group(3).strip()
            
            # Evaluar condici√≥n
            try:
                if eval(condition):
                    return true_value
                else:
                    return false_value
            except:
                return "ERROR"
        return "ERROR"
    
    # ===== FUNCIONES CONDICIONALES AVANZADAS =====
    def function_contar_si(self, expr):
        """Funci√≥n CONTAR.SI/COUNTIF - Cuenta celdas que cumplen condici√≥n"""
        import re
        # CONTAR.SI(rango;criterio)
        match = re.match(r"(?:CONTAR\.SI|COUNTIF)\((.*?)[;,](.*?)\)", expr.upper())
        if not match:
            return 0
        
        values = self.extract_range_values(match.group(1))
        criterio = match.group(2).strip().strip('"')
        
        count = 0
        for val in values:
            try:
                if criterio.startswith(">") or criterio.startswith("<") or criterio.startswith("="):
                    if eval(f"{float(val)}{criterio}"):
                        count += 1
                elif str(val).upper() == criterio.upper():
                    count += 1
            except:
                pass
        return count
    
    def function_suma_si(self, expr):
        """Funci√≥n SUMA.SI/SUMIF - Suma celdas que cumplen condici√≥n"""
        import re
        # SUMA.SI(rango;criterio)
        match = re.match(r"(?:SUMA\.SI|SUMIF)\((.*?)[;,](.*?)\)", expr.upper())
        if not match:
            return 0
        
        values = self.extract_range_values(match.group(1))
        criterio = match.group(2).strip().strip('"')
        
        suma = 0
        for val in values:
            try:
                if criterio.startswith(">") or criterio.startswith("<") or criterio.startswith("="):
                    if eval(f"{float(val)}{criterio}"):
                        suma += float(val)
                elif str(val).upper() == criterio.upper():
                    suma += float(val)
            except:
                pass
        return suma
    
    # ===== FUNCIONES DE TEXTO =====
    def function_concatenar(self, expr):
        """Funci√≥n CONCATENAR/CONCAT"""
        import re
        # Extraer valores entre par√©ntesis
        match = re.match(r"(?:CONCATENAR|CONCAT)\((.*)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        parts = match.group(1).split(";")
        if len(parts) == 1:
            parts = match.group(1).split(",")
        
        result = ""
        for part in parts:
            part = part.strip().strip('"')
            # Si es una referencia de celda
            if re.match(r"[A-Z]+\d+", part.upper()):
                row, col = self.parse_cell_reference(part)
                if row is not None:
                    item = self.table.item(row, col)
                    if item:
                        result += item.text()
            else:
                result += part
        return result
    
    def function_izquierda(self, expr):
        """Funci√≥n IZQUIERDA/LEFT"""
        import re
        match = re.match(r"(?:IZQUIERDA|LEFT)\((.*?)[;,](\d+)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        num_chars = int(match.group(2))
        return text[:num_chars]
    
    def function_derecha(self, expr):
        """Funci√≥n DERECHA/RIGHT"""
        import re
        match = re.match(r"(?:DERECHA|RIGHT)\((.*?)[;,](\d+)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        num_chars = int(match.group(2))
        return text[-num_chars:]
    
    def function_extrae(self, expr):
        """Funci√≥n EXTRAE/MID"""
        import re
        match = re.match(r"(?:EXTRAE|MID)\((.*?)[;,](\d+)[;,](\d+)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        start = int(match.group(2)) - 1  # Excel usa base 1
        length = int(match.group(3))
        return text[start:start+length]
    
    def function_largo(self, expr):
        """Funci√≥n LARGO/LEN"""
        import re
        match = re.match(r"(?:LARGO|LEN)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        text = self.get_cell_value_or_text(match.group(1))
        return len(text)
    
    def function_mayusc(self, expr):
        """Funci√≥n MAYUSC/UPPER"""
        import re
        match = re.match(r"(?:MAYUSC|UPPER)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        return text.upper()
    
    def function_minusc(self, expr):
        """Funci√≥n MINUSC/LOWER"""
        import re
        match = re.match(r"(?:MINUSC|LOWER)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        return text.lower()
    
    def get_cell_value_or_text(self, ref):
        """Obtener valor de celda o devolver texto literal"""
        import re
        ref = ref.strip().strip('"')
        
        # Si es una referencia de celda
        if re.match(r"[A-Z]+\d+", ref.upper()):
            row, col = self.parse_cell_reference(ref)
            if row is not None:
                item = self.table.item(row, col)
                if item:
                    return item.text()
        return ref
    
    # ===== FUNCIONES DE FECHA Y HORA =====
    def function_hoy(self):
        """Funci√≥n HOY/TODAY"""
        from datetime import datetime
        return datetime.now().strftime("%d/%m/%Y")
    
    def function_ahora(self):
        """Funci√≥n AHORA/NOW"""
        from datetime import datetime
        return datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    
    def function_a√±o(self, expr):
        """Funci√≥n A√ëO/YEAR"""
        from datetime import datetime
        # Por simplicidad, devolver el a√±o actual
        return datetime.now().year
    
    def function_mes(self, expr):
        """Funci√≥n MES/MONTH"""
        from datetime import datetime
        return datetime.now().month
    
    def function_dia(self, expr):
        """Funci√≥n DIA/DAY"""
        from datetime import datetime
        return datetime.now().day
    
    # ===== FUNCIONES DE B√öSQUEDA =====
    def function_buscarv(self, expr):
        """Funci√≥n BUSCARV/VLOOKUP - B√∫squeda vertical"""
        import re
        # BUSCARV(valor_buscado;rango;columna;coincidencia_exacta)
        match = re.match(r"(?:BUSCARV|VLOOKUP)\((.*?)[;,](.*?)[;,](\d+)", expr, re.IGNORECASE)
        if not match:
            return "N/A"
        
        search_value = self.get_cell_value_or_text(match.group(1))
        range_expr = match.group(2)
        col_index = int(match.group(3))
        
        # Extraer rango
        range_match = re.search(r"([A-Z]+\d+):([A-Z]+\d+)", range_expr.upper())
        if not range_match:
            return "N/A"
        
        start_ref = range_match.group(1)
        end_ref = range_match.group(2)
        start_row, start_col = self.parse_cell_reference(start_ref)
        end_row, end_col = self.parse_cell_reference(end_ref)
        
        # Buscar en la primera columna del rango
        for row in range(start_row, end_row + 1):
            item = self.table.item(row, start_col)
            if item and item.text().upper() == search_value.upper():
                # Devolver valor de la columna especificada
                result_col = start_col + col_index - 1
                result_item = self.table.item(row, result_col)
                if result_item:
                    return result_item.text()
        
        return "N/A"
    
    # ===== FUNCIONES ESTAD√çSTICAS AVANZADAS =====
    def function_mediana(self, expr):
        """Funci√≥n MEDIANA/MEDIAN"""
        values = self.extract_range_values(expr)
        try:
            numeric_values = sorted([float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()])
            if not numeric_values:
                return 0
            n = len(numeric_values)
            if n % 2 == 0:
                return (numeric_values[n//2-1] + numeric_values[n//2]) / 2
            else:
                return numeric_values[n//2]
        except:
            return 0
    
    def function_moda(self, expr):
        """Funci√≥n MODA/MODE"""
        values = self.extract_range_values(expr)
        try:
            from collections import Counter
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            if numeric_values:
                counter = Counter(numeric_values)
                return counter.most_common(1)[0][0]
            return 0
        except:
            return 0
    
    def function_redondear(self, expr):
        """Funci√≥n REDONDEAR/ROUND"""
        import re
        match = re.match(r"(?:REDONDEAR|ROUND)\((.*?)[;,](\d+)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            decimals = int(match.group(2))
            return round(value, decimals)
        except:
            return 0
    
    def function_potencia(self, expr):
        """Funci√≥n POTENCIA/POWER"""
        import re
        match = re.match(r"(?:POTENCIA|POWER)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            base = float(self.get_cell_value_or_text(match.group(1)))
            exponente = float(self.get_cell_value_or_text(match.group(2)))
            return base ** exponente
        except:
            return 0
    
    def function_raiz(self, expr):
        """Funci√≥n RAIZ/SQRT"""
        import re
        import math
        match = re.match(r"(?:RAIZ|SQRT)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return math.sqrt(value)
        except:
            return 0
    
    def function_abs(self, expr):
        """Funci√≥n ABS - Valor absoluto"""
        import re
        match = re.match(r"ABS\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return abs(value)
        except:
            return 0
    
    # ===== FUNCIONES L√ìGICAS =====
    def function_y(self, expr):
        """Funci√≥n Y/AND - Todas las condiciones deben ser verdaderas"""
        import re
        match = re.match(r"(?:Y|AND)\((.*)\)", expr, re.IGNORECASE)
        if not match:
            return False
        
        conditions = match.group(1).split(";")
        if len(conditions) == 1:
            conditions = match.group(1).split(",")
        
        try:
            for condition in conditions:
                condition = condition.strip()
                if not eval(condition):
                    return False
            return True
        except:
            return False
    
    def function_o(self, expr):
        """Funci√≥n O/OR - Al menos una condici√≥n debe ser verdadera"""
        import re
        match = re.match(r"(?:O|OR)\((.*)\)", expr, re.IGNORECASE)
        if not match:
            return False
        
        conditions = match.group(1).split(";")
        if len(conditions) == 1:
            conditions = match.group(1).split(",")
        
        try:
            for condition in conditions:
                condition = condition.strip()
                if eval(condition):
                    return True
            return False
        except:
            return False
    
    def function_no(self, expr):
        """Funci√≥n NO/NOT - Invierte el valor l√≥gico"""
        import re
        match = re.match(r"(?:NO|NOT)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return False
        
        try:
            condition = match.group(1).strip()
            return not eval(condition)
        except:
            return False
    
    # ===== FUNCIONES ESTAD√çSTICAS AVANZADAS (NUEVAS) =====
    
    def function_varianza(self, expr):
        """Funci√≥n VARIANZA/VAR - Calcula la varianza de un rango"""
        values = self.extract_range_values(expr)
        try:
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            if len(numeric_values) < 2:
                return 0
            mean = sum(numeric_values) / len(numeric_values)
            variance = sum((x - mean) ** 2 for x in numeric_values) / (len(numeric_values) - 1)
            return round(variance, 6)
        except:
            return 0
    
    def function_desvest(self, expr):
        """Funci√≥n DESVEST/STDEV - Calcula la desviaci√≥n est√°ndar"""
        import math
        values = self.extract_range_values(expr)
        try:
            numeric_values = [float(v) for v in values if v and str(v).replace('.', '', 1).replace('-', '', 1).isdigit()]
            if len(numeric_values) < 2:
                return 0
            mean = sum(numeric_values) / len(numeric_values)
            variance = sum((x - mean) ** 2 for x in numeric_values) / (len(numeric_values) - 1)
            return round(math.sqrt(variance), 6)
        except:
            return 0
    
    def function_promedio_si(self, expr):
        """Funci√≥n PROMEDIO.SI/AVERAGEIF - Promedio condicional"""
        import re
        match = re.match(r"(?:PROMEDIO\.SI|AVERAGEIF)\((.*?)[;,](.*?)\)", expr.upper())
        if not match:
            return 0
        
        values = self.extract_range_values(match.group(1))
        criterio = match.group(2).strip().strip('"')
        
        matching_values = []
        for val in values:
            try:
                num_val = float(val)
                if criterio.startswith(">") or criterio.startswith("<") or criterio.startswith("="):
                    if eval(f"{num_val}{criterio}"):
                        matching_values.append(num_val)
                elif str(val).upper() == criterio.upper():
                    matching_values.append(num_val)
            except:
                pass
        
        if matching_values:
            return round(sum(matching_values) / len(matching_values), 2)
        return 0
    
    def function_buscarh(self, expr):
        """Funci√≥n BUSCARH/HLOOKUP - B√∫squeda horizontal"""
        import re
        match = re.match(r"(?:BUSCARH|HLOOKUP)\((.*?)[;,](.*?)[;,](\d+)", expr, re.IGNORECASE)
        if not match:
            return "N/A"
        
        search_value = self.get_cell_value_or_text(match.group(1))
        range_expr = match.group(2)
        row_index = int(match.group(3))
        
        range_match = re.search(r"([A-Z]+\d+):([A-Z]+\d+)", range_expr.upper())
        if not range_match:
            return "N/A"
        
        start_ref = range_match.group(1)
        end_ref = range_match.group(2)
        start_row, start_col = self.parse_cell_reference(start_ref)
        end_row, end_col = self.parse_cell_reference(end_ref)
        
        # Buscar en la primera fila del rango
        for col in range(start_col, end_col + 1):
            item = self.table.item(start_row, col)
            if item and item.text().upper() == search_value.upper():
                result_row = start_row + row_index - 1
                result_item = self.table.item(result_row, col)
                if result_item:
                    return result_item.text()
        
        return "N/A"
    
    def function_contar_blanco(self, expr):
        """Funci√≥n CONTAR.BLANCO/COUNTBLANK - Cuenta celdas vac√≠as"""
        import re
        match = re.search(r"([A-Z]+\d+):([A-Z]+\d+)", expr.upper())
        if not match:
            return 0
        
        start_ref = match.group(1)
        end_ref = match.group(2)
        start_row, start_col = self.parse_cell_reference(start_ref)
        end_row, end_col = self.parse_cell_reference(end_ref)
        
        count = 0
        for row in range(start_row, end_row + 1):
            for col in range(start_col, end_col + 1):
                item = self.table.item(row, col)
                if not item or not item.text():
                    count += 1
        return count
    
    def function_contara(self, expr):
        """Funci√≥n CONTARA/COUNTA - Cuenta celdas no vac√≠as"""
        values = self.extract_range_values(expr)
        return len([v for v in values if v and str(v).strip()])
    
    def function_producto(self, expr):
        """Funci√≥n PRODUCTO/PRODUCT - Multiplica todos los valores"""
        values = self.extract_range_values(expr)
        try:
            result = 1
            for v in values:
                if v:
                    result *= float(v)
            return result
        except:
            return 0
    
    def function_entero(self, expr):
        """Funci√≥n ENTERO/INT - Redondea hacia abajo al entero m√°s cercano"""
        import re
        import math
        match = re.match(r"(?:ENTERO|INT)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return math.floor(value)
        except:
            return 0
    
    def function_residuo(self, expr):
        """Funci√≥n RESIDUO/MOD - Devuelve el residuo de una divisi√≥n"""
        import re
        match = re.match(r"(?:RESIDUO|MOD)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            numero = float(self.get_cell_value_or_text(match.group(1)))
            divisor = float(self.get_cell_value_or_text(match.group(2)))
            return numero % divisor
        except:
            return 0
    
    def function_truncar(self, expr):
        """Funci√≥n TRUNCAR/TRUNC - Trunca un n√∫mero a entero"""
        import re
        import math
        match = re.match(r"(?:TRUNCAR|TRUNC)\((.*?)(?:[;,](\d+))?\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            decimals = int(match.group(2)) if match.group(2) else 0
            factor = 10 ** decimals
            return math.trunc(value * factor) / factor
        except:
            return 0
    
    def function_aleatorio(self, expr):
        """Funci√≥n ALEATORIO/RAND - Genera n√∫mero aleatorio entre 0 y 1"""
        import random
        return round(random.random(), 6)
    
    def function_aleatorio_entre(self, expr):
        """Funci√≥n ALEATORIO.ENTRE/RANDBETWEEN - N√∫mero aleatorio entre dos valores"""
        import re
        import random
        match = re.match(r"(?:ALEATORIO\.ENTRE|RANDBETWEEN)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            min_val = int(float(self.get_cell_value_or_text(match.group(1))))
            max_val = int(float(self.get_cell_value_or_text(match.group(2))))
            return random.randint(min_val, max_val)
        except:
            return 0
    
    def function_pi(self, expr):
        """Funci√≥n PI - Devuelve el valor de PI"""
        import math
        return round(math.pi, 10)
    
    def function_seno(self, expr):
        """Funci√≥n SENO/SIN - Calcula el seno de un √°ngulo"""
        import re
        import math
        match = re.match(r"(?:SENO|SIN)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return round(math.sin(value), 10)
        except:
            return 0
    
    def function_coseno(self, expr):
        """Funci√≥n COS - Calcula el coseno de un √°ngulo"""
        import re
        import math
        match = re.match(r"(?:COS|COSENO)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return round(math.cos(value), 10)
        except:
            return 0
    
    def function_tangente(self, expr):
        """Funci√≥n TAN - Calcula la tangente de un √°ngulo"""
        import re
        import math
        match = re.match(r"(?:TAN|TANGENTE)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return round(math.tan(value), 10)
        except:
            return 0
    
    def function_log(self, expr):
        """Funci√≥n LOG - Calcula el logaritmo"""
        import re
        import math
        match = re.match(r"LOG\((.*?)(?:[;,](.*?))?\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            base = float(self.get_cell_value_or_text(match.group(2))) if match.group(2) else 10
            return round(math.log(value, base), 10)
        except:
            return 0
    
    def function_ln(self, expr):
        """Funci√≥n LN - Calcula el logaritmo natural"""
        import re
        import math
        match = re.match(r"LN\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return round(math.log(value), 10)
        except:
            return 0
    
    def function_exp(self, expr):
        """Funci√≥n EXP - Calcula e elevado a una potencia"""
        import re
        import math
        match = re.match(r"EXP\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            return round(math.exp(value), 10)
        except:
            return 0
    
    def function_espacios(self, expr):
        """Funci√≥n ESPACIOS/TRIM - Elimina espacios extra"""
        import re
        match = re.match(r"(?:ESPACIOS|TRIM)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        return ' '.join(text.split())
    
    def function_texto(self, expr):
        """Funci√≥n TEXTO/TEXT - Convierte n√∫mero a texto con formato"""
        import re
        match = re.match(r"(?:TEXTO|TEXT)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        try:
            value = float(self.get_cell_value_or_text(match.group(1)))
            formato = match.group(2).strip().strip('"')
            
            if formato == "0":
                return str(int(value))
            elif formato == "0.00":
                return f"{value:.2f}"
            elif formato == "#,##0":
                return f"{value:,.0f}"
            elif formato == "#,##0.00":
                return f"{value:,.2f}"
            elif formato == "0%":
                return f"{value * 100:.0f}%"
            elif formato == "0.00%":
                return f"{value * 100:.2f}%"
            else:
                return str(value)
        except:
            return ""
    
    def function_valor(self, expr):
        """Funci√≥n VALOR/VALUE - Convierte texto a n√∫mero"""
        import re
        match = re.match(r"(?:VALOR|VALUE)\((.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        try:
            text = self.get_cell_value_or_text(match.group(1))
            # Limpiar el texto
            text = text.replace('$', '').replace(',', '').replace('%', '').strip()
            return float(text)
        except:
            return 0
    
    def function_sustituir(self, expr):
        """Funci√≥n SUSTITUIR/SUBSTITUTE - Reemplaza texto"""
        import re
        match = re.match(r"(?:SUSTITUIR|SUBSTITUTE)\((.*?)[;,](.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = self.get_cell_value_or_text(match.group(1))
        old_text = match.group(2).strip().strip('"')
        new_text = match.group(3).strip().strip('"')
        
        return text.replace(old_text, new_text)
    
    def function_encontrar(self, expr):
        """Funci√≥n ENCONTRAR/FIND - Encuentra posici√≥n de texto"""
        import re
        match = re.match(r"(?:ENCONTRAR|FIND)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return 0
        
        search_text = match.group(1).strip().strip('"')
        text = self.get_cell_value_or_text(match.group(2))
        
        pos = text.find(search_text)
        return pos + 1 if pos >= 0 else 0
    
    def function_repetir(self, expr):
        """Funci√≥n REPETIR/REPT - Repite texto"""
        import re
        match = re.match(r"(?:REPETIR|REPT)\((.*?)[;,](\d+)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        text = match.group(1).strip().strip('"')
        times = int(match.group(2))
        
        return text * times
    
    def function_si_error(self, expr):
        """Funci√≥n SI.ERROR/IFERROR - Maneja errores"""
        import re
        match = re.match(r"(?:SI\.ERROR|IFERROR)\((.*?)[;,](.*?)\)", expr, re.IGNORECASE)
        if not match:
            return ""
        
        try:
            formula_part = match.group(1).strip()
            # Intentar evaluar la f√≥rmula
            if formula_part.startswith("="):
                result = self.evaluate_formula(formula_part, None)
            else:
                result = eval(formula_part)
            return result
        except:
            # Si hay error, devolver el valor alternativo
            return match.group(2).strip().strip('"')
        
    def extract_range_values(self, expr):
        """Extraer valores de un rango (ej: A1:A10)"""
        import re
        
        # Buscar patr√≥n de rango A1:A10
        match = re.search(r"([A-Z]+\d+):([A-Z]+\d+)", expr.upper())
        if match:
            start_ref = match.group(1)
            end_ref = match.group(2)
            
            start_row, start_col = self.parse_cell_reference(start_ref)
            end_row, end_col = self.parse_cell_reference(end_ref)
            
            if start_row is not None and end_row is not None:
                values = []
                for row in range(start_row, end_row + 1):
                    for col in range(start_col, end_col + 1):
                        item = self.table.item(row, col)
                        if item and item.text():
                            values.append(item.text())
                return values
                
        # Buscar celdas individuales separadas por coma
        cell_refs = re.findall(r"[A-Z]+\d+", expr.upper())
        values = []
        for ref in cell_refs:
            row, col = self.parse_cell_reference(ref)
            if row is not None:
                item = self.table.item(row, col)
                if item and item.text():
                    values.append(item.text())
        return values
        
    def evaluate_expression(self, expr):
        """Evaluar expresi√≥n matem√°tica con referencias de celdas"""
        import re
        
        # Reemplazar referencias de celdas por sus valores
        cell_refs = re.findall(r"[A-Z]+\d+", expr.upper())
        for ref in cell_refs:
            row, col = self.parse_cell_reference(ref)
            if row is not None:
                item = self.table.item(row, col)
                value = item.text() if item else "0"
                expr = expr.replace(ref, value)
                
        # Evaluar expresi√≥n
        try:
            result = eval(expr)
            return result
        except:
            return "ERROR"
            
    def change_sheet(self, sheet_name):
        """Cambiar hoja activa"""
        # Guardar datos de la hoja actual
        self.save_current_sheet()
        
        # Cargar nueva hoja
        self.current_sheet = sheet_name
        self.load_sheet(sheet_name)
        
    def save_current_sheet(self):
        """Guardar datos de la hoja actual"""
        sheet_data = {}
        sheet_formulas = {}
        sheet_dependencies = {}
        
        for row in range(self.table.rowCount()):
            for col in range(self.table.columnCount()):
                item = self.table.item(row, col)
                if item and item.text():
                    cell_ref = self.get_cell_reference(row, col)
                    key = f"{self.current_sheet}:{cell_ref}"
                    sheet_data[cell_ref] = item.text()
                    if key in self.formulas:
                        sheet_formulas[cell_ref] = self.formulas[key]
                    if key in self.dependencies:
                        sheet_dependencies[cell_ref] = self.dependencies[key]
                        
        self.sheets[self.current_sheet] = {
            "data": sheet_data,
            "formulas": sheet_formulas,
            "dependencies": sheet_dependencies
        }
        
    def load_sheet(self, sheet_name):
        """Cargar datos de una hoja"""
        self.table.blockSignals(True)
        self.table.clear()
        
        # Reconfigurar encabezados
        column_headers = [chr(65 + i) for i in range(26)]
        self.table.setHorizontalHeaderLabels(column_headers)
        row_headers = [str(i + 1) for i in range(100)]
        self.table.setVerticalHeaderLabels(row_headers)
        
        if sheet_name in self.sheets:
            sheet_data = self.sheets[sheet_name].get("data", {})
            sheet_formulas = self.sheets[sheet_name].get("formulas", {})
            sheet_dependencies = self.sheets[sheet_name].get("dependencies", {})
            
            for cell_ref, value in sheet_data.items():
                row, col = self.parse_cell_reference(cell_ref)
                if row is not None:
                    item = QTableWidgetItem(value)
                    self.table.setItem(row, col, item)
                    
                    # Restaurar f√≥rmula si existe
                    if cell_ref in sheet_formulas:
                        key = f"{sheet_name}:{cell_ref}"
                        self.formulas[key] = sheet_formulas[cell_ref]
                    
                    # Restaurar dependencias si existen
                    if cell_ref in sheet_dependencies:
                        key = f"{sheet_name}:{cell_ref}"
                        self.dependencies[key] = sheet_dependencies[cell_ref]
                        
        self.table.blockSignals(False)
        
    def show_help(self):
        """Mostrar ayuda de f√≥rmulas"""
        from PyQt6.QtWidgets import QMessageBox
        
        help_text = """
<h2 style='color: #4a90e2;'>üìä Hoja de C√°lculo Profesional - Gu√≠a Completa</h2>

<h3>‚ö° CARACTER√çSTICAS PROFESIONALES AVANZADAS:</h3>
<ul style='font-size: 9pt; color: #4ae24a;'>
    <li><b>‚ú® Actualizaci√≥n autom√°tica de f√≥rmulas</b> - Se recalculan al instante</li>
    <li><b>‚å®Ô∏è Autocompletado inteligente</b> - 50+ funciones con sugerencias</li>
    <li><b>üìä 12 ESTILOS DE TABLAS VISUALES</b> - Con bordes reales y colores vibrantes</li>
    <li><b>üé® Formato profesional</b> - Negrita, cursiva, subrayado, colores, bordes</li>
    <li><b>‚¨å Combinar/separar celdas</b> - Como Excel</li>
    <li><b>üîç Buscar y reemplazar</b> - En toda la hoja o selecci√≥n</li>
    <li><b>‚ÜïÔ∏è Insertar/eliminar</b> - Filas y columnas din√°micas</li>
    <li><b>üìÑ M√∫ltiples hojas</b> - Crear, renombrar, eliminar hojas</li>
    <li><b>üî¢ Formato de n√∫meros</b> - %, $, decimales con un click</li>
    <li><b>üîΩ Ordenar datos</b> - Ascendente/descendente por columna</li>
    <li><b>üìã Copiar/Pegar/Cortar</b> - Portapapeles completo</li>
    <li><b>üîé Zoom din√°mico</b> - 50% a 200% ajusta todo</li>
    <li><b>üìà GR√ÅFICOS VISUALES</b> - Barras, l√≠neas, circular, √°rea</li>
    <li><b>üíæ Exportar datos</b> - CSV, TXT, HTML</li>
    <li><b>üìÇ Importar datos</b> - Desde CSV</li>
    <li><b>üñ±Ô∏è Men√∫ contextual completo</b> - Click derecho en cualquier celda</li>
    <li><b>üìê Bordes de tabla</b> - Visuales, gruesos, personalizables</li>
    <li><b>üéØ Cuadro de nombre de celda</b> - Navegaci√≥n r√°pida</li>
</ul>

<h3>üé® NUEVOS ESTILOS DE TABLA:</h3>
<ul style='font-size: 9pt;'>
    <li>üîµ <b>Cl√°sico Azul</b> - Profesional y limpio</li>
    <li>üü¢ <b>Verde Profesional</b> - Fresco y corporativo</li>
    <li>üü† <b>Naranja Vibrante</b> - En√©rgico y llamativo</li>
    <li>üü£ <b>Morado Elegante</b> - Sofisticado y moderno</li>
    <li>üî¥ <b>Rojo Corporativo</b> - Impactante y serio</li>
    <li>‚ö´ <b>Oscuro Minimalista</b> - Elegante y discreto</li>
    <li>‚ö™ <b>Claro Moderno</b> - Limpio y espacioso</li>
    <li>üåà <b>Arco√≠ris</b> - Colorido y divertido</li>
    <li>üíº <b>Ejecutivo</b> - Formal y empresarial</li>
    <li>üé® <b>Pastel</b> - Suave y agradable</li>
    <li>‚ö° <b>Ne√≥n</b> - Brillante y moderno</li>
    <li>üèÜ <b>Dorado Premium</b> - Lujoso y destacado</li>
</ul>

<h3>üî¢ Funciones Matem√°ticas:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=SUMA(A1:A10)</b> / =SUM(...) - Suma valores</li>
    <li><b>=PROMEDIO(A1:A10)</b> / =AVERAGE(...) - Promedio</li>
    <li><b>=MAX(A1:A10)</b> - Valor m√°ximo</li>
    <li><b>=MIN(A1:A10)</b> - Valor m√≠nimo</li>
    <li><b>=MEDIANA(A1:A10)</b> / =MEDIAN(...) - Mediana</li>
    <li><b>=MODA(A1:A10)</b> / =MODE(...) - Moda</li>
    <li><b>=REDONDEAR(A1;2)</b> / =ROUND(...) - Redondear</li>
    <li><b>=POTENCIA(2;3)</b> / =POWER(...) - Potencia</li>
    <li><b>=RAIZ(25)</b> / =SQRT(...) - Ra√≠z cuadrada</li>
    <li><b>=ABS(-5)</b> - Valor absoluto</li>
</ul>

<h3>üîç Funciones Condicionales:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=SI(A1>10;"S√≠";"No")</b> / =IF(...) - Condicional</li>
    <li><b>=CONTAR(A1:A10)</b> / =COUNT(...) - Contar valores</li>
    <li><b>=CONTAR.SI(A1:A10;">10")</b> / =COUNTIF(...) - Contar con criterio</li>
    <li><b>=SUMA.SI(A1:A10;">10")</b> / =SUMIF(...) - Sumar con criterio</li>
</ul>

<h3>üìù Funciones de Texto:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=CONCATENAR("Hola";" Mundo")</b> / =CONCAT(...) - Unir texto</li>
    <li><b>=IZQUIERDA("Texto";2)</b> / =LEFT(...) - Primeros caracteres</li>
    <li><b>=DERECHA("Texto";2)</b> / =RIGHT(...) - √öltimos caracteres</li>
    <li><b>=EXTRAE("Texto";2;3)</b> / =MID(...) - Extraer caracteres</li>
    <li><b>=LARGO("Texto")</b> / =LEN(...) - Longitud del texto</li>
    <li><b>=MAYUSC("texto")</b> / =UPPER(...) - Convertir a may√∫sculas</li>
    <li><b>=MINUSC("TEXTO")</b> / =LOWER(...) - Convertir a min√∫sculas</li>
</ul>

<h3>üìÖ Funciones de Fecha:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=HOY()</b> / =TODAY() - Fecha actual</li>
    <li><b>=AHORA()</b> / =NOW() - Fecha y hora actual</li>
    <li><b>=A√ëO()</b> / =YEAR() - A√±o actual</li>
    <li><b>=MES()</b> / =MONTH() - Mes actual</li>
    <li><b>=DIA()</b> / =DAY() - D√≠a actual</li>
</ul>

<h3>üîé Funciones de B√∫squeda:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=BUSCARV("valor";A1:C10;2)</b> / =VLOOKUP(...) - B√∫squeda vertical</li>
</ul>

<h3>üîÄ Funciones L√≥gicas:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=Y(A1>5;B1<10)</b> / =AND(...) - Y l√≥gico</li>
    <li><b>=O(A1>5;B1<10)</b> / =OR(...) - O l√≥gico</li>
    <li><b>=NO(A1>5)</b> / =NOT(...) - NO l√≥gico</li>
</ul>

<h3>‚ûï Operaciones:</h3>
<ul style='font-size: 9pt;'>
    <li><b>=A1+B1</b> - Suma | <b>=A1-B1</b> - Resta</li>
    <li><b>=A1*B1</b> - Multiplicaci√≥n | <b>=A1/B1</b> - Divisi√≥n</li>
    <li><b>=(A1+B1)*2</b> - Expresiones complejas</li>
</ul>

<p style='color: #ffa500; font-size: 9pt; margin-top: 15px;'>
<b>üí° Ejemplos:</b><br>
=SUMA(A1:A5)+B1*2<br>
=SI(PROMEDIO(A1:A10)>50;"Aprobado";"Reprobado")<br>
=CONCATENAR(A1;" - ";HOY())
</p>
        """
        
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Ayuda - Hoja de C√°lculo")
        msg_box.setTextFormat(Qt.TextFormat.RichText)
        msg_box.setText(help_text)
        msg_box.setStyleSheet("""
            QMessageBox {
                background-color: #f3f3f3;
            }
            QMessageBox QLabel {
                color: #e0e0e0;
                min-width: 600px;
            }
            QMessageBox QPushButton {
                background-color: #217346;
                color: white;
                border: none;
                padding: 8px 20px;
                border-radius: 4px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #1a5c38;
            }
        """)
        msg_box.exec()
        
    def get_data(self):
        """Obtener datos para guardar"""
        self.save_current_sheet()
        return {
            "sheets": self.sheets,
            "current_sheet": self.current_sheet
        }
        
    def set_data(self, data):
        """Cargar datos guardados"""
        self.sheets = data.get("sheets", {"Hoja1": {"data": {}, "formulas": {}}})
        self.current_sheet = data.get("current_sheet", "Hoja1")
        
        # Asegurar que la hoja actual existe
        if self.current_sheet not in self.sheets:
            self.current_sheet = list(self.sheets.keys())[0] if self.sheets else "Hoja1"
        
        # Actualizar pesta√±as visuales
        if hasattr(self, 'sheets_tabs_layout'):
            self.update_sheet_tabs()
        
        # Cargar hoja actual
        self.load_sheet(self.current_sheet)


class MainWindow(QMainWindow):
    """Ventana principal de la aplicaci√≥n"""

    def __init__(self):
        super().__init__()
        self.data_file = "file_manager_data.json"
        self.file_watcher = FileWatcher()
        self.file_watcher.file_changed.connect(self.on_file_changed)

        self.setWindowTitle("Gestor de Archivos y Carpetas v1.0.2")
        set_window_icon(self)
        self.setMinimumSize(800, 600)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.performance_manager = PerformanceManager()
        self.plugin_manager = PluginManager()
        self.logger = Logger()
        self.config_manager = AdvancedConfigManager()
        self.export_manager = DataExportManager()

        # Configurar shortcuts globales
        self.shortcuts = {}
        self.setup_shortcuts()
        self.setup_quick_paste_shortcut()

        self.setup_ui()
        self.setup_style()
        self.setup_menu()
        self.load_data()
        self.restore_geometry()

        # Inicializar sistema de bandeja del sistema despu√©s de UI
        self.setup_system_tray()

        # Verificar si debe iniciar en segundo plano
        start_in_background = self.config_manager.get(
            "behavior", "start_in_background", False
        )
        if start_in_background:
            self.hide()
            self.tray_icon.showMessage(
                "üìÅ Gestor de Archivos Pro",
                "Iniciado en segundo plano.\n‚ö° Ctrl+Alt+V est√° activo globalmente.",
                QSystemTrayIcon.MessageIcon.Information,
                3000,
            )

        # Auto-guardar cada 30 segundos
        self.auto_save_timer = QTimer()
        self.auto_save_timer.timeout.connect(self.save_data)
        self.auto_save_timer.start(30000)

        # Inicializar sistema de hooks globales despu√©s de que todo est√© listo
        self.global_hotkey_manager = None
        if GLOBAL_HOOKS_AVAILABLE:
            self.global_hotkey_manager = GlobalHotkeyManager(self)
            # Usar QTimer para inicializar hooks despu√©s de que la ventana est√© completamente cargada
            QTimer.singleShot(2000, self.start_global_hooks)
            print("Programando inicio de hooks globales...")
        else:
            print("Hooks globales no disponibles - dependencias faltantes")

        # Trigger plugin hook
        self.plugin_manager.trigger_hook("app_started", self)

        # Log de inicio
        self.logger.info("Aplicaci√≥n iniciada correctamente")

    def setup_ui(self):
        """Configurar la interfaz principal"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)

        # Widget de pesta√±as
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet("""
            QTabWidget::pane {
                border: 1px solid #555555;
                background-color: #1a1a1a;
            }
            QTabBar::tab {
                background-color: #ffffff;
                color: #333333;
                padding: 10px 20px;
                margin-right: 2px;
                border: 1px solid #555555;
                border-bottom: none;
            }
            QTabBar::tab:selected {
                background-color: #217346;
            }
            QTabBar::tab:hover {
                background-color: #3a3a3a;
            }
        """)

        # Pesta√±a del gestor local
        local_tab = QWidget()
        local_layout = QVBoxLayout(local_tab)
        local_layout.setContentsMargins(0, 0, 0, 0)

        # Barra de herramientas de organizaci√≥n
        toolbar_layout = QHBoxLayout()
        toolbar_layout.setContentsMargins(10, 5, 10, 5)

        sort_label = QLabel("üî§ Ordenar por:")
        sort_label.setStyleSheet("""
            QLabel {
                color: #ffffff;
                font-size: 9pt;
                padding: 5px;
            }
        """)
        toolbar_layout.addWidget(sort_label)

        self.sort_combo = QComboBox()
        self.sort_combo.addItem("üìù Nombre (A-Z)", "name_asc")
        self.sort_combo.addItem("üìù Nombre (Z-A)", "name_desc")
        self.sort_combo.addItem("üìÖ Fecha a√±adida (Reciente)", "date_added_desc")
        self.sort_combo.addItem("üìÖ Fecha a√±adida (Antigua)", "date_added_asc")
        self.sort_combo.addItem("üïê √öltima modificaci√≥n (Reciente)", "modified_desc")
        self.sort_combo.addItem("üïê √öltima modificaci√≥n (Antigua)", "modified_asc")
        self.sort_combo.addItem("üìä Tipo de archivo", "type")
        self.sort_combo.addItem("üìè Tama√±o (Mayor a menor)", "size_desc")
        self.sort_combo.addItem("üìè Tama√±o (Menor a mayor)", "size_asc")
        self.sort_combo.addItem("üéØ Orden personalizado", "custom")
        self.sort_combo.currentIndexChanged.connect(self.sort_items)
        self.sort_combo.setFixedWidth(250)
        self.sort_combo.setStyleSheet("""
            QComboBox {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-size: 9pt;
            }
            QComboBox:hover {
                border: 1px solid #4a90e2;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: #ffffff;
                color: #333333;
                selection-background-color: #217346;
            }
        """)
        toolbar_layout.addWidget(self.sort_combo)

        # Bot√≥n de vista
        self.view_btn = QPushButton("üìã Vista: Lista")
        self.view_btn.setToolTip("Cambiar tipo de vista (pr√≥ximamente)")
        self.view_btn.setFixedWidth(130)
        self.view_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                padding: 5px 10px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
            }
        """)
        toolbar_layout.addWidget(self.view_btn)

        toolbar_layout.addStretch()

        # Contador de elementos
        self.items_count_label = QLabel("0 elementos")
        self.items_count_label.setStyleSheet("""
            QLabel {
                color: #cccccc;
                font-size: 9pt;
                padding: 5px;
            }
        """)
        toolbar_layout.addWidget(self.items_count_label)

        local_layout.addLayout(toolbar_layout)

        self.drop_area = DropArea()
        self.drop_area.files_dropped.connect(self.add_files)
        local_layout.addWidget(self.drop_area)

        self.tab_widget.addTab(local_tab, "üìÅ Gestor Local")

        # Pesta√±a de directorios y archivos favoritos
        self.directory_manager_tab = DirectoryManagerTab(self)
        self.directory_manager_tab.directory_changed.connect(self.save_data)
        self.tab_widget.addTab(self.directory_manager_tab, "‚≠ê Favoritos")

        # Pesta√±a de Dashboard/Notas (solo si est√° habilitada)
        dashboard_enabled = self.config_manager.get("dashboard", "enabled", False)
        if dashboard_enabled:
            self.dashboard_tab = DashboardTab(self)
            self.dashboard_tab.data_changed.connect(self.save_data)
            self.tab_widget.addTab(self.dashboard_tab, "üìù Dashboard")
        else:
            self.dashboard_tab = None

        # Pesta√±a de Notas y Tareas
        self.notes_tasks_tab = NotesAndTasksTab(self)
        self.notes_tasks_tab.data_changed.connect(self.save_data)
        self.tab_widget.addTab(self.notes_tasks_tab, "üìù Notas & Tareas")

        # Pesta√±a de Hoja de C√°lculo
        self.spreadsheet_tab = SpreadsheetTab(self)
        self.spreadsheet_tab.data_changed.connect(self.save_data)
        self.tab_widget.addTab(self.spreadsheet_tab, "üìä Excel")

        layout.addWidget(self.tab_widget)

    def setup_style(self):
        """Configurar el estilo de la aplicaci√≥n"""
        # Cargar tema guardado desde configuraci√≥n
        saved_theme = self.config_manager.get("appearance", "theme", "dark")
        self.theme_manager.set_theme(saved_theme)

        # Aplicar stylesheet con el tema cargado
        self.setStyleSheet(self.theme_manager.get_stylesheet("main"))

        # Aplicar opacidad guardada
        saved_opacity = self.config_manager.get("appearance", "window_opacity", 1.0)
        self.setWindowOpacity(saved_opacity)

    def setup_menu(self):
        """Configurar el men√∫ de la aplicaci√≥n"""
        menubar = self.menuBar()

        # Men√∫ Archivo
        file_menu = menubar.addMenu("Archivo")

        add_file_action = QAction("Agregar Archivo...", self)
        add_file_action.setShortcut(QKeySequence.StandardKey.Open)
        add_file_action.triggered.connect(self.add_file_dialog)
        file_menu.addAction(add_file_action)

        add_folder_action = QAction("Agregar Carpeta...", self)
        add_folder_action.setShortcut(QKeySequence("Ctrl+Shift+O"))
        add_folder_action.triggered.connect(self.add_folder_dialog)
        file_menu.addAction(add_folder_action)

        file_menu.addSeparator()

        save_action = QAction("Guardar", self)
        save_action.setShortcut(QKeySequence.StandardKey.Save)
        save_action.triggered.connect(self.save_data)
        file_menu.addAction(save_action)

        file_menu.addSeparator()

        exit_action = QAction("Salir", self)
        exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Men√∫ Editar
        edit_menu = menubar.addMenu("Editar")

        # Operaciones de clipboard
        copy_path_action = QAction("üìÑ Copiar Ruta", self)
        copy_path_action.setShortcut(QKeySequence("Ctrl+Shift+C"))
        copy_path_action.triggered.connect(self.copy_selected_path)
        copy_path_action.setToolTip("Copiar la ruta del elemento seleccionado")
        edit_menu.addAction(copy_path_action)

        paste_action = QAction("üìã Pegar Elementos", self)
        paste_action.setShortcut(QKeySequence.StandardKey.Paste)
        paste_action.triggered.connect(self.paste_from_menu)
        edit_menu.addAction(paste_action)

        edit_menu.addSeparator()

        # B√∫squeda
        find_action = QAction("üîç Buscar...", self)
        find_action.setShortcut(QKeySequence.StandardKey.Find)
        find_action.triggered.connect(self.show_search_dialog)
        edit_menu.addAction(find_action)

        show_all_action = QAction("üëÅÔ∏è Mostrar Todos", self)
        show_all_action.setShortcuts(
            [QKeySequence("Esc"), QKeySequence("Ctrl+Shift+F")]
        )
        show_all_action.triggered.connect(self.show_all_items)
        show_all_action.setToolTip(
            "Mostrar todos los elementos (cancelar b√∫squeda) - ESC o Ctrl+Shift+F"
        )
        edit_menu.addAction(show_all_action)

        edit_menu.addSeparator()

        # Operaciones de archivos
        refresh_action = QAction("üîÑ Actualizar Lista", self)
        refresh_action.setShortcut(QKeySequence.StandardKey.Refresh)
        refresh_action.triggered.connect(self.refresh_all_items)
        edit_menu.addAction(refresh_action)

        edit_menu.addSeparator()

        # Limpieza
        clear_action = QAction("üßπ Limpiar Todo", self)
        clear_action.setShortcut(QKeySequence("Ctrl+Shift+Delete"))
        clear_action.triggered.connect(self.clear_all)
        edit_menu.addAction(clear_action)

        edit_menu.addSeparator()

        # Preferencias
        preferences_action = QAction("‚öôÔ∏è Preferencias", self)
        preferences_action.setShortcut(QKeySequence.StandardKey.Preferences)
        preferences_action.triggered.connect(self.show_advanced_config)
        edit_menu.addAction(preferences_action)

        # Men√∫ Herramientas
        tools_menu = menubar.addMenu("Herramientas")

        performance_action = QAction("‚ö° Limpiar Cach√©", self)
        performance_action.triggered.connect(self.clear_performance_cache)
        tools_menu.addAction(performance_action)

        stats_action = QAction("üìä Estad√≠sticas", self)
        stats_action.triggered.connect(self.show_statistics)
        tools_menu.addAction(stats_action)

        tools_menu.addSeparator()

        quick_paste_action = QAction("‚ö° Pegado R√°pido (Ctrl+Alt+V)", self)
        quick_paste_action.triggered.connect(self.show_quick_paste_dialog)
        tools_menu.addAction(quick_paste_action)

        change_dir_action = QAction("üìÇ Cambiar Directorio de Trabajo", self)
        change_dir_action.setShortcut(QKeySequence("Ctrl+Shift+D"))
        change_dir_action.triggered.connect(self.change_working_directory)
        tools_menu.addAction(change_dir_action)

        tools_menu.addSeparator()

        config_action = QAction("‚öôÔ∏è Configuraci√≥n Avanzada", self)
        config_action.triggered.connect(self.show_advanced_config)
        tools_menu.addAction(config_action)

        export_action = QAction("üì§ Exportar Datos", self)
        export_action.triggered.connect(self.export_application_data)
        tools_menu.addAction(export_action)

        import_action = QAction("üì• Importar Datos", self)
        import_action.triggered.connect(self.import_application_data)
        tools_menu.addAction(import_action)

        # Men√∫ Ver
        view_menu = menubar.addMenu("Ver")

        # Submen√∫ de temas
        themes_menu = view_menu.addMenu("üé® Temas")
        theme_names = self.theme_manager.get_theme_names()

        for theme_key, theme_name in theme_names.items():
            theme_action = QAction(theme_name, self)
            theme_action.triggered.connect(
                lambda checked, key=theme_key: self.change_theme(key)
            )
            themes_menu.addAction(theme_action)

        view_menu.addSeparator()

        toggle_theme_action = QAction("üåì Alternar Oscuro/Claro", self)
        toggle_theme_action.triggered.connect(self.toggle_theme)
        view_menu.addAction(toggle_theme_action)

        fullscreen_action = QAction("‚õ∂ Pantalla Completa", self)
        fullscreen_action.setShortcut("F11")
        fullscreen_action.triggered.connect(self.toggle_fullscreen)
        view_menu.addAction(fullscreen_action)

        # Men√∫ Ayuda
        # Men√∫ Sistema
        system_menu = menubar.addMenu("Sistema")

        minimize_to_tray_action = QAction("üîΩ Minimizar a Bandeja", self)
        minimize_to_tray_action.triggered.connect(self.hide)
        system_menu.addAction(minimize_to_tray_action)

        system_menu.addSeparator()

        quit_completely_action = QAction("‚ùå Salir Completamente", self)
        quit_completely_action.triggered.connect(self.quit_application)
        system_menu.addAction(quit_completely_action)

        # Men√∫ Ayuda
        help_menu = menubar.addMenu("Ayuda")

        shortcuts_action = QAction("‚å®Ô∏è Atajos de Teclado", self)
        shortcuts_action.triggered.connect(self.show_shortcuts_help)
        help_menu.addAction(shortcuts_action)

        background_help_action = QAction("üîÑ Funcionamiento en Segundo Plano", self)
        background_help_action.triggered.connect(self.show_background_help)
        help_menu.addAction(background_help_action)

        help_menu.addSeparator()

        about_action = QAction("Acerca de", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

        # Barra de estado
        # Mostrar directorio actual en la barra de estado
        current_dir = self.get_current_working_directory()
        base_message = f"Directorio actual: {current_dir} | Listo para recibir archivos"
        if GLOBAL_HOOKS_AVAILABLE:
            base_message += " | ‚ö° Ctrl+Alt+C (capturar) | Ctrl+Alt+V (pegar) GLOBALES ACTIVOS | üîÑ Segundo plano"
        self.statusBar().showMessage(base_message)

    def paste_from_menu(self):
        """Pegar desde el men√∫"""
        self.drop_area.paste_items_with_selection()
        self.update_status_bar()

    def clear_clipboard_from_menu(self):
        """Limpiar clipboard desde el men√∫"""
        self.drop_area.clear_clipboard()
        self.update_status_bar()

    def copy_selected_path(self):
        """Copiar la ruta del elemento seleccionado al portapapeles"""
        # Obtener el elemento seleccionado en el √°rea de drop
        selected_items = []
        for widget in self.drop_area.item_widgets.values():
            if widget.is_selected_for_batch():
                selected_items.append(widget.file_item.path)

        if not selected_items:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Por favor, selecciona al menos un elemento para copiar su ruta.",
            )
            return

        # Si hay m√∫ltiples elementos, copiar todas las rutas separadas por nueva l√≠nea
        paths_text = "\n".join(selected_items)

        clipboard = QApplication.clipboard()
        clipboard.setText(paths_text)

        count = len(selected_items)
        self.statusBar().showMessage(
            f"‚úì {count} ruta{'s' if count > 1 else ''} copiada{'s' if count > 1 else ''} al portapapeles",
            3000,
        )

    def select_all_items(self):
        """Seleccionar todos los elementos en el √°rea de drop"""
        if not self.drop_area.items:
            self.statusBar().showMessage("No hay elementos para seleccionar", 2000)
            return

        # Seleccionar todos los widgets
        for widget in self.drop_area.item_widgets.values():
            widget.select_for_batch(True)

        count = len(self.drop_area.items)
        self.statusBar().showMessage(
            f"‚úì {count} elemento{'s' if count != 1 else ''} seleccionado{'s' if count != 1 else ''}",
            2000,
        )
        self.update_status_bar()

    def deselect_all_items(self):
        """Deseleccionar todos los elementos en el √°rea de drop"""
        if not self.drop_area.items:
            self.statusBar().showMessage("No hay elementos para deseleccionar", 2000)
            return

        # Deseleccionar todos los widgets
        for widget in self.drop_area.item_widgets.values():
            widget.select_for_batch(False)

        self.statusBar().showMessage("‚úì Todos los elementos deseleccionados", 2000)
        self.update_status_bar()

    def show_search_dialog(self):
        """Mostrar di√°logo de b√∫squeda para filtrar elementos"""
        if not self.drop_area.items:
            QMessageBox.information(
                self, "Lista vac√≠a", "No hay elementos en la lista para buscar."
            )
            return

        # Crear di√°logo de b√∫squeda
        search_dialog = SearchDialog(self, self.drop_area.items)
        if search_dialog.exec() == QDialog.DialogCode.Accepted:
            # Verificar si se pidi√≥ mostrar todos
            if search_dialog.search_term == "__SHOW_ALL__":
                self.show_all_items()
            else:
                # Filtrar elementos seg√∫n la b√∫squeda
                search_term = search_dialog.get_search_term()
                if search_term:
                    self.filter_items(search_term)

    def filter_items(self, search_term: str):
        """Filtrar elementos seg√∫n t√©rmino de b√∫squeda"""
        search_term = search_term.lower()
        matched_count = 0

        # Ocultar/mostrar widgets seg√∫n coincidencia
        for widget in self.drop_area.item_widgets.values():
            item = widget.file_item
            # Buscar en nombre, ruta y descripci√≥n
            match = (
                search_term in item.name.lower()
                or search_term in item.path.lower()
                or (item.description and search_term in item.description.lower())
            )

            if match:
                widget.show()
                matched_count += 1
            else:
                widget.hide()

        if matched_count == 0:
            QMessageBox.information(
                self,
                "Sin resultados",
                f"No se encontraron elementos que coincidan con '{search_term}'.",
            )
            # Mostrar todos de nuevo
            self.show_all_items()
        else:
            self.statusBar().showMessage(
                f"üîç Se encontraron {matched_count} elemento{'s' if matched_count != 1 else ''} | ESC o Ctrl+Shift+F para mostrar todos",
                5000,
            )

    def show_all_items(self):
        """Mostrar todos los elementos (cancelar filtro de b√∫squeda)"""
        if not self.drop_area.items:
            return

        # Mostrar todos los widgets
        hidden_count = 0
        for widget in self.drop_area.item_widgets.values():
            if widget.isHidden():
                widget.show()
                hidden_count += 1

        if hidden_count > 0:
            self.statusBar().showMessage(
                f"‚úì Mostrando todos los elementos ({len(self.drop_area.items)} en total)",
                2000,
            )
        else:
            self.statusBar().showMessage(
                "‚úì Todos los elementos ya est√°n visibles", 2000
            )

    def duplicate_selected_item(self):
        """Duplicar el elemento seleccionado"""
        # Obtener elementos seleccionados
        selected_items = []
        for widget in self.drop_area.item_widgets.values():
            if widget.is_selected_for_batch():
                selected_items.append(widget.file_item)

        if not selected_items:
            QMessageBox.information(
                self,
                "Sin selecci√≥n",
                "Por favor, selecciona al menos un elemento para duplicar.",
            )
            return

        duplicated_count = 0
        for item in selected_items:
            # Crear una copia del FileItem con una nueva fecha
            duplicate_item = FileItem(
                name=item.name,
                path=item.path,
                is_directory=item.is_directory,
                date_added=datetime.now().strftime("%Y-%m-%d %H:%M"),
                last_modified=item.last_modified,
                size=item.size,
                description=f"{item.description} (copia)"
                if item.description
                else "(copia)",
            )

            self.drop_area.add_item(duplicate_item)
            self.file_watcher.add_file(item.path)
            duplicated_count += 1

        self.save_data()
        self.update_items_count()
        self.statusBar().showMessage(
            f"‚úì {duplicated_count} elemento{'s' if duplicated_count != 1 else ''} duplicado{'s' if duplicated_count != 1 else ''}",
            3000,
        )

    def refresh_all_items(self):
        """Actualizar informaci√≥n de todos los elementos"""
        if not self.drop_area.items:
            self.statusBar().showMessage("No hay elementos para actualizar", 2000)
            return

        updated_count = 0
        removed_count = 0

        # Actualizar cada elemento
        items_to_remove = []
        for item in self.drop_area.items:
            if os.path.exists(item.path):
                try:
                    stat = os.stat(item.path)
                    item.last_modified = datetime.fromtimestamp(stat.st_mtime).strftime(
                        "%Y-%m-%d %H:%M"
                    )
                    if not item.is_directory:
                        item.size = stat.st_size
                    updated_count += 1
                except Exception as e:
                    print(f"Error actualizando {item.path}: {e}")
            else:
                items_to_remove.append(item)
                removed_count += 1

        # Remover elementos que ya no existen
        for item in items_to_remove:
            self.drop_area.remove_item(item.path)
            self.file_watcher.remove_file(item.path)

        # Refrescar visualizaci√≥n
        self.drop_area.refresh_display()
        self.save_data()
        self.update_items_count()

        # Mensaje de estado
        message_parts = []
        if updated_count > 0:
            message_parts.append(
                f"{updated_count} actualizado{'s' if updated_count != 1 else ''}"
            )
        if removed_count > 0:
            message_parts.append(
                f"{removed_count} eliminado{'s' if removed_count != 1 else ''} (no existente{'s' if removed_count != 1 else ''})"
            )

        if message_parts:
            self.statusBar().showMessage(f"‚úì {', '.join(message_parts)}", 3000)
        else:
            self.statusBar().showMessage("‚úì Lista actualizada", 2000)

    def update_status_bar(self):
        """Actualizar barra de estado con informaci√≥n del clipboard m√∫ltiple"""
        # Contar elementos seleccionados
        selected_count = 0
        for widget in self.drop_area.item_widgets.values():
            if widget.is_selected_for_batch():
                selected_count += 1

        status_parts = []

        # Informaci√≥n del clipboard m√∫ltiple
        clipboard_count = self.drop_area.multi_clipboard.count()
        if clipboard_count > 0:
            status_parts.append(f"üìã Clipboard: {clipboard_count} elementos")

        status_parts.append(f"{len(self.drop_area.items)} elementos")

        if selected_count > 0:
            status_parts.append(f"‚úì {selected_count} seleccionados")

        # Incluir directorio actual m√°s relevante
        current_dir = self.get_current_working_directory()
        status_parts.insert(0, f"üìÅ {os.path.basename(current_dir)}")

        if not status_parts or (
            len(status_parts) == 1 and "elementos" in status_parts[0]
        ):
            self.statusBar().showMessage(" | ".join(status_parts))
        else:
            self.statusBar().showMessage(" | ".join(status_parts))

    def add_files(self, file_paths: List[str]):
        """Agregar archivos o carpetas desde arrastre"""
        for path in file_paths:
            self.add_single_file(path)

        self.save_data()
        self.statusBar().showMessage(f"Se agregaron {len(file_paths)} elemento(s)")

        # Limpiar mensaje despu√©s de 3 segundos
        QTimer.singleShot(3000, lambda: self.statusBar().showMessage("Listo"))

    def add_single_file(self, path: str, description: str = "", silent: bool = False):
        """Agregar un solo archivo o carpeta"""
        print(f"add_single_file llamado para: {path}")

        if not os.path.exists(path):
            print(f"  ‚úó El archivo no existe: {path}")
            if not silent:
                QMessageBox.warning(
                    self, "Error", f"El archivo o carpeta no existe:\n{path}"
                )
            return False

        # Verificar si ya existe
        existing_paths = [item.path for item in self.drop_area.items]
        if path in existing_paths:
            print(f"  ‚ö†Ô∏è El archivo ya est√° en la lista: {path}")
            if not silent:
                QMessageBox.information(
                    self, "Informaci√≥n", "Este elemento ya est√° en la lista."
                )
            return False

        try:
            stat = os.stat(path)
            is_dir = os.path.isdir(path)

            file_item = FileItem(
                name=os.path.basename(path),
                path=path,
                is_directory=is_dir,
                date_added=datetime.now().strftime("%Y-%m-%d %H:%M"),
                last_modified=datetime.fromtimestamp(stat.st_mtime).strftime(
                    "%Y-%m-%d %H:%M"
                ),
                size=None if is_dir else stat.st_size,
                description=description,
            )

            self.drop_area.add_item(file_item)
            self.file_watcher.add_file(path)
            print(f"  ‚úì Archivo agregado exitosamente: {path}")

            # Actualizar contador de elementos
            self.update_items_count()
            return True

        except Exception as e:
            print(f"  ‚úó Error agregando archivo: {e}")
            if not silent:
                QMessageBox.warning(
                    self, "Error", f"No se pudo agregar el elemento:\n{str(e)}"
                )
            return False

    def add_file_dialog(self):
        """Mostrar di√°logo para agregar archivo"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Seleccionar Archivo", "", "Todos los archivos (*.*)"
        )

        if file_path:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            file_path = normalize_network_path(file_path)
            self.add_single_file(file_path)
            self.save_data()

    def add_folder_dialog(self):
        """Mostrar di√°logo para agregar carpeta"""
        folder_path = QFileDialog.getExistingDirectory(self, "Seleccionar Carpeta")

        if folder_path:
            # Normalizar ruta para soportar rutas de red UNC correctamente
            folder_path = normalize_network_path(folder_path)
            self.add_single_file(folder_path)
            self.save_data()

    def clear_all(self):
        """Limpiar todos los elementos"""
        reply = QMessageBox.question(
            self,
            "Confirmar",
            "¬øEst√°s seguro de que quieres eliminar todos los elementos?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            self.drop_area.clear_all()
            self.file_watcher.files_to_watch.clear()
            self.save_data()
            self.statusBar().showMessage("Lista limpiada")

    def on_file_changed(self, filepath: str):
        """Manejar cambios en archivos observados"""
        self.drop_area.update_item(filepath)
        self.save_data()

        filename = os.path.basename(filepath)
        self.statusBar().showMessage(f"Actualizado: {filename}", 2000)

    def update_items_count(self):
        """Actualizar contador de elementos"""
        count = len(self.drop_area.items)
        if count == 0:
            self.items_count_label.setText("0 elementos")
        elif count == 1:
            self.items_count_label.setText("1 elemento")
        else:
            self.items_count_label.setText(f"{count} elementos")

    def sort_items(self):
        """Ordenar elementos seg√∫n el criterio seleccionado"""
        sort_type = self.sort_combo.currentData()

        if not self.drop_area.items:
            return

        # Guardar el orden actual antes de ordenar
        original_items = self.drop_area.items.copy()

        try:
            if sort_type == "name_asc":
                self.drop_area.items.sort(key=lambda x: x.name.lower())
            elif sort_type == "name_desc":
                self.drop_area.items.sort(key=lambda x: x.name.lower(), reverse=True)
            elif sort_type == "date_added_asc":
                self.drop_area.items.sort(key=lambda x: x.date_added)
            elif sort_type == "date_added_desc":
                self.drop_area.items.sort(key=lambda x: x.date_added, reverse=True)
            elif sort_type == "modified_asc":
                self.drop_area.items.sort(key=lambda x: x.last_modified)
            elif sort_type == "modified_desc":
                self.drop_area.items.sort(key=lambda x: x.last_modified, reverse=True)
            elif sort_type == "type":
                # Ordenar por extensi√≥n/tipo, luego por nombre
                def get_extension(item):
                    if item.is_directory:
                        return "000_folder"  # Carpetas primero
                    ext = os.path.splitext(item.name)[1].lower()
                    return ext if ext else "zzz_no_ext"

                self.drop_area.items.sort(
                    key=lambda x: (get_extension(x), x.name.lower())
                )
            elif sort_type == "size_asc":
                # Carpetas al final, luego por tama√±o
                self.drop_area.items.sort(
                    key=lambda x: (x.is_directory, x.size if x.size else 0)
                )
            elif sort_type == "size_desc":
                # Carpetas al final, luego por tama√±o descendente
                self.drop_area.items.sort(
                    key=lambda x: (x.is_directory, -(x.size if x.size else 0))
                )
            elif sort_type == "custom":
                # No hacer nada, mantener orden actual
                return

            # Actualizar la visualizaci√≥n
            self.drop_area.refresh_display()
            self.statusBar().showMessage(
                f"‚úì Lista ordenada: {self.sort_combo.currentText()}", 2000
            )

        except Exception as e:
            print(f"Error ordenando items: {e}")
            # Restaurar orden original si hay error
            self.drop_area.items = original_items
            self.drop_area.refresh_display()

    def save_data(self):
        """Guardar datos en archivo JSON"""
        try:
            data = {
                "items": [asdict(item) for item in self.drop_area.items],
                "favorite_directories": self.directory_manager_tab.get_directories(),
                "last_saved": datetime.now().isoformat(),
            }

            # Solo incluir datos del dashboard si est√° habilitado
            if self.dashboard_tab is not None:
                data["dashboard_data"] = self.dashboard_tab.get_data()

            # Guardar datos de la pesta√±a de notas y tareas
            data["notes_tasks_data"] = self.notes_tasks_tab.get_data()

            # Guardar datos de la hoja de c√°lculo
            data["spreadsheet_data"] = self.spreadsheet_tab.get_data()

            with open(self.data_file, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)

        except Exception as e:
            QMessageBox.warning(
                self,
                "Error de Guardado",
                f"No se pudieron guardar los datos:\n{str(e)}",
            )

    def load_data(self):
        """Cargar datos desde archivo JSON"""
        if not os.path.exists(self.data_file):
            return

        try:
            with open(self.data_file, "r", encoding="utf-8") as f:
                data = json.load(f)

            items = data.get("items", [])
            for item_data in items:
                try:
                    # Normalizar ruta para soportar rutas de red UNC correctamente
                    if "path" in item_data:
                        item_data["path"] = normalize_network_path(item_data["path"])

                    file_item = FileItem(**item_data)
                    if os.path.exists(file_item.path):
                        self.drop_area.add_item(file_item)
                        self.file_watcher.add_file(file_item.path)
                    # Si el archivo no existe, simplemente no lo cargamos
                except Exception as e:
                    print(f"Error cargando item: {e}")
                    continue

            # Cargar directorios favoritos
            favorite_directories = data.get("favorite_directories", [])
            if favorite_directories:
                self.directory_manager_tab.set_directories(favorite_directories)

            # Cargar datos del dashboard (solo si est√° habilitado)
            dashboard_data = data.get("dashboard_data", {})
            if dashboard_data and self.dashboard_tab is not None:
                self.dashboard_tab.set_data(dashboard_data)

            # Cargar datos de la pesta√±a de notas y tareas
            notes_tasks_data = data.get("notes_tasks_data", {})
            if notes_tasks_data:
                self.notes_tasks_tab.set_data(notes_tasks_data)

            # Cargar datos de la hoja de c√°lculo
            spreadsheet_data = data.get("spreadsheet_data", {})
            if spreadsheet_data:
                self.spreadsheet_tab.set_data(spreadsheet_data)

            if (
                items
                or favorite_directories
                or (dashboard_data and self.dashboard_tab is not None)
                or notes_tasks_data
                or spreadsheet_data
            ):
                status_msg = f"Cargados {len(self.drop_area.items)} elementos"
                if favorite_directories:
                    status_msg += (
                        f" y {len(favorite_directories)} directorios favoritos"
                    )
                if dashboard_data and self.dashboard_tab is not None:
                    status_msg += f" y datos del dashboard"
                self.statusBar().showMessage(status_msg)

            # Actualizar contador de elementos
            self.update_items_count()

        except Exception as e:
            QMessageBox.warning(
                self, "Error de Carga", f"No se pudieron cargar los datos:\n{str(e)}"
            )

    def show_about(self):
        """Mostrar informaci√≥n sobre la aplicaci√≥n"""
        QMessageBox.about(
            self,
            "Acerca de Gestor de Archivos",
            """
            <h3>üìÅ Gestor de Archivos y Carpetas</h3>
            <p><b>Versi√≥n:</b> 1.0.2</p>
            <p><b>Descripci√≥n:</b> Una interfaz elegante para organizar y acceder
            r√°pidamente a tus archivos y carpetas favoritos.</p>

            <p><b>Caracter√≠sticas:</b></p>
            <ul>
                <li>üéØ Arrastrar y soltar archivos y carpetas</li>
                <li>üíæ Guardado autom√°tico de la lista</li>
                <li>üîÑ Detecci√≥n autom√°tica de cambios</li>
                <li>üé® Interfaz elegante en tonos oscuros</li>
                <li>‚ö° Acceso r√°pido a elementos guardados</li>
            </ul>

            <p><b>Desarrollado con:</b> Python & PyQt6</p>
            """,
        )

    def keyPressEvent(self, event):
        """Manejar eventos de teclado"""
        # Ctrl+V para pegar
        if (
            event.key() == Qt.Key.Key_V
            and event.modifiers() == Qt.KeyboardModifier.ControlModifier
        ):
            self.paste_from_menu()
        # Delete para limpiar clipboard
        elif (
            event.key() == Qt.Key.Key_Delete
            and event.modifiers() == Qt.KeyboardModifier.ShiftModifier
        ):
            self.clear_clipboard_from_menu()
        # F11 para pantalla completa
        elif event.key() == Qt.Key.Key_F11:
            self.toggle_fullscreen()
        # Ctrl+Alt+V para pegado r√°pido
        elif event.key() == Qt.Key.Key_V and event.modifiers() == (
            Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier
        ):
            self.show_quick_paste_dialog()
        else:
            super().keyPressEvent(event)

    def setup_shortcuts(self):
        """Configurar atajos de teclado personalizables"""
        from PyQt6.QtGui import QShortcut

        # Shortcuts adicionales
        refresh_shortcut = QShortcut(QKeySequence("F5"), self)
        refresh_shortcut.activated.connect(self.refresh_all)

        stats_shortcut = QShortcut(QKeySequence("Ctrl+I"), self)
        stats_shortcut.activated.connect(self.show_statistics)

        self.shortcuts["refresh"] = refresh_shortcut
        self.shortcuts["stats"] = stats_shortcut

    def setup_quick_paste_shortcut(self):
        """Configurar atajo de pegado r√°pido Ctrl+Alt+V"""
        # No crear shortcut duplicado aqu√≠, ya se maneja en keyPressEvent
        pass

    def refresh_all(self):
        """Refrescar toda la aplicaci√≥n"""
        self.performance_manager.clear_cache()
        self.file_watcher.check_files()
        self.update_status_bar()

    def show_global_hooks_notification(self):
        """Mostrar notificaci√≥n de que los hooks globales est√°n activos"""
        current_msg = self.statusBar().currentMessage()
        if "‚ö° Ctrl+Alt+V global ACTIVO" not in current_msg:
            self.statusBar().showMessage(f"{current_msg} | ‚ö° Ctrl+Alt+V global ACTIVO")

    def clear_performance_cache(self):
        """Limpiar cach√© de rendimiento"""
        self.performance_manager.clear_cache()
        QMessageBox.information(
            self,
            "Cach√© Limpiado",
            "El cach√© de rendimiento ha sido limpiado exitosamente.",
        )

    def show_statistics(self):
        """Mostrar estad√≠sticas de la aplicaci√≥n"""
        total_items = len(self.drop_area.items)
        clipboard_items = self.drop_area.multi_clipboard.count()

        stats_text = f"""
üìä Estad√≠sticas de la Aplicaci√≥n

üìÇ Elementos guardados: {total_items}
üìã Elementos en clipboard: {clipboard_items}
üéØ Tema actual: {self.theme_manager.current_theme.title()}
‚ö° Cach√© activo: S√≠
üîå Plugins cargados: {len(self.plugin_manager.plugins)}


        """

        QMessageBox.information(self, "üìä Estad√≠sticas", stats_text.strip())

    def show_shortcuts_help(self):
        """Mostrar ayuda de atajos de teclado"""
        shortcuts_text = """
‚å®Ô∏è Atajos de Teclado Disponibles

üîß Funciones Principales:
‚Ä¢ Ctrl+O          Agregar archivo
‚Ä¢ Ctrl+S          Guardar datos
‚Ä¢ Ctrl+Q          Salir de la aplicaci√≥n

üìã Clipboard y Pegado GLOBAL:
‚Ä¢ Ctrl+Alt+C      ‚ú® CAPTURAR archivos seleccionados
‚Ä¢ Ctrl+Alt+V      ‚ö° PEGAR archivos (directorio actual)
‚Ä¢ Ctrl+V          Pegar con selecci√≥n m√∫ltiple
‚Ä¢ Shift+Delete    Limpiar clipboard completamente

üñ•Ô∏è Ventana y Vista:
‚Ä¢ F5              Refrescar aplicaci√≥n
‚Ä¢ F11             Alternar pantalla completa
‚Ä¢ Ctrl+I          Mostrar estad√≠sticas
‚Ä¢ Ctrl+Shift+D    Cambiar directorio de trabajo

‚ú® NUEVO: Captura Global (Ctrl+Alt+C):
M√©todo 1 (Recomendado):
1. Selecciona archivos en Explorer ‚Üí Ctrl+C (copiar)
2. Presiona Ctrl+Alt+C para a√±adirlos a la lista

M√©todo 2 (Autom√°tico):
- Mant√©n archivos seleccionados en Explorer
- Presiona Ctrl+Alt+C para capturarlos directamente
- Funciona con ventanas de Explorer en segundo plano

‚ö° Pegado R√°pido (Ctrl+Alt+V):
Pega los archivos guardados directamente en el directorio
donde est√©s trabajando. Funciona desde CUALQUIER aplicaci√≥n.

üìÇ Cambio de Directorio (Ctrl+Shift+D):
Cambia el directorio de trabajo para el pegado r√°pido.

üí° Flujo de Trabajo Recomendado:
1. Selecciona archivos en Explorer ‚Üí Ctrl+Alt+C (capturar)
2. Ve a la carpeta destino ‚Üí Ctrl+Alt+V (pegar)
3. ¬°Listo! Los archivos se copian autom√°ticamente
        """

        QMessageBox.information(self, "‚å®Ô∏è Atajos de Teclado", shortcuts_text.strip())

    def show_background_help(self):
        """Mostrar ayuda sobre funcionamiento en segundo plano"""
        background_text = """
üîÑ Funcionamiento en Segundo Plano

La aplicaci√≥n est√° dise√±ada para funcionar continuamente
en segundo plano, manteniendo los hooks globales activos.

üéØ Caracter√≠sticas del Sistema:
‚Ä¢ Al cerrar la ventana principal, la app NO se cierra
‚Ä¢ Se minimiza a la bandeja del sistema (system tray)
‚Ä¢ Ctrl+Alt+V sigue funcionando desde cualquier aplicaci√≥n
‚Ä¢ Detecta autom√°ticamente la carpeta donde est√°s trabajando

üöÄ NUEVO: Inicio Autom√°tico en Segundo Plano:
‚Ä¢ Marca "üîÑ Iniciar en segundo plano" en la ventana principal
‚Ä¢ La app iniciar√° directo en la bandeja del sistema
‚Ä¢ Ctrl+Alt+V estar√° activo desde el primer momento
‚Ä¢ No ver√°s la ventana hasta que la necesites

üîß C√≥mo Funciona:
1. La aplicaci√≥n se inicia (normal o en segundo plano)
2. Activa los hooks globales autom√°ticamente
3. Al cerrar la ventana, se minimiza a la bandeja
4. Puedes usar Ctrl+Alt+V desde cualquier lugar
5. Doble clic en el icono de la bandeja restaura la ventana

üìç Detecci√≥n Autom√°tica de Carpetas:
‚Ä¢ En el Explorador de Windows: detecta la carpeta abierta
‚Ä¢ En el Escritorio: usa la carpeta del escritorio
‚Ä¢ En otras apps: intenta detectar el directorio de trabajo

‚öôÔ∏è Controles del Sistema:
‚Ä¢ Clic derecho en icono de bandeja: men√∫ de opciones
‚Ä¢ Sistema ‚Üí Estado Hooks Globales: verificar funcionamiento
‚Ä¢ Sistema ‚Üí Salir Completamente: cerrar definitivamente

üí° Consejos:
‚Ä¢ Activa "Iniciar en segundo plano" para m√°xima comodidad
‚Ä¢ Mant√©n la aplicaci√≥n ejecut√°ndose para usar Ctrl+Alt+V
‚Ä¢ Si no funciona, verifica el estado de hooks globales
‚Ä¢ La app consume muy pocos recursos en segundo plano
        """

        QMessageBox.information(self, "üîÑ Segundo Plano", background_text.strip())

    def show_advanced_config(self):
        """Mostrar di√°logo de configuraci√≥n avanzada"""
        dialog = AdvancedConfigDialog(self.config_manager, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Aplicar cambios de configuraci√≥n
            self.apply_config_changes()

    def apply_config_changes(self):
        """Aplicar cambios de configuraci√≥n"""
        # Aplicar tema
        theme = self.config_manager.get("appearance", "theme", "dark")
        if theme != self.theme_manager.current_theme:
            self.theme_manager.current_theme = theme
            self.setStyleSheet(self.theme_manager.get_stylesheet("main"))

        # Aplicar opacidad de ventana
        opacity = self.config_manager.get("appearance", "window_opacity", 1.0)
        self.setWindowOpacity(opacity)

        # Aplicar animaciones
        animations_enabled = self.config_manager.get(
            "appearance", "animations_enabled", True
        )
        for widget in self.drop_area.item_widgets.values():
            widget.animation_enabled = animations_enabled

        # Aplicar configuraci√≥n de clipboard
        max_clipboard = self.config_manager.get(
            "performance", "max_clipboard_items", 50
        )
        self.drop_area.multi_clipboard.max_items = max_clipboard

        # Aplicar auto-save interval
        interval = self.config_manager.get("behavior", "auto_save_interval", 30) * 1000
        self.auto_save_timer.setInterval(interval)

        # Reiniciar hooks globales para aplicar nuevos atajos de teclado
        if self.global_hotkey_manager and GLOBAL_HOOKS_AVAILABLE:
            print("Reiniciando hooks globales para aplicar nuevos atajos...")
            self.global_hotkey_manager.stop_global_listener()
            # Usar QTimer para reiniciar despu√©s de un breve delay
            QTimer.singleShot(1000, self.start_global_hooks)

    def export_application_data(self):
        """Exportar datos de la aplicaci√≥n"""
        filepath, selected_format = QFileDialog.getSaveFileName(
            self,
            "Exportar Datos de la Aplicaci√≥n",
            f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            "JSON Files (*.json);;CSV Files (*.csv);;XML Files (*.xml)",
        )

        if filepath:
            format_type = filepath.split(".")[-1].lower()

            # Preparar datos para exportar
            export_data = {
                "items": [asdict(item) for item in self.drop_area.items],
                "clipboard": self.drop_area.multi_clipboard.get_items(),
                "config": self.config_manager.config,
                "export_date": datetime.now().isoformat(),
                "version": "2.1",
            }

            if self.export_manager.export_data(export_data, filepath, format_type):
                QMessageBox.information(
                    self,
                    "Exportaci√≥n Exitosa",
                    f"Datos exportados exitosamente a:\n{filepath}",
                )
            else:
                QMessageBox.critical(
                    self, "Error de Exportaci√≥n", "No se pudieron exportar los datos."
                )

    def import_application_data(self):
        """Importar datos de la aplicaci√≥n"""
        filepath, _ = QFileDialog.getOpenFileName(
            self,
            "Importar Datos de la Aplicaci√≥n",
            "",
            "JSON Files (*.json);;CSV Files (*.csv);;XML Files (*.xml);;All Files (*)",
        )

        if filepath:
            format_type = filepath.split(".")[-1].lower()

            result = QMessageBox.question(
                self,
                "Confirmar Importaci√≥n",
                "¬øDeseas reemplazar los datos actuales?\n\n"
                "Esta acci√≥n no se puede deshacer.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )

            if result == QMessageBox.StandardButton.Yes:
                imported_data = self.export_manager.import_data(filepath, format_type)

                if imported_data:
                    try:
                        # Limpiar datos actuales
                        self.drop_area.clear_all()

                        # Importar elementos
                        if "items" in imported_data:
                            for item_data in imported_data["items"]:
                                try:
                                    file_item = FileItem(**item_data)
                                    if os.path.exists(file_item.path):
                                        self.drop_area.add_item(file_item)
                                except:
                                    continue

                        # Importar configuraci√≥n si existe
                        if "config" in imported_data:
                            self.config_manager.config = imported_data["config"]
                            self.config_manager.save_config()
                            self.apply_config_changes()

                        QMessageBox.information(
                            self,
                            "Importaci√≥n Exitosa",
                            "Datos importados exitosamente.",
                        )

                    except Exception as e:
                        QMessageBox.critical(
                            self,
                            "Error de Importaci√≥n",
                            f"Error procesando datos importados:\n{str(e)}",
                        )
                else:
                    QMessageBox.critical(
                        self,
                        "Error de Importaci√≥n",
                        "No se pudieron leer los datos del archivo.",
                    )

    def change_theme(self, theme_key):
        """Cambiar a un tema espec√≠fico"""
        self.theme_manager.set_theme(theme_key)
        self.config_manager.set("appearance", "theme", theme_key)
        self.setStyleSheet(self.theme_manager.get_stylesheet("main"))
        self.statusBar().showMessage(
            f"‚ú® Tema cambiado a: {self.theme_manager.themes[theme_key]['name']}", 3000
        )

    def toggle_theme(self):
        """Alternar tema claro/oscuro"""
        self.theme_manager.toggle_theme()
        self.setStyleSheet(self.theme_manager.get_stylesheet("main"))

    def toggle_fullscreen(self):
        """Alternar pantalla completa"""
        if self.isFullScreen():
            self.showNormal()
        else:
            self.showFullScreen()

    def restore_geometry(self):
        """Restaurar geometr√≠a de la ventana principal"""
        self.geometry_manager.restore_window_geometry(self, "main_window", (1000, 700))

    def select_all_items(self):
        """Seleccionar todos los elementos para operaciones masivas"""
        for widget in self.drop_area.item_widgets.values():
            widget.set_batch_selection(True)
        self.update_status_bar()

    def select_none_items(self):
        """Deseleccionar todos los elementos"""
        for widget in self.drop_area.item_widgets.values():
            widget.set_batch_selection(False)
        self.update_status_bar()

    def refresh_all_items(self):
        """Actualizar informaci√≥n de todos los archivos y carpetas"""
        if not self.drop_area.items:
            QMessageBox.information(
                self, "Sin elementos", "No hay elementos para actualizar."
            )
            return

        # Mostrar di√°logo de progreso
        progress = QMessageBox(self)
        progress.setWindowTitle("Actualizando...")
        progress.setText("Verificando archivos y carpetas...")
        progress.setStandardButtons(QMessageBox.StandardButton.NoButton)
        progress.show()
        QApplication.processEvents()

        removed_count = 0
        updated_count = 0
        error_count = 0
        items_to_remove = []

        # Verificar cada item
        for widget in list(self.drop_area.item_widgets.values()):
            try:
                path = widget.file_item.path

                # Verificar si el archivo existe
                if not os.path.exists(path):
                    items_to_remove.append(path)
                    removed_count += 1
                else:
                    # Actualizar informaci√≥n
                    if os.path.isfile(path):
                        widget.file_item.size = os.path.getsize(path)
                        widget.file_item.modified = os.path.getmtime(path)

                    widget.file_item.name = os.path.basename(path)

                    # Limpiar cach√©
                    if hasattr(widget, "performance_manager"):
                        widget.performance_manager.clear_cache()

                    # Actualizar UI
                    widget.update_info()
                    updated_count += 1

            except Exception as e:
                print(f"Error actualizando {path}: {e}")
                error_count += 1

        # Eliminar items que ya no existen
        for path in items_to_remove:
            self.drop_area.remove_item(path)

        progress.close()

        # Mostrar resultados
        message = f"‚úÖ Actualizaci√≥n completada:\n\n"
        message += f"‚Ä¢ Actualizados: {updated_count}\n"
        if removed_count > 0:
            message += f"‚Ä¢ Eliminados (no encontrados): {removed_count}\n"
        if error_count > 0:
            message += f"‚Ä¢ Errores: {error_count}\n"

        QMessageBox.information(self, "Actualizaci√≥n Completada", message)

        self.update_status_bar()

    def manage_clipboard(self):
        """Gestionar elementos del clipboard m√∫ltiple"""
        clipboard_items = self.drop_area.multi_clipboard.get_items()

        if not clipboard_items:
            QMessageBox.information(
                self,
                "Clipboard Vac√≠o",
                "No hay elementos en el clipboard para gestionar.",
            )
            return

        # Mostrar di√°logo de gesti√≥n del clipboard
        dialog = ClipboardManagerDialog(self.drop_area.multi_clipboard, self)
        dialog.exec()
        self.update_status_bar()

    def show_quick_paste_dialog(self):
        """Mostrar di√°logo de pegado r√°pido"""
        if not self.drop_area.items:
            QMessageBox.information(
                self,
                "Sin Archivos",
                "No hay archivos guardados en la aplicaci√≥n para pegar.\n\nüí° Arrastra algunos archivos primero a la ventana principal.",
            )
            return

        # Verificar configuraci√≥n para usar solo Pegado Global
        config_manager = AdvancedConfigManager()
        use_global = config_manager.get("behavior", "use_global_quick_paste", False)

        if use_global:
            # Usar ventana de Pegado Global en su lugar
            target_folder = self.get_current_working_directory()
            # Normalizar ruta para soportar rutas de red UNC correctamente
            target_folder = normalize_network_path(target_folder)
            dialog = GlobalQuickPasteDialog(self.drop_area.items, target_folder, self)
            dialog.exec()
            return

        # Verificar si la ventana tiene el foco
        if not self.isActiveWindow():
            # Traer ventana al frente
            self.raise_()
            self.activateWindow()

            # Mostrar notificaci√≥n sobre la limitaci√≥n
            QMessageBox.information(
                self,
                "‚ö° Pegado R√°pido Activado",
                "Nota: El pegado r√°pido (Ctrl+Alt+V) funciona cuando la aplicaci√≥n\n"
                "tiene el foco. Se pegar√° en el directorio mostrado en la barra de estado.\n\n"
                "üí° Para pegar en una ubicaci√≥n espec√≠fica:\n"
                "1. Navega a la carpeta deseada en el explorador\n"
                "2. Vuelve a la aplicaci√≥n y usa Ctrl+Alt+V\n"
                "3. O usa 'Copiar Seleccionados' para elegir destino manualmente",
            )

        # Mostrar di√°logo de pegado r√°pido normal
        dialog = QuickPasteDialog(self.drop_area.items, self)
        dialog.exec()

    @pyqtSlot(str)
    def show_global_quick_paste(self, target_folder=""):
        """Mostrar pegado r√°pido global con carpeta detectada autom√°ticamente"""
        try:
            # Usar target_folder o detectar uno por defecto
            if not target_folder:
                target_folder = self.get_current_working_directory()

            # Normalizar ruta para soportar rutas de red UNC correctamente
            target_folder = normalize_network_path(target_folder)

            print(f"Mostrando pegado global para: {target_folder}")

            # NO mostrar la ventana principal - solo el di√°logo de pegado

            if not hasattr(self, "drop_area") or not self.drop_area.items:
                # Crear di√°logo personalizado sin mostrar la ventana principal
                no_files_dialog = NoFilesDialog(target_folder, self)
                no_files_dialog.exec()
                return

            # Crear di√°logo especializado para pegado global (sin mostrar ventana principal)
            dialog = GlobalQuickPasteDialog(self.drop_area.items, target_folder, self)
            dialog.exec()
        except Exception as e:
            print(f"Error mostrando pegado global: {e}")

    def capture_selected_files(self):
        """Capturar archivos seleccionados del sistema con Ctrl+Alt+C"""
        files = []
        try:
            print("\n=== CAPTURANDO ARCHIVOS SELECCIONADOS ===")

            # M√©todo 1: Intentar desde el portapapeles primero (m√°s seguro)
            try:
                print("M√©todo 1: Intentando obtener archivos del portapapeles...")
                files = self.get_files_from_clipboard()
                if files:
                    print(f"‚úì Archivos encontrados en portapapeles: {len(files)}")
            except Exception as e:
                print(f"Error en m√©todo 1 (portapapeles): {e}")

            # M√©todo 2: Obtener de Explorer activo
            if not files:
                try:
                    print(
                        "M√©todo 2: Intentando obtener archivos del Explorer activo..."
                    )
                    files = self.get_selected_files_from_explorer()
                    if files:
                        print(f"‚úì Archivos encontrados en Explorer: {len(files)}")
                except Exception as e:
                    print(f"Error en m√©todo 2 (Explorer): {e}")

            # M√©todo 3: Usar UIAutomation como √∫ltimo recurso
            if not files:
                try:
                    print("M√©todo 3: Intentando con UIAutomation...")
                    files = self.get_selected_files_uiautomation()
                    if files:
                        print(f"‚úì Archivos encontrados con UIAutomation: {len(files)}")
                except Exception as e:
                    print(f"Error en m√©todo 3 (UIAutomation): {e}")

            print(f"Total de archivos encontrados: {len(files)}")

            if files:
                added_count = 0
                skipped_count = 0
                duplicate_count = 0

                for file_path in files:
                    print(f"Procesando: {file_path}")
                    if os.path.exists(file_path):
                        # Agregar a la lista en modo silencioso (sin MessageBox)
                        result = self.add_single_file(file_path, silent=True)
                        if result:
                            added_count += 1
                            print(f"  ‚úì Agregado: {file_path}")
                        else:
                            # Ya estaba en la lista
                            duplicate_count += 1
                            print(f"  ‚ö†Ô∏è Ya existe: {file_path}")
                    else:
                        print(f"  ‚úó No existe: {file_path}")
                        skipped_count += 1

                # Guardar cambios
                if added_count > 0:
                    self.save_data()

                if added_count > 0:
                    # Mostrar notificaci√≥n de √©xito
                    msg = f"{added_count} archivo(s) agregado(s) a la lista.\nUsa Ctrl+Alt+V para pegarlos."
                    if skipped_count > 0:
                        msg += f"\n({skipped_count} archivos ya estaban en la lista)"

                    self.tray_icon.showMessage(
                        "‚úÖ Archivos Capturados",
                        msg,
                        QSystemTrayIcon.MessageIcon.Information,
                        3000,
                    )
                    print(f"‚úì Se agregaron {added_count} archivos a la lista")
                else:
                    self.tray_icon.showMessage(
                        "‚ö†Ô∏è Sin Archivos Nuevos",
                        "Los archivos ya est√°n en la lista.",
                        QSystemTrayIcon.MessageIcon.Warning,
                        2000,
                    )
            else:
                # No se encontraron archivos
                self.tray_icon.showMessage(
                    "‚ö†Ô∏è No se Detectaron Archivos",
                    "1. Selecciona archivos en el Explorador\n"
                    "2. Presiona Ctrl+C para copiarlos\n"
                    "3. Presiona Ctrl+Alt+C para capturarlos\n\n"
                    "O mant√©n archivos seleccionados y presiona Ctrl+Alt+C",
                    QSystemTrayIcon.MessageIcon.Warning,
                    5000,
                )
                print("‚úó No se detectaron archivos seleccionados")

            print("=== FIN CAPTURA ===\n")

        except Exception as e:
            print(f"‚úó Error capturando archivos: {e}")
            import traceback

            traceback.print_exc()
            self.tray_icon.showMessage(
                "‚ùå Error",
                f"Error capturando archivos: {str(e)}",
                QSystemTrayIcon.MessageIcon.Critical,
                2000,
            )

    def show_main_window(self):
        """Mostrar la ventana principal (atajo configurable)"""
        try:
            print("Mostrando ventana principal...")
            # Mostrar ventana
            self.show()
            # Activar ventana (traer al frente)
            self.activateWindow()
            # En Windows, usar setWindowState para asegurar que se muestre correctamente
            self.setWindowState(
                self.windowState() & ~Qt.WindowState.WindowMinimized
                | Qt.WindowState.WindowActive
            )
            # Elevar la ventana al frente
            self.raise_()
            print("Ventana principal mostrada correctamente")

            # Notificaci√≥n opcional
            if hasattr(self, "tray_icon"):
                self.tray_icon.showMessage(
                    "üëÅÔ∏è Ventana Visible",
                    "La ventana principal se ha restaurado",
                    QSystemTrayIcon.MessageIcon.Information,
                    1500,
                )
        except Exception as e:
            print(f"Error mostrando ventana: {e}")

    def hide_main_window(self):
        """Ocultar la ventana principal (atajo configurable)"""
        try:
            print("Ocultando ventana principal...")
            # Ocultar ventana
            self.hide()
            print("Ventana principal ocultada correctamente")

            # Notificaci√≥n opcional
            if hasattr(self, "tray_icon"):
                self.tray_icon.showMessage(
                    "üîΩ Ventana Oculta",
                    "La ventana principal se ha minimizado a la bandeja del sistema",
                    QSystemTrayIcon.MessageIcon.Information,
                    1500,
                )
        except Exception as e:
            print(f"Error ocultando ventana: {e}")

    def get_files_from_clipboard(self):
        """Obtener archivos del portapapeles de Windows"""
        files = []
        try:
            import win32clipboard

            print("  Abriendo portapapeles...")
            win32clipboard.OpenClipboard()
            try:
                print("  Verificando formato CF_HDROP...")
                if win32clipboard.IsClipboardFormatAvailable(win32clipboard.CF_HDROP):
                    print("  Formato disponible, obteniendo datos...")
                    clipboard_data = win32clipboard.GetClipboardData(
                        win32clipboard.CF_HDROP
                    )
                    if clipboard_data:
                        files = list(clipboard_data)
                        print(f"  ‚úì {len(files)} archivos encontrados en portapapeles:")
                        for f in files:
                            print(f"    - {f}")
                    else:
                        print("  ‚úó Portapapeles vac√≠o (no hay datos)")
                else:
                    print("  ‚úó Formato CF_HDROP no disponible en el portapapeles")
                    print("  Esto significa que no hay archivos copiados")
            finally:
                win32clipboard.CloseClipboard()
                print("  Portapapeles cerrado")
        except Exception as e:
            print(f"  ‚úó Error obteniendo archivos del portapapeles: {e}")
            import traceback

            traceback.print_exc()

        return files

    def get_selected_files_from_explorer(self):
        """Obtener archivos seleccionados del Explorer de Windows"""
        files = []
        try:
            import win32com.client

            print("Creando conexi√≥n con Shell.Application...")
            shell = win32com.client.Dispatch("Shell.Application")

            # Buscar en TODAS las ventanas del Explorer
            print("Buscando archivos seleccionados en ventanas del Explorer...")

            for window in shell.Windows():
                try:
                    # Intentar obtener items seleccionados
                    selected_items = window.Document.SelectedItems()

                    if selected_items and selected_items.Count > 0:
                        for item in selected_items:
                            try:
                                if hasattr(item, "Path") and item.Path:
                                    files.append(item.Path)
                                    print(f"  ‚úì Archivo encontrado: {item.Path}")
                            except Exception as e:
                                print(f"  Error procesando item: {e}")
                                continue

                except Exception as e:
                    # Algunas ventanas pueden no ser accesibles, continuar con la siguiente
                    continue

            if files:
                print(f"Total de archivos encontrados en Explorer: {len(files)}")
            else:
                print("No se encontraron archivos seleccionados en Explorer")

        except Exception as e:
            print(f"Error obteniendo archivos del Explorer: {e}")
            import traceback

            traceback.print_exc()

        return files

    def get_selected_files_uiautomation(self):
        """M√©todo alternativo simplificado (desactivado por estabilidad)"""
        # Este m√©todo se desactiva para evitar crashes
        # El usuario debe usar Ctrl+C manualmente antes de Ctrl+Alt+C
        print("  M√©todo UIAutomation desactivado por estabilidad")
        return []

    def start_global_hooks(self):
        """Iniciar hooks globales"""
        if not self.global_hotkey_manager or not hasattr(self, "drop_area"):
            print("No se puede iniciar hooks: faltan dependencias")
            return

        try:
            print("Intentando iniciar hooks globales...")
            success = self.global_hotkey_manager.start_global_listener()
            if success:
                self.logger.info("Sistema de hooks globales iniciado correctamente")
                # Actualizar mensaje de barra de estado
                self.update_status_bar()
                print("Hooks globales iniciados exitosamente!")
            else:
                self.logger.warning("No se pudieron inicializar los hooks globales")
                print("Error: No se pudieron inicializar los hooks globales")
        except Exception as e:
            self.logger.error(f"Error iniciando hooks globales: {e}")
            print(f"Excepci√≥n al iniciar hooks: {e}")

    def setup_system_tray(self):
        """Configurar icono de bandeja del sistema"""
        if not QSystemTrayIcon.isSystemTrayAvailable():
            QMessageBox.critical(
                None,
                "System Tray",
                "No se detect√≥ soporte para bandeja del sistema.\n"
                "La aplicaci√≥n no podr√° funcionar en segundo plano.",
            )
            return

        # Crear icono de bandeja
        self.tray_icon = QSystemTrayIcon(self)

        # Crear icono simple (puedes cambiarlo por un archivo .ico)
        from PyQt6.QtGui import QPixmap, QPainter, QBrush

        pixmap = QPixmap(32, 32)
        pixmap.fill(Qt.GlobalColor.transparent)

        painter = QPainter(pixmap)
        painter.setBrush(QBrush(QColor(74, 144, 226)))
        painter.drawEllipse(2, 2, 28, 28)
        painter.setPen(QColor(255, 255, 255))
        painter.drawText(pixmap.rect(), Qt.AlignmentFlag.AlignCenter, "üìÅ")
        painter.end()

        icon = QIcon(pixmap)
        self.tray_icon.setIcon(icon)

        # Crear men√∫ contextual para la bandeja
        tray_menu = QMenu()

        show_action = tray_menu.addAction("üîç Mostrar Ventana")
        show_action.triggered.connect(self.show_main_window)

        quick_paste_action = tray_menu.addAction("‚ö° Pegado R√°pido (Ctrl+Alt+V)")
        quick_paste_action.triggered.connect(self.show_quick_paste_dialog)

        tray_menu.addSeparator()

        quit_action = tray_menu.addAction("‚ùå Salir Completamente")
        quit_action.triggered.connect(self.quit_application)

        self.tray_icon.setContextMenu(tray_menu)

        # Conectar doble clic para mostrar ventana
        self.tray_icon.activated.connect(self.on_tray_icon_activated)

        # Mostrar el icono de la bandeja
        self.tray_icon.show()

        # Tooltip
        self.tray_icon.setToolTip(
            "üìÅ Gestor de Archivos\n"
            "‚ú® Ctrl+C ‚Üí Ctrl+Alt+C - Capturar archivos\n"
            "‚ö° Ctrl+Alt+V - Pegar archivos\n"
            "üîÑ Funcionando en segundo plano"
        )

    def on_tray_icon_activated(self, reason):
        """Manejar clicks en el icono de la bandeja"""
        if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.show_main_window()

    def show_main_window(self):
        """Mostrar la ventana principal"""
        self.show()
        self.raise_()
        self.activateWindow()

    def change_working_directory(self):
        """Cambiar directorio de trabajo de la aplicaci√≥n"""
        current_dir = self.get_current_working_directory()

        new_dir = QFileDialog.getExistingDirectory(
            self,
            "Seleccionar Nuevo Directorio de Trabajo",
            current_dir,
            QFileDialog.Option.ShowDirsOnly | QFileDialog.Option.DontResolveSymlinks,
        )

        if new_dir:
            try:
                os.chdir(new_dir)
                self.update_status_bar()
                QMessageBox.information(
                    self,
                    "üìÇ Directorio Cambiado",
                    f"‚úÖ Directorio de trabajo cambiado a:\n\nüìÅ {new_dir}\n\n"
                    f"üí° Ahora Ctrl+Alt+V pegar√° archivos en esta ubicaci√≥n.",
                )
                self.logger.info(f"Directorio de trabajo cambiado a: {new_dir}")
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "‚ùå Error",
                    f"No se pudo cambiar al directorio:\n{new_dir}\n\nError: {str(e)}",
                )
                self.logger.error(f"Error cambiando directorio: {e}")

    def closeEvent(self, event):
        """Evento al cerrar la aplicaci√≥n - Minimizar a bandeja en lugar de cerrar"""
        if self.tray_icon.isVisible():
            # Minimizar a la bandeja del sistema
            self.hide()
            self.tray_icon.showMessage(
                "‚ö° Funcionando en Segundo Plano",
                "Ctrl+Alt+V sigue ACTIVO desde cualquier aplicaci√≥n.\n"
                "üëÄ Busca el icono üìÅ en la bandeja del sistema.\n"
                "üñ±Ô∏è Clic derecho en el icono para ver opciones.",
                QSystemTrayIcon.MessageIcon.Information,
                4000,
            )
            event.ignore()  # No cerrar realmente
        else:
            # Si no hay system tray, cerrar normalmente
            self.quit_application()
            event.accept()

    def quit_application(self):
        """Cerrar completamente la aplicaci√≥n"""
        self.save_data()
        # Guardar geometr√≠a
        self.geometry_manager.save_window_geometry("main_window", self.geometry())

        # Trigger plugin hook
        self.plugin_manager.trigger_hook("app_closing", self)

        # Detener hooks globales
        if self.global_hotkey_manager:
            self.global_hotkey_manager.stop_global_listener()

        # Limpiar recursos
        self.performance_manager.shutdown()

        # Log de cierre
        self.logger.info("Aplicaci√≥n cerrada correctamente")

        # Salir de la aplicaci√≥n
        QApplication.quit()

    def get_current_working_directory(self):
        """Obtener el directorio de trabajo m√°s relevante"""
        try:
            # Intentar obtener el directorio actual del proceso
            cwd = os.getcwd()

            # Si estamos en el directorio de la aplicaci√≥n, intentar algo m√°s √∫til
            app_dir = os.path.dirname(os.path.abspath(__file__))

            if cwd == app_dir:
                # Si estamos en el directorio de la app, usar el escritorio como alternativa
                desktop = os.path.join(os.path.expanduser("~"), "Desktop")
                if os.path.exists(desktop):
                    return desktop
                else:
                    # Si no existe Desktop, usar home
                    return os.path.expanduser("~")

            return cwd

        except Exception as e:
            # Fallback al home del usuario
            return os.path.expanduser("~")


class AdvancedConfigDialog(QDialog):
    """Di√°logo de configuraci√≥n avanzada"""

    def __init__(self, config_manager, parent=None):
        super().__init__(parent)
        self.config_manager = config_manager
        self.setWindowTitle("‚öôÔ∏è Configuraci√≥n Avanzada")
        set_window_icon(self)
        self.setMinimumSize(600, 820)
        self.resize(700, 780)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        self.load_current_config()
        self.restore_geometry()

    def setup_ui(self):
        """Configurar interfaz del di√°logo"""
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)

        # T√≠tulo
        title_label = QLabel("‚öôÔ∏è Configuraci√≥n Avanzada del Sistema")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(12)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 10px;")
        layout.addWidget(title_label)

        # Pesta√±as de configuraci√≥n
        self.config_tabs = QTabWidget()

        # Pesta√±a Apariencia
        appearance_tab = self.create_appearance_tab()
        self.config_tabs.addTab(appearance_tab, "üé® Apariencia")

        # Pesta√±a Rendimiento
        performance_tab = self.create_performance_tab()
        self.config_tabs.addTab(performance_tab, "‚ö° Rendimiento")

        # Pesta√±a Comportamiento
        behavior_tab = self.create_behavior_tab()
        self.config_tabs.addTab(behavior_tab, "‚öôÔ∏è Comportamiento")

        # Pesta√±a Atajos
        shortcuts_tab = self.create_shortcuts_tab()
        self.config_tabs.addTab(shortcuts_tab, "‚å®Ô∏è Atajos de Teclado")

        # Pesta√±a Funciones en Desarrollo
        dev_tab = self.create_dev_functions_tab()
        self.config_tabs.addTab(dev_tab, "üîß Funciones en Desarrollo")

        layout.addWidget(self.config_tabs)

        # Botones
        buttons_layout = QHBoxLayout()

        self.reset_btn = QPushButton("üîÑ Restablecer")
        self.reset_btn.clicked.connect(self.reset_to_defaults)

        self.apply_btn = QPushButton("‚úÖ Aplicar")
        self.apply_btn.clicked.connect(self.apply_changes)

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)

        self.ok_btn = QPushButton("üíæ Aceptar")
        self.ok_btn.clicked.connect(self.accept_changes)

        buttons_layout.addWidget(self.reset_btn)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.apply_btn)
        buttons_layout.addWidget(self.cancel_btn)
        buttons_layout.addWidget(self.ok_btn)

        layout.addLayout(buttons_layout)

    def create_appearance_tab(self):
        """Crear pesta√±a de apariencia"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Tema
        theme_group = QGroupBox("üé® Tema")
        theme_layout = QVBoxLayout(theme_group)

        theme_layout.addWidget(QLabel("Selecciona un tema:"))
        self.theme_combo = QComboBox()

        # A√±adir temas disponibles
        theme_names = self.theme_manager.get_theme_names()
        for theme_key, theme_name in theme_names.items():
            self.theme_combo.addItem(theme_name, theme_key)

        # Conectar cambio de tema para vista previa
        self.theme_combo.currentIndexChanged.connect(self.preview_theme)

        theme_layout.addWidget(self.theme_combo)

        layout.addWidget(theme_group)

        # Animaciones
        animation_group = QGroupBox("‚ú® Animaciones")
        animation_layout = QVBoxLayout(animation_group)

        self.animations_enabled = QCheckBox("Habilitar animaciones")
        self.show_tooltips = QCheckBox("Mostrar tooltips")
        animation_layout.addWidget(self.animations_enabled)
        animation_layout.addWidget(self.show_tooltips)

        layout.addWidget(animation_group)

        # Opacidad
        opacity_group = QGroupBox("üëª Transparencia")
        opacity_layout = QVBoxLayout(opacity_group)

        opacity_layout.addWidget(QLabel("Opacidad de ventana (50% - 100%):"))
        self.opacity_slider = QSpinBox()
        self.opacity_slider.setRange(50, 100)
        self.opacity_slider.setSuffix("%")
        self.opacity_slider.valueChanged.connect(self.on_opacity_changed)
        self.opacity_slider.setToolTip(
            "Ajusta la transparencia de la ventana principal.\n"
            "100% = Opaco (sin transparencia)\n"
            "50% = M√°xima transparencia permitida"
        )
        opacity_layout.addWidget(self.opacity_slider)

        layout.addWidget(opacity_group)
        layout.addStretch()

        return tab

    def create_performance_tab(self):
        """Crear pesta√±a de rendimiento"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Clipboard
        clipboard_group = QGroupBox("üìã Clipboard")
        clipboard_layout = QVBoxLayout(clipboard_group)

        clipboard_layout.addWidget(QLabel("M√°ximo elementos en clipboard:"))
        self.max_clipboard_items = QSpinBox()
        self.max_clipboard_items.setRange(10, 200)
        clipboard_layout.addWidget(self.max_clipboard_items)

        layout.addWidget(clipboard_group)

        # Cach√©
        cache_group = QGroupBox("üíæ Cach√©")
        cache_layout = QVBoxLayout(cache_group)

        self.cache_enabled = QCheckBox("Habilitar cach√© de archivos")
        self.virtual_scrolling = QCheckBox("Scroll virtual (mejor rendimiento)")
        cache_layout.addWidget(self.cache_enabled)
        cache_layout.addWidget(self.virtual_scrolling)

        layout.addWidget(cache_group)

        # Display
        display_group = QGroupBox("üì∫ Visualizaci√≥n")
        display_layout = QVBoxLayout(display_group)

        display_layout.addWidget(QLabel("M√°ximo elementos mostrados:"))
        self.max_display_items = QSpinBox()
        self.max_display_items.setRange(100, 2000)
        display_layout.addWidget(self.max_display_items)

        layout.addWidget(display_group)
        layout.addStretch()

        return tab

    def create_behavior_tab(self):
        """Crear pesta√±a de comportamiento"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Auto-save
        autosave_group = QGroupBox("üíæ Auto-guardado")
        autosave_layout = QVBoxLayout(autosave_group)

        autosave_layout.addWidget(QLabel("Intervalo de auto-guardado (segundos):"))
        self.auto_save_interval = QSpinBox()
        self.auto_save_interval.setRange(10, 300)
        autosave_layout.addWidget(self.auto_save_interval)

        layout.addWidget(autosave_group)

        # Confirmaciones
        confirm_group = QGroupBox("‚ùì Confirmaciones")
        confirm_layout = QVBoxLayout(confirm_group)

        self.confirm_deletions = QCheckBox("Confirmar eliminaciones")
        self.remember_window_positions = QCheckBox("Recordar posiciones de ventana")
        confirm_layout.addWidget(self.confirm_deletions)
        confirm_layout.addWidget(self.remember_window_positions)

        layout.addWidget(confirm_group)

        # Plugins
        plugins_group = QGroupBox("üîå Plugins")
        plugins_layout = QVBoxLayout(plugins_group)

        self.enable_plugins = QCheckBox("Habilitar sistema de plugins")
        plugins_layout.addWidget(self.enable_plugins)

        layout.addWidget(plugins_group)

        # Inicio en segundo plano
        startup_group = QGroupBox("üöÄ Inicio de Aplicaci√≥n")
        startup_layout = QVBoxLayout(startup_group)

        self.start_in_background = QCheckBox("Iniciar en segundo plano")
        self.start_in_background.setToolTip(
            "La aplicaci√≥n iniciar√° minimizada a la bandeja del sistema"
        )
        startup_layout.addWidget(self.start_in_background)

        self.close_quick_paste_after_pasting = QCheckBox(
            "Cerrar pegado r√°pido despu√©s de pegar"
        )
        self.close_quick_paste_after_pasting.setToolTip(
            "Si est√° marcado, la ventana de pegado r√°pido se cerrar√° autom√°ticamente despu√©s de pegar.\n"
            "Si no, permanecer√° abierta para pegar m√°s archivos."
        )
        startup_layout.addWidget(self.close_quick_paste_after_pasting)

        self.use_global_quick_paste = QCheckBox(
            "Usar solo Pegado Global (desactivar Pegado R√°pido)"
        )
        self.use_global_quick_paste.setToolTip(
            "Si est√° marcado, se desactivar√° la ventana de 'Pegado R√°pido' normal\n"
            "y solo se usar√° la ventana de 'Pegado Global' con detecci√≥n autom√°tica de carpeta."
        )
        startup_layout.addWidget(self.use_global_quick_paste)

        startup_layout.addWidget(QLabel(""))  # Separador

        self.auto_start_windows = QCheckBox("‚öôÔ∏è Iniciar autom√°ticamente con Windows")
        self.auto_start_windows.setToolTip(
            "Crea un acceso directo en la carpeta de inicio de Windows\n"
            "para que la aplicaci√≥n se ejecute autom√°ticamente al encender el ordenador.\n"
            "Nota: Solo funciona si ejecutas la aplicaci√≥n como .exe"
        )
        self.auto_start_windows.toggled.connect(self.on_auto_start_toggled)
        startup_layout.addWidget(self.auto_start_windows)

        layout.addWidget(startup_group)
        layout.addStretch()

        return tab

    def create_dev_functions_tab(self):
        """Crear pesta√±a de funciones en desarrollo"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Informaci√≥n general
        info_group = QGroupBox("‚ö†Ô∏è Funciones Experimentales")
        info_layout = QVBoxLayout(info_group)

        info_text = QLabel(
            "Esta secci√≥n contiene funciones experimentales y en desarrollo.\n\n"
            "‚ö†Ô∏è ADVERTENCIA: Estas funciones pueden ser inestables o cambiar en futuras versiones.\n"
            "√ösalas bajo tu propia responsabilidad."
        )
        info_text.setStyleSheet(
            "color: #ff9f43; font-size: 10pt; padding: 15px; background-color: rgba(255, 159, 67, 0.1); border-radius: 8px;"
        )
        info_text.setWordWrap(True)
        info_layout.addWidget(info_text)

        layout.addWidget(info_group)

        # Dashboard Control
        dashboard_group = QGroupBox("üìä Control de Dashboard")
        dashboard_layout = QVBoxLayout(dashboard_group)

        # Estado actual del Dashboard
        self.dashboard_status_label = QLabel("Estado: Desactivado")
        self.dashboard_status_label.setStyleSheet(
            "color: #ff4444; font-weight: bold; font-size: 11pt;"
        )
        dashboard_layout.addWidget(self.dashboard_status_label)

        # Contrase√±a para activar/desactivar
        password_layout = QHBoxLayout()
        password_layout.addWidget(QLabel("Contrase√±a:"))
        self.dashboard_password_input = QLineEdit()
        self.dashboard_password_input.setPlaceholderText(
            "Ingresa contrase√±a para activar/desactivar Dashboard"
        )
        self.dashboard_password_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.dashboard_password_input.setStyleSheet("""
            QLineEdit {
                background-color: rgba(42, 42, 42, 0.8);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 6px;
                padding: 8px;
                color: #ffffff;
            }
            QLineEdit:focus {
                border: 2px solid #4a90e2;
            }
        """)
        password_layout.addWidget(self.dashboard_password_input)
        dashboard_layout.addLayout(password_layout)

        # Botones de control
        button_layout = QHBoxLayout()

        self.activate_dashboard_btn = QPushButton("üîì Activar Dashboard")
        self.activate_dashboard_btn.setStyleSheet("""
            QPushButton {
                background-color: #26de81;
                border: none;
                border-radius: 6px;
                color: #ffffff;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #16ce71;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #aaaaaa;
            }
        """)
        self.activate_dashboard_btn.clicked.connect(self.activate_dashboard)
        button_layout.addWidget(self.activate_dashboard_btn)

        self.deactivate_dashboard_btn = QPushButton("üîí Desactivar Dashboard")
        self.deactivate_dashboard_btn.setStyleSheet("""
            QPushButton {
                background-color: #ff4444;
                border: none;
                border-radius: 6px;
                color: #ffffff;
                padding: 8px 16px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #ff3333;
            }
            QPushButton:disabled {
                background-color: #666666;
                color: #aaaaaa;
            }
        """)
        self.deactivate_dashboard_btn.clicked.connect(self.deactivate_dashboard)
        button_layout.addWidget(self.deactivate_dashboard_btn)

        dashboard_layout.addLayout(button_layout)

        # Informaci√≥n sobre el Dashboard
        dashboard_info = QLabel(
            "El Dashboard es una funci√≥n experimental que incluye:\n"
            "‚Ä¢ Gesti√≥n de notas y tareas\n"
            "‚Ä¢ Calendario integrado\n"
            "‚Ä¢ Panel de actividad reciente\n\n"
            "Esta funci√≥n est√° en desarrollo y puede tener limitaciones."
        )
        dashboard_info.setStyleSheet(
            "color: #aaaaaa; font-size: 9pt; padding: 10px; background-color: rgba(42, 42, 42, 0.3); border-radius: 6px;"
        )
        dashboard_info.setWordWrap(True)
        dashboard_layout.addWidget(dashboard_info)

        layout.addWidget(dashboard_group)

        # Espaciador
        layout.addStretch()

        return tab

    def create_shortcuts_tab(self):
        """Crear pesta√±a de atajos de teclado"""
        tab = QWidget()
        layout = QVBoxLayout(tab)

        # Informaci√≥n general
        info_group = QGroupBox("‚ÑπÔ∏è Informaci√≥n")
        info_layout = QVBoxLayout(info_group)

        info_text = QLabel(
            "Configura atajos de teclado globales personalizados.\n\n"
            "Los atajos funcionan desde cualquier aplicaci√≥n cuando el gestor est√° ejecut√°ndose.\n\n"
            "Formato: <ctrl>+<alt>+tecla o <ctrl>+<shift>+tecla\n"
            "Ejemplos: <ctrl>+<alt>+s, <ctrl>+<shift>+h, <ctrl>+<alt>+<shift>+m"
        )
        info_text.setStyleSheet("color: #aaaaaa; font-size: 9pt; padding: 10px;")
        info_text.setWordWrap(True)
        info_layout.addWidget(info_text)

        layout.addWidget(info_group)

        # Atajos de Ventana
        window_group = QGroupBox("ü™ü Atajos de Ventana")
        window_layout = QVBoxLayout(window_group)

        # Atajo para mostrar ventana
        show_layout = QHBoxLayout()
        show_label = QLabel("Mostrar Ventana:")
        show_label.setMinimumWidth(140)
        self.show_window_shortcut = QLineEdit()
        self.show_window_shortcut.setPlaceholderText("Ej: <ctrl>+<alt>+s")
        self.show_window_shortcut.setToolTip(
            "Atajo de teclado global para mostrar la ventana principal cuando est√° oculta.\n"
            "Formato: <ctrl>+<alt>+tecla\n"
            "Ejemplo: <ctrl>+<alt>+s"
        )
        show_layout.addWidget(show_label)
        show_layout.addWidget(self.show_window_shortcut)
        window_layout.addLayout(show_layout)

        # Atajo para ocultar ventana
        hide_layout = QHBoxLayout()
        hide_label = QLabel("Ocultar Ventana:")
        hide_label.setMinimumWidth(140)
        self.hide_window_shortcut = QLineEdit()
        self.hide_window_shortcut.setPlaceholderText("Ej: <ctrl>+<alt>+h")
        self.hide_window_shortcut.setToolTip(
            "Atajo de teclado global para ocultar la ventana principal al fondo.\n"
            "Formato: <ctrl>+<alt>+tecla\n"
            "Ejemplo: <ctrl>+<alt>+h"
        )
        hide_layout.addWidget(hide_label)
        hide_layout.addWidget(self.hide_window_shortcut)
        window_layout.addLayout(hide_layout)

        layout.addWidget(window_group)

        # Atajos de Archivos
        files_group = QGroupBox("üìÇ Atajos de Archivos")
        files_layout = QVBoxLayout(files_group)

        # Atajo para pegado r√°pido
        paste_layout = QHBoxLayout()
        paste_label = QLabel("Pegado R√°pido:")
        paste_label.setMinimumWidth(140)
        self.quick_paste_shortcut = QLineEdit()
        self.quick_paste_shortcut.setPlaceholderText("Ej: <ctrl>+<alt>+v")
        self.quick_paste_shortcut.setToolTip(
            "Atajo de teclado global para abrir el pegado r√°pido de archivos.\n"
            "Formato: <ctrl>+<alt>+tecla\n"
            "Ejemplo: <ctrl>+<alt>+v"
        )
        paste_layout.addWidget(paste_label)
        paste_layout.addWidget(self.quick_paste_shortcut)
        files_layout.addLayout(paste_layout)

        # Atajo para copiar archivos
        copy_layout = QHBoxLayout()
        copy_label = QLabel("Copiar Archivos:")
        copy_label.setMinimumWidth(140)
        self.quick_copy_shortcut = QLineEdit()
        self.quick_copy_shortcut.setPlaceholderText("Ej: <ctrl>+<alt>+c")
        self.quick_copy_shortcut.setToolTip(
            "Atajo de teclado global para copiar archivos seleccionados al gestor.\n"
            "Formato: <ctrl>+<alt>+tecla\n"
            "Ejemplo: <ctrl>+<alt>+c"
        )
        copy_layout.addWidget(copy_label)
        copy_layout.addWidget(self.quick_copy_shortcut)
        files_layout.addLayout(copy_layout)

        layout.addWidget(files_group)

        # Bot√≥n para probar atajos
        test_layout = QHBoxLayout()
        test_layout.addStretch()
        test_shortcut_btn = QPushButton("üß™ Probar y Validar Atajos")
        test_shortcut_btn.clicked.connect(self.test_shortcuts)
        test_shortcut_btn.setFixedWidth(200)
        test_shortcut_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                border: none;
                border-radius: 6px;
                padding: 10px 16px;
                font-size: 10pt;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #138496;
            }
        """)
        test_layout.addWidget(test_shortcut_btn)
        test_layout.addStretch()
        layout.addLayout(test_layout)

        # Nota final
        note_label = QLabel(
            "üí° Tip: Los cambios se aplican inmediatamente al presionar 'Aplicar' o 'Aceptar'.\n"
            "No es necesario reiniciar la aplicaci√≥n."
        )
        note_label.setStyleSheet(
            "color: #ffc107; font-size: 9pt; padding: 10px; "
            "background-color: rgba(255, 193, 7, 0.1); border-radius: 5px; margin-top: 10px;"
        )
        note_label.setWordWrap(True)
        layout.addWidget(note_label)

        layout.addStretch()

        return tab

    def setup_style(self):
        """Configurar estilo del di√°logo"""
        self.setStyleSheet(self.theme_manager.get_stylesheet("dialog"))

    def load_current_config(self):
        """Cargar configuraci√≥n actual"""
        # Apariencia
        theme = self.config_manager.get("appearance", "theme", "dark")
        # Seleccionar el tema en el combo
        for i in range(self.theme_combo.count()):
            if self.theme_combo.itemData(i) == theme:
                self.theme_combo.setCurrentIndex(i)
                break

        self.animations_enabled.setChecked(
            self.config_manager.get("appearance", "animations_enabled", True)
        )
        self.show_tooltips.setChecked(
            self.config_manager.get("appearance", "show_tooltips", True)
        )

        opacity = int(
            self.config_manager.get("appearance", "window_opacity", 1.0) * 100
        )
        self.opacity_slider.setValue(opacity)

        # Rendimiento
        self.max_clipboard_items.setValue(
            self.config_manager.get("performance", "max_clipboard_items", 50)
        )
        self.cache_enabled.setChecked(
            self.config_manager.get("performance", "cache_enabled", True)
        )
        self.virtual_scrolling.setChecked(
            self.config_manager.get("performance", "virtual_scrolling", True)
        )
        self.max_display_items.setValue(
            self.config_manager.get("performance", "max_display_items", 500)
        )

        # Comportamiento
        self.auto_save_interval.setValue(
            self.config_manager.get("behavior", "auto_save_interval", 30)
        )
        self.confirm_deletions.setChecked(
            self.config_manager.get("behavior", "confirm_deletions", True)
        )
        self.remember_window_positions.setChecked(
            self.config_manager.get("behavior", "remember_window_positions", True)
        )
        self.enable_plugins.setChecked(
            self.config_manager.get("behavior", "enable_plugins", True)
        )

        self.start_in_background.setChecked(
            self.config_manager.get("behavior", "start_in_background", False)
        )

        self.close_quick_paste_after_pasting.setChecked(
            self.config_manager.get("behavior", "close_quick_paste_after_pasting", True)
        )

        self.use_global_quick_paste.setChecked(
            self.config_manager.get("behavior", "use_global_quick_paste", False)
        )

        # Cargar estado de inicio autom√°tico de Windows
        self.auto_start_windows.setChecked(
            self.config_manager.get("behavior", "auto_start_windows", False)
        )

        # Atajos de teclado
        self.show_window_shortcut.setText(
            self.config_manager.get("shortcuts", "show_window", "<ctrl>+<alt>+s")
        )
        self.hide_window_shortcut.setText(
            self.config_manager.get("shortcuts", "hide_window", "<ctrl>+<alt>+h")
        )
        self.quick_paste_shortcut.setText(
            self.config_manager.get("shortcuts", "quick_paste", "<ctrl>+<alt>+v")
        )
        self.quick_copy_shortcut.setText(
            self.config_manager.get("shortcuts", "quick_copy", "<ctrl>+<alt>+c")
        )

        # Dashboard
        dashboard_enabled = self.config_manager.get("dashboard", "enabled", False)
        if dashboard_enabled:
            self.dashboard_status_label.setText("Estado: Activado")
            self.dashboard_status_label.setStyleSheet(
                "color: #26de81; font-weight: bold; font-size: 11pt;"
            )
            self.activate_dashboard_btn.setEnabled(False)
            self.deactivate_dashboard_btn.setEnabled(True)
        else:
            self.dashboard_status_label.setText("Estado: Desactivado")
            self.dashboard_status_label.setStyleSheet(
                "color: #ff4444; font-weight: bold; font-size: 11pt;"
            )
            self.activate_dashboard_btn.setEnabled(True)
            self.deactivate_dashboard_btn.setEnabled(False)

    def apply_changes(self):
        """Aplicar cambios sin cerrar"""
        self.save_config()
        # Aplicar cambios en la ventana principal inmediatamente
        if hasattr(self.parent(), "apply_config_changes"):
            self.parent().apply_config_changes()

    def accept_changes(self):
        """Aceptar y cerrar"""
        self.save_config()
        self.accept()

    def save_config(self):
        """Guardar configuraci√≥n"""
        # Apariencia - obtener tema seleccionado del combo
        theme = self.theme_combo.currentData()
        self.config_manager.set("appearance", "theme", theme)
        self.config_manager.set(
            "appearance", "animations_enabled", self.animations_enabled.isChecked()
        )
        self.config_manager.set(
            "appearance", "show_tooltips", self.show_tooltips.isChecked()
        )
        self.config_manager.set(
            "appearance", "window_opacity", self.opacity_slider.value() / 100.0
        )

        # Rendimiento
        self.config_manager.set(
            "performance", "max_clipboard_items", self.max_clipboard_items.value()
        )
        self.config_manager.set(
            "performance", "cache_enabled", self.cache_enabled.isChecked()
        )
        self.config_manager.set(
            "performance", "virtual_scrolling", self.virtual_scrolling.isChecked()
        )
        self.config_manager.set(
            "performance", "max_display_items", self.max_display_items.value()
        )

        # Comportamiento
        self.config_manager.set(
            "behavior", "auto_save_interval", self.auto_save_interval.value()
        )
        self.config_manager.set(
            "behavior", "confirm_deletions", self.confirm_deletions.isChecked()
        )
        self.config_manager.set(
            "behavior",
            "remember_window_positions",
            self.remember_window_positions.isChecked(),
        )
        self.config_manager.set(
            "behavior", "enable_plugins", self.enable_plugins.isChecked()
        )

        self.config_manager.set(
            "behavior", "start_in_background", self.start_in_background.isChecked()
        )

        self.config_manager.set(
            "behavior",
            "close_quick_paste_after_pasting",
            self.close_quick_paste_after_pasting.isChecked(),
        )

        self.config_manager.set(
            "behavior",
            "use_global_quick_paste",
            self.use_global_quick_paste.isChecked(),
        )

        # Atajos de teclado
        self.config_manager.set(
            "shortcuts", "show_window", self.show_window_shortcut.text().strip()
        )
        self.config_manager.set(
            "shortcuts", "hide_window", self.hide_window_shortcut.text().strip()
        )
        self.config_manager.set(
            "shortcuts", "quick_paste", self.quick_paste_shortcut.text().strip()
        )
        self.config_manager.set(
            "shortcuts", "quick_copy", self.quick_copy_shortcut.text().strip()
        )

        # No guardamos auto_start_windows aqu√≠ porque se maneja con on_auto_start_toggled

    def reset_to_defaults(self):
        """Restablecer a valores por defecto"""
        result = QMessageBox.question(
            self,
            "Confirmar Restablecimiento",
            "¬øDeseas restablecer todas las configuraciones a sus valores por defecto?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
        )

        if result == QMessageBox.StandardButton.Yes:
            self.config_manager.config = self.config_manager.default_config.copy()
            self.config_manager.save_config()
            self.load_current_config()

    def preview_theme(self):
        """Vista previa del tema seleccionado"""
        theme_key = self.theme_combo.currentData()
        if theme_key:
            # Aplicar temporalmente el tema al di√°logo
            self.theme_manager.set_theme(theme_key)
            self.setStyleSheet(self.theme_manager.get_stylesheet("dialog"))

    def on_opacity_changed(self, value):
        """Vista previa de opacidad en tiempo real"""
        if hasattr(self.parent(), "setWindowOpacity"):
            opacity = value / 100.0
            self.parent().setWindowOpacity(opacity)

    def on_auto_start_toggled(self, checked):
        """Manejar cambio en inicio autom√°tico de Windows"""
        if checked:
            success = self.create_windows_startup_shortcut()
            if success:
                self.config_manager.set("behavior", "auto_start_windows", True)
                QMessageBox.information(
                    self,
                    "‚úÖ Inicio Autom√°tico Activado",
                    "Se ha creado un acceso directo en la carpeta de inicio de Windows.\n\n"
                    "La aplicaci√≥n se iniciar√° autom√°ticamente al encender el ordenador.\n\n"
                    "Nota: Si est√°s ejecutando desde Python, se crear√° el acceso directo\n"
                    "pero podr√≠a no funcionar correctamente. Es recomendable usar un .exe compilado.",
                )
            else:
                # Si falla, desmarcar el checkbox
                self.auto_start_windows.setChecked(False)
                QMessageBox.warning(
                    self,
                    "‚ùå Error",
                    "No se pudo crear el acceso directo en la carpeta de inicio.\n\n"
                    "Verifica que tengas permisos suficientes.",
                )
        else:
            success = self.remove_windows_startup_shortcut()
            if success:
                self.config_manager.set("behavior", "auto_start_windows", False)
                QMessageBox.information(
                    self,
                    "üóëÔ∏è Inicio Autom√°tico Desactivado",
                    "Se ha eliminado el acceso directo de la carpeta de inicio de Windows.\n\n"
                    "La aplicaci√≥n ya no se iniciar√° autom√°ticamente.",
                )
            else:
                # Si falla, volver a marcar el checkbox
                self.auto_start_windows.setChecked(True)

    def create_windows_startup_shortcut(self):
        """Crear acceso directo en la carpeta de inicio de Windows"""
        try:
            import win32com.client

            # Obtener ruta de la carpeta de inicio
            startup_folder = os.path.join(
                os.getenv("APPDATA"),
                "Microsoft",
                "Windows",
                "Start Menu",
                "Programs",
                "Startup",
            )

            # Crear nombre del acceso directo
            shortcut_path = os.path.join(startup_folder, "GestorArchivos.lnk")

            # Obtener ruta del ejecutable actual
            if getattr(sys, "frozen", False):
                # Si es un .exe compilado
                target_path = sys.executable
            else:
                # Si se ejecuta desde Python
                target_path = os.path.abspath(sys.argv[0])

            # Crear el acceso directo
            shell = win32com.client.Dispatch("WScript.Shell")
            shortcut = shell.CreateShortCut(shortcut_path)
            shortcut.TargetPath = target_path
            shortcut.WorkingDirectory = os.path.dirname(target_path)
            shortcut.Description = "Gestor de Archivos y Carpetas"

            # Si es Python, usar el int√©rprete de Python
            if not getattr(sys, "frozen", False):
                shortcut.TargetPath = sys.executable
                shortcut.Arguments = f'"{target_path}"'

            shortcut.save()

            print(f"Acceso directo creado en: {shortcut_path}")
            return True

        except Exception as e:
            print(f"Error creando acceso directo: {e}")
            return False

    def remove_windows_startup_shortcut(self):
        """Eliminar acceso directo de la carpeta de inicio de Windows"""
        try:
            # Obtener ruta de la carpeta de inicio
            startup_folder = os.path.join(
                os.getenv("APPDATA"),
                "Microsoft",
                "Windows",
                "Start Menu",
                "Programs",
                "Startup",
            )

            # Ruta del acceso directo
            shortcut_path = os.path.join(startup_folder, "GestorArchivos.lnk")

            # Eliminar si existe
            if os.path.exists(shortcut_path):
                os.remove(shortcut_path)
                print(f"Acceso directo eliminado: {shortcut_path}")
                return True
            else:
                print("El acceso directo no existe")
                return True  # No es un error si no existe

        except Exception as e:
            print(f"Error eliminando acceso directo: {e}")
            return False

    def test_shortcuts(self):
        """Probar los atajos de teclado configurados"""
        show_shortcut = self.show_window_shortcut.text().strip()
        hide_shortcut = self.hide_window_shortcut.text().strip()
        paste_shortcut = self.quick_paste_shortcut.text().strip()
        copy_shortcut = self.quick_copy_shortcut.text().strip()

        # Verificar que todos los atajos est√©n configurados
        if (
            not show_shortcut
            or not hide_shortcut
            or not paste_shortcut
            or not copy_shortcut
        ):
            QMessageBox.warning(
                self,
                "‚ö†Ô∏è Atajos Vac√≠os",
                "Por favor, configura todos los atajos antes de probarlos.",
            )
            return

        # Validar formato b√°sico
        valid_patterns = ["<ctrl>", "<alt>", "<shift>"]

        def validate_shortcut(shortcut):
            shortcut_lower = shortcut.lower()
            has_modifier = any(mod in shortcut_lower for mod in valid_patterns)
            has_plus = "+" in shortcut
            return has_modifier and has_plus

        # Validar todos los atajos
        shortcuts_to_validate = [
            ("Mostrar Ventana", show_shortcut),
            ("Ocultar Ventana", hide_shortcut),
            ("Pegado R√°pido", paste_shortcut),
            ("Copiar Archivos", copy_shortcut),
        ]

        invalid_shortcuts = []
        for name, shortcut in shortcuts_to_validate:
            if not validate_shortcut(shortcut):
                invalid_shortcuts.append(f"‚Ä¢ {name}: {shortcut}")

        if invalid_shortcuts:
            QMessageBox.warning(
                self,
                "‚ö†Ô∏è Formato Inv√°lido",
                "Los siguientes atajos tienen formato inv√°lido:\n\n"
                + "\n".join(invalid_shortcuts)
                + "\n\n"
                + "Los atajos deben seguir el formato:\n"
                "<ctrl>+<alt>+tecla\n\n"
                "Ejemplos v√°lidos:\n"
                "‚Ä¢ <ctrl>+<alt>+s\n"
                "‚Ä¢ <ctrl>+<shift>+h\n"
                "‚Ä¢ <ctrl>+<alt>+<shift>+m",
            )
            return

        # Verificar duplicados
        shortcuts_dict = {}
        duplicates = []
        for name, shortcut in shortcuts_to_validate:
            if shortcut in shortcuts_dict:
                duplicates.append(f"‚Ä¢ {shortcut}: {shortcuts_dict[shortcut]} y {name}")
            else:
                shortcuts_dict[shortcut] = name

        if duplicates:
            QMessageBox.warning(
                self,
                "‚ö†Ô∏è Atajos Duplicados",
                "Los siguientes atajos est√°n duplicados:\n\n"
                + "\n".join(duplicates)
                + "\n\n"
                + "Cada atajo debe ser √∫nico.",
            )
            return

        QMessageBox.information(
            self,
            "‚úÖ Atajos V√°lidos",
            f"Todos los atajos configurados son v√°lidos:\n\n"
            f"üîº Mostrar Ventana: {show_shortcut}\n"
            f"üîΩ Ocultar Ventana: {hide_shortcut}\n"
            f"üìã Pegado R√°pido: {paste_shortcut}\n"
            f"üìÇ Copiar Archivos: {copy_shortcut}\n\n"
            f"Haz clic en 'Aplicar' o 'Aceptar' para guardar los cambios.\n"
            f"Los atajos se activar√°n inmediatamente al aplicar.",
        )

    def restore_geometry(self):
        """Restaurar geometr√≠a de la ventana"""
        self.geometry_manager.restore_window_geometry(
            self, "advanced_config", (700, 780)
        )

    def closeEvent(self, event):
        """Guardar geometr√≠a al cerrar"""
        self.geometry_manager.save_window_geometry("advanced_config", self.geometry())
        super().closeEvent(event)

    def activate_dashboard(self):
        """Activar Dashboard con contrase√±a"""
        password = self.dashboard_password_input.text()

        if password == "activedashboard":
            # Guardar configuraci√≥n
            self.config_manager.set("dashboard", "enabled", True)
            self.config_manager.set("dashboard", "password_used", True)

            # Actualizar estado visual
            self.dashboard_status_label.setText("Estado: Activado")
            self.dashboard_status_label.setStyleSheet(
                "color: #26de81; font-weight: bold; font-size: 11pt;"
            )

            # Deshabilitar bot√≥n de activar y habilitar desactivar
            self.activate_dashboard_btn.setEnabled(False)
            self.deactivate_dashboard_btn.setEnabled(True)

            # Limpiar campo de contrase√±a
            self.dashboard_password_input.clear()

            # Mostrar mensaje de √©xito
            QMessageBox.information(
                self,
                "‚úÖ Dashboard Activado",
                "El Dashboard ha sido activado correctamente.\n\n"
                "Reinicia la aplicaci√≥n para ver la pesta√±a Dashboard.",
            )

        else:
            QMessageBox.warning(
                self,
                "‚ùå Contrase√±a Incorrecta",
                "La contrase√±a ingresada no es correcta.\n\n"
                "Verifica la contrase√±a e intenta nuevamente.",
            )

    def deactivate_dashboard(self):
        """Desactivar Dashboard con contrase√±a"""
        password = self.dashboard_password_input.text()

        if password == "desactivedashboard":
            # Guardar configuraci√≥n
            self.config_manager.set("dashboard", "enabled", False)
            self.config_manager.set("dashboard", "password_used", True)

            # Actualizar estado visual
            self.dashboard_status_label.setText("Estado: Desactivado")
            self.dashboard_status_label.setStyleSheet(
                "color: #ff4444; font-weight: bold; font-size: 11pt;"
            )

            # Habilitar bot√≥n de activar y deshabilitar desactivar
            self.activate_dashboard_btn.setEnabled(True)
            self.deactivate_dashboard_btn.setEnabled(False)

            # Limpiar campo de contrase√±a
            self.dashboard_password_input.clear()

            # Mostrar mensaje de √©xito
            QMessageBox.information(
                self,
                "üîí Dashboard Desactivado",
                "El Dashboard ha sido desactivado correctamente.\n\n"
                "Reinicia la aplicaci√≥n para que los cambios surtan efecto.",
            )

        else:
            QMessageBox.warning(
                self,
                "‚ùå Contrase√±a Incorrecta",
                "La contrase√±a ingresada no es correcta.\n\n"
                "Verifica la contrase√±a e intenta nuevamente.",
            )


class QuickPasteDialog(QDialog):
    """Di√°logo de pegado r√°pido con Ctrl+Alt+V"""

    def __init__(self, items_list, parent=None):
        super().__init__(parent)
        self.items_list = items_list
        self.selected_items = []
        self.config_manager = AdvancedConfigManager()
        self.setWindowTitle("‚ö° Pegado R√°pido - Ctrl+Alt+V")
        set_window_icon(self)
        self.setWindowFlags(Qt.WindowType.Dialog | Qt.WindowType.WindowStaysOnTopHint)
        self.setMinimumSize(500, 400)
        self.resize(700, 600)
        self.geometry_manager = WindowGeometryManager()
        self.theme_manager = ThemeManager()
        self.setup_ui()
        self.setup_style()
        self.setup_shortcuts()
        self.position_near_cursor()

    def setup_ui(self):
        """Configurar interfaz de pegado r√°pido"""
        layout = QVBoxLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)

        # Obtener directorio m√°s relevante
        current_dir = self.get_current_working_directory()
        # Normalizar ruta para soportar rutas de red UNC correctamente
        current_dir = normalize_network_path(current_dir)
        title_label = QLabel(f"‚ö° Pegado R√°pido al Directorio Actual")
        title_font = QFont()
        title_font.setBold(True)
        title_font.setPointSize(11)
        title_label.setFont(title_font)
        title_label.setStyleSheet("color: #4a90e2; margin-bottom: 5px;")
        layout.addWidget(title_label)

        # Mostrar directorio actual
        dir_label = QLabel(f"üìÅ Destino: {current_dir}")
        dir_label.setStyleSheet(
            "color: #cccccc; font-size: 9pt; margin-bottom: 10px; font-family: 'Consolas', monospace;"
        )
        dir_label.setWordWrap(True)
        layout.addWidget(dir_label)

        # Lista de archivos disponibles
        # Bot√≥n para cambiar directorio
        change_dir_layout = QHBoxLayout()
        change_dir_btn = QPushButton("üìÇ Cambiar Destino")
        change_dir_btn.clicked.connect(self.change_destination_directory)
        change_dir_btn.setStyleSheet("""
            QPushButton {
                background-color: #6f42c1;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px 12px;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #5a32a3;
            }
        """)
        change_dir_layout.addWidget(change_dir_btn)
        change_dir_layout.addStretch()
        layout.addLayout(change_dir_layout)

        # T√≠tulo con info del directorio actual
        info_label = QLabel(
            f"Selecciona archivos para pegar ({len(self.items_list)} disponibles):"
        )
        info_label.setStyleSheet("color: #ffffff; font-weight: bold;")
        layout.addWidget(info_label)

        # TreeWidget compacto con columna de renombrado
        self.items_tree = QTreeWidget()
        self.items_tree.setHeaderLabels(
            ["", "Archivo/Carpeta", "Nuevo Nombre", "Ubicaci√≥n"]
        )
        self.items_tree.setRootIsDecorated(False)
        self.items_tree.setAlternatingRowColors(True)
        self.items_tree.setMaximumHeight(200)

        # Poblar con archivos guardados
        for item in self.items_list:
            tree_item = QTreeWidgetItem()
            tree_item.setFlags(
                tree_item.flags()
                | Qt.ItemFlag.ItemIsUserCheckable
                | Qt.ItemFlag.ItemIsEditable
            )
            tree_item.setCheckState(0, Qt.CheckState.Checked)

            # Icono y nombre
            icon = get_file_icon_by_extension(item.path, item.is_directory)
            tree_item.setText(1, f"{icon} {item.name}")
            tree_item.setText(2, item.name)  # Nuevo nombre (editable - doble click)
            tree_item.setText(3, item.path)
            tree_item.setData(0, Qt.ItemDataRole.UserRole, item)
            tree_item.setToolTip(2, "Doble click para editar el nombre")

            # Color por tipo
            if item.is_directory:
                tree_item.setBackground(1, QColor(54, 162, 235, 30))
            else:
                tree_item.setBackground(1, QColor(75, 192, 192, 30))

            # Color especial para columna editable
            tree_item.setBackground(2, QColor(100, 200, 100, 20))

            self.items_tree.addTopLevelItem(tree_item)

        # Ajustar columnas
        self.items_tree.resizeColumnToContents(0)
        self.items_tree.resizeColumnToContents(1)

        # Conectar doble click para edici√≥n controlada
        self.items_tree.itemDoubleClicked.connect(self.on_item_double_clicked)

        layout.addWidget(self.items_tree)

        # Botones de selecci√≥n r√°pida
        selection_layout = QHBoxLayout()

        select_all_btn = QPushButton("‚òë Todo")
        select_all_btn.setMaximumWidth(60)
        select_all_btn.clicked.connect(self.select_all)

        select_none_btn = QPushButton("‚òê Nada")
        select_none_btn.setMaximumWidth(60)
        select_none_btn.clicked.connect(self.select_none)

        selection_layout.addWidget(select_all_btn)
        selection_layout.addWidget(select_none_btn)
        selection_layout.addStretch()

        layout.addLayout(selection_layout)

        # Informaci√≥n de selecci√≥n
        self.selection_info = QLabel("Todos los elementos seleccionados")
        self.selection_info.setStyleSheet(
            "color: #888888; font-style: italic; font-size: 8pt;"
        )
        layout.addWidget(self.selection_info)

        # Opci√≥n para cerrar despu√©s de pegar
        close_after_layout = QHBoxLayout()
        self.close_after_paste_check = QCheckBox("Cerrar ventana despu√©s de pegar")
        self.close_after_paste_check.setChecked(
            self.config_manager.get("behavior", "close_quick_paste_after_pasting", True)
        )
        self.close_after_paste_check.setToolTip(
            "Si est√° marcado, la ventana se cerrar√° autom√°ticamente despu√©s de pegar.\n"
            "Si no est√° marcado, la ventana permanecer√° abierta para pegar m√°s archivos."
        )
        self.close_after_paste_check.toggled.connect(self.on_close_after_paste_toggled)
        self.close_after_paste_check.setStyleSheet("""
            QCheckBox {
                color: #cccccc;
                font-size: 9pt;
                padding: 5px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
        """)
        close_after_layout.addWidget(self.close_after_paste_check)
        close_after_layout.addStretch()
        layout.addLayout(close_after_layout)

        # Botones principales
        buttons_layout = QHBoxLayout()

        self.paste_btn = QPushButton("‚ö° Pegar Aqu√≠")
        self.paste_btn.clicked.connect(self.quick_paste)
        self.paste_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
                font-size: 10pt;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)

        self.cancel_btn = QPushButton("‚ùå Cancelar")
        self.cancel_btn.clicked.connect(self.reject)

        buttons_layout.addWidget(self.paste_btn)
        buttons_layout.addWidget(self.cancel_btn)
        layout.addLayout(buttons_layout)

        # Conectar se√±ales
        self.items_tree.itemChanged.connect(self.update_selection_info)
        self.update_selection_info()

    def setup_style(self):
        """Configurar estilo del di√°logo"""
        self.setStyleSheet("""
            QDialog {
                background-color: #1a1a1a;
                color: #ffffff;
            }
            QTreeWidget {
                background-color: #ffffff;
                color: #333333;
                border: 1px solid #555555;
                border-radius: 4px;
                alternate-background-color: #3a3a3a;
            }
            QTreeWidget::item {
                padding: 3px;
                border: none;
            }
            QTreeWidget::item:hover {
                background-color: #454545;
            }
            QHeaderView::section {
                background-color: #3a3a3a;
                color: #ffffff;
                padding: 5px;
                border: 1px solid #555555;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton {
                background-color: #217346;
                border: none;
                border-radius: 4px;
                color: white;
                padding: 6px 12px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #357abd;
            }
        """)

    def setup_shortcuts(self):
        """Configurar atajos de teclado"""
        from PyQt6.QtGui import QShortcut

        # Enter para pegar
        enter_shortcut = QShortcut(QKeySequence("Return"), self)
        enter_shortcut.activated.connect(self.quick_paste)

        # Escape para cancelar
        escape_shortcut = QShortcut(QKeySequence("Escape"), self)
        escape_shortcut.activated.connect(self.reject)

        # Ctrl+A para seleccionar todo
        select_all_shortcut = QShortcut(QKeySequence("Ctrl+A"), self)
        select_all_shortcut.activated.connect(self.select_all)

    def select_all(self):
        """Seleccionar todos los elementos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Checked)

    def select_none(self):
        """Deseleccionar todos los elementos"""
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Unchecked)

    def on_item_double_clicked(self, item, column):
        """Permitir edici√≥n solo en la columna 'Nuevo Nombre' (columna 2)"""
        if column == 2:
            self.items_tree.editItem(item, column)

    def update_selection_info(self):
        """Actualizar informaci√≥n de selecci√≥n"""
        selected_count = 0
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                selected_count += 1

        if selected_count == 0:
            self.selection_info.setText("Ning√∫n elemento seleccionado")
            self.paste_btn.setEnabled(False)
        else:
            self.selection_info.setText(
                f"{selected_count} elementos seleccionados para pegar"
            )
            self.paste_btn.setEnabled(True)

    def on_close_after_paste_toggled(self, checked):
        """Guardar configuraci√≥n cuando cambia la opci√≥n de cerrar despu√©s de pegar"""
        self.config_manager.set("behavior", "close_quick_paste_after_pasting", checked)

    def quick_paste(self):
        """Realizar pegado r√°pido"""
        # Obtener elementos seleccionados con sus nuevos nombres
        selected_items = []
        custom_names = {}
        for i in range(self.items_tree.topLevelItemCount()):
            item = self.items_tree.topLevelItem(i)
            if item.checkState(0) == Qt.CheckState.Checked:
                file_item = item.data(0, Qt.ItemDataRole.UserRole)
                if file_item:
                    selected_items.append(file_item)
                    # Guardar nombre personalizado si fue editado
                    custom_name = item.text(2).strip()
                    if custom_name and custom_name != file_item.name:
                        custom_names[file_item.path] = custom_name

        if not selected_items:
            QMessageBox.information(
                self, "Sin Selecci√≥n", "Selecciona al menos un elemento para pegar."
            )
            return

        # Directorio de destino
        destination_dir = self.get_current_working_directory()
        # Normalizar ruta para soportar rutas de red UNC correctamente
        destination_dir = normalize_network_path(destination_dir)

        # Verificar permisos de escritura
        if not os.access(destination_dir, os.W_OK):
            QMessageBox.critical(
                self,
                "Error de Permisos",
                f"No tienes permisos de escritura en:\n{destination_dir}",
            )
            return

        # Procesar copia
        self.paste_btn.setEnabled(False)
        self.paste_btn.setText("Copiando...")

        copied_files = []
        errors = []

        try:
            for item in selected_items:
                try:
                    source_path = item.path
                    if not os.path.exists(source_path):
                        errors.append(f"{item.name}: Archivo origen no existe")
                        continue

                    # Usar nombre personalizado si existe, sino el original
                    item_name = custom_names.get(
                        item.path, os.path.basename(source_path)
                    )
                    dest_path = os.path.join(destination_dir, item_name)

                    # Manejar archivos existentes
                    counter = 1
                    original_dest = dest_path
                    while os.path.exists(dest_path):
                        name, ext = os.path.splitext(item_name)
                        if item.is_directory:
                            new_name = f"{name} - Copia ({counter})"
                        else:
                            new_name = f"{name} - Copia ({counter}){ext}"
                        dest_path = os.path.join(destination_dir, new_name)
                        counter += 1

                    # Copiar
                    import shutil

                    if item.is_directory:
                        shutil.copytree(source_path, dest_path)
                    else:
                        shutil.copy2(source_path, dest_path)

                    copied_files.append(dest_path)

                except Exception as e:
                    errors.append(f"{item.name}: {str(e)}")

                # Actualizar UI
                QApplication.processEvents()

            # Mostrar resultado
            if copied_files:
                if errors:
                    QMessageBox.warning(
                        self,
                        "Pegado Parcial",
                        f"‚úÖ {len(copied_files)} archivos copiados.\n‚ùå {len(errors)} errores.",
                    )
                else:
                    # Mostrar notificaci√≥n exitosa
                    self.show_success_notification(len(copied_files), destination_dir)

                    # Cerrar autom√°ticamente solo si la opci√≥n est√° marcada
                    if self.close_after_paste_check.isChecked():
                        QTimer.singleShot(
                            1500, self.accept
                        )  # Auto-cerrar despu√©s de 1.5 segundos
                    else:
                        # Desmarcar todos los items despu√©s de pegar si no se cierra
                        self.select_none()
            else:
                QMessageBox.critical(self, "Error", "No se pudo copiar ning√∫n archivo.")

        except Exception as e:
            QMessageBox.critical(
                self, "Error Inesperado", f"Error durante el pegado:\n{str(e)}"
            )

        finally:
            self.paste_btn.setEnabled(True)
            self.paste_btn.setText("‚ö° Pegar Aqu√≠")

    def show_success_notification(self, count, destination):
        """Mostrar notificaci√≥n de √©xito visual"""
        # Cambiar apariencia temporal para indicar √©xito
        self.setStyleSheet(
            self.styleSheet()
            + """
            QDialog {
                border: 2px solid #28a745;
                background-color: #1a2e1a;
            }
        """
        )

        # Actualizar t√≠tulo temporalmente
        self.setWindowTitle(f"‚úÖ ¬°{count} archivos pegados exitosamente!")

        # Mostrar mensaje en el di√°logo
        success_label = QLabel(f"‚úÖ ¬°Pegado exitoso! {count} archivos copiados")
        success_label.setStyleSheet("""
            color: #28a745;
            font-weight: bold;
            padding: 10px;
            background-color: rgba(40, 167, 69, 0.2);
            border-radius: 4px;
        """)

        # Insertar temporalmente en el layout
        layout = self.layout()
        layout.insertWidget(0, success_label)

        # Remover despu√©s de un tiempo
        QTimer.singleShot(1200, lambda: success_label.deleteLater())

    def position_near_cursor(self):
        """Posicionar ventana cerca del cursor del mouse"""
        from PyQt6.QtGui import QCursor

        cursor_pos = QCursor.pos()
        dialog_size = self.size()

        # Obtener informaci√≥n de la pantalla
        screen = QApplication.screenAt(cursor_pos)
        if screen:
            screen_geometry = screen.geometry()

            # Calcular posici√≥n cerca del cursor pero dentro de la pantalla
            x = cursor_pos.x() + 20  # Offset del cursor
            y = cursor_pos.y() + 20

            # Ajustar si se sale de la pantalla por la derecha
            if x + dialog_size.width() > screen_geometry.right():
                x = cursor_pos.x() - dialog_size.width() - 20

            # Ajustar si se sale de la pantalla por abajo
            if y + dialog_size.height() > screen_geometry.bottom():
                y = cursor_pos.y() - dialog_size.height() - 20

            # Asegurar que no se salga por la izquierda o arriba
            x = max(screen_geometry.left(), x)
            y = max(screen_geometry.top(), y)

            self.move(x, y)
        else:
            # Fallback: centrar en la pantalla principal
            self.move(
                cursor_pos.x() - dialog_size.width() // 2,
                cursor_pos.y() - dialog_size.height() // 2,
            )

    def get_current_working_directory(self):
        """Obtener el directorio de trabajo m√°s relevante"""
        try:
            # Intentar obtener el directorio actual del proceso
            cwd = os.getcwd()

            # Si estamos en el directorio de la aplicaci√≥n, intentar algo m√°s √∫til
            app_dir = os.path.dirname(os.path.abspath(__file__))

            if cwd == app_dir:
                # Si estamos en el directorio de la app, usar el escritorio como alternativa
                desktop = os.path.join(os.path.expanduser("~"), "Desktop")
                if os.path.exists(desktop):
                    return desktop
                else:
                    # Si no existe Desktop, usar home
                    return os.path.expanduser("~")

            return cwd

        except Exception as e:
            # Fallback al home del usuario
            return os.path.expanduser("~")

    def change_destination_directory(self):
        """Cambiar directorio de destino desde el di√°logo de pegado r√°pido"""
        current_dir = self.get_current_working_directory()

        new_dir = QFileDialog.getExistingDirectory(
            self,
            "Seleccionar Nuevo Directorio de Destino",
            current_dir,
            QFileDialog.Option.ShowDirsOnly | QFileDialog.Option.DontResolveSymlinks,
        )

        if new_dir:
            try:
                # Normalizar ruta para soportar rutas de red UNC correctamente
                new_dir = normalize_network_path(new_dir)
                os.chdir(new_dir)
                # Actualizar la etiqueta del directorio
                new_current_dir = self.get_current_working_directory()
                new_current_dir = normalize_network_path(new_current_dir)

                # Buscar y actualizar el label del directorio
                for i in range(self.layout().count()):
                    item = self.layout().itemAt(i)
                    if item and item.widget() and isinstance(item.widget(), QLabel):
                        widget = item.widget()
                        if widget.text().startswith("üìÅ Destino:"):
                            widget.setText(f"üìÅ Destino: {new_current_dir}")
                            break

                QMessageBox.information(
                    self,
                    "üìÇ Destino Cambiado",
                    f"‚úÖ Nuevo directorio de destino:\nüìÅ {new_current_dir}",
                )
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "‚ùå Error",
                    f"No se pudo cambiar al directorio:\n{new_dir}\n\nError: {str(e)}",
                )


def main():
    """Funci√≥n principal"""
    app = QApplication(sys.argv)
    app.setApplicationName("Gestor de Archivos y Carpetas")
    app.setApplicationVersion("2.1")

    # Configurar aplicaci√≥n
    app.setOrganizationName("FileManager Pro")
    app.setOrganizationDomain("filemanager.pro")

    # Configurar icono de la aplicaci√≥n
    icon_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "logo_sin_f.png"
    )
    if os.path.exists(icon_path):
        app.setWindowIcon(QIcon(icon_path))

    # Crear ventana principal
    window = MainWindow()

    # Verificar si debe iniciar en segundo plano
    # Si no est√° configurado para segundo plano, mostrar la ventana
    config_manager = AdvancedConfigManager()
    start_in_background = config_manager.get("behavior", "start_in_background", False)
    if not start_in_background:
        window.show()

    # Ejecutar aplicaci√≥n
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
